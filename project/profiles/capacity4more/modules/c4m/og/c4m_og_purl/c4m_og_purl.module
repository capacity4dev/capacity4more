<?php

/**
 * @file
 * Hooks & plugins for the c4m_og_purl module.
 */

// Link types that can be used to auto-magically create the proper URL.
define('C4M_OG_PURL_LINK_AUTO', 'purl_auto');
define('C4M_OG_PURL_LINK_DISABLED', 'purl_disabled');
define('C4M_OG_PURL_LINK_DASHBOARD', 'purl_og_dashboard');

include_once 'c4m_og_purl.ds_render_field.inc';
include_once 'c4m_og_purl.uri_info.inc';

/**
 * Implements hook_init().
 *
 * Redirect /node/GROUP_ID path to the group dashboard /GROUP-TITLE.
 * Denies access to global pages, if under OG context (under PURL).
 */
function c4m_og_purl_init() {
  // Redirect based on purl aliases.
  c4m_og_purl_redirect();

  $item = menu_get_item();

  if (empty($item['path'])) {
    return;
  }

  if ($item['path'] === 'node/%') {
    if (!isset($item['map'][1])) {
      return;
    }
    // We are not in node view.
    $node = $item['map'][1];

    if (!og_is_group_type('node', $node->type)) {

      $context = og_context();
      $group = c4m_og_get_group_of_content($node);

      if ($group xor $context) {
        // We should never have context for a node that is not part of og.
        c4m_content_deny_access();
      }

      // Group content must be displayed within its group context.
      if ($group && $group->nid != $context['gid']) {
        c4m_content_deny_access();
      }

      // This is not a group.
      return;
    }

    drupal_goto($node->purl);
  }

  if (c4m_og_purl_context_conflict_page()) {
    // Conflict between menu item and context.
    drupal_access_denied();
    drupal_exit();
  }
}

/**
 * Redirects based on purl aliases.
 */
function c4m_og_purl_redirect() {
  if (!db_table_exists('c4m_og_purl_aliases')) {
    return;
  }

  $path = current_path();
  $args = explode('/', $path);
  $arg = $args[0];
  $alias = db_query('SELECT new_path FROM {c4m_og_purl_aliases} WHERE old_path = :old_path', [':old_path' => $arg])->fetchField();
  if ($alias) {
    $args[0] = $alias;
    $new_path = implode('/', $args);
    $options = ['query' => drupal_get_query_parameters()];
    // If destination is present in query params it may override the redirect.
    unset($_GET['destination']);
    drupal_goto($new_path, $options, '301');
  }
}

/**
 * Check whether there is a conflict between the current menu item and context.
 *
 * A conflict between the menu item and context happens when adding a purl path
 * to a global page.
 *
 * @return bool
 *   TRUE if there is a conflict, otherwise returns FALSE.
 */
function c4m_og_purl_context_conflict_page() {
  $item = menu_get_item();
  // Menu items prefixes, which we allow to be accessed under OG context.
  $group_allowed_path = _c4m_og_purl_allowed_paths();

  return og_context() && !_c4m_og_purl_starts_with_in_array($group_allowed_path, $item['path']);
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Prevent PURL prefix from appearing at page links, if they don't point
 * to group content.
 */
function c4m_og_purl_url_outbound_alter(&$path, &$options, $original_path) {
  if (drupal_is_cli()) {
    // The script is running in a command-line environment.
    return;
  }

  // When explicitly creating a url with purl enabled.
  if (!empty($options['purl']['enabled'])) {
    return;
  }

  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);
    return;
  }

  // Path prefixes, which we allow to be accessed under OG context.
  $group_allowed_path = _c4m_og_purl_allowed_paths();
  $context = og_context();

  if ($context) {
    if (!_c4m_og_purl_starts_with_in_array($group_allowed_path, $path)) {
      // Under OG context, but path prefix is not specified at allowed array.
      // Cancel the 'prefix' that was added by purl_url_outbound_alter().
      // purl_url_outbound_alter() will always run before this hook, as
      // PURL model weight is lower (-20) than standard (0).
      $options['prefix'] = '';

      return;
    }

    if (_c4m_og_purl_starts_with($path, 'node') && !_c4m_og_purl_node_at_path_is_content_of_group($path, $context['gid']) && !_c4m_og_purl_path_is_add_group_content($path, $context['gid'])) {
      // Node at path is not content of current OG group, thus, remove purl.
      $options['prefix'] = '';

      return;
    }

    // In case purl at $options['prefix'] is incorrect, update it.
    $group_purl = c4m_og_current_group_purl() . '/';
    if (!empty($options['prefix']) && $options['prefix'] != $group_purl) {
      $options['prefix'] = $group_purl;
    }
  }
}

/**
 * Determines if node ($nid at path) is content of group with ID $gid.
 *
 * @param string $path
 *   Menu item path.
 * @param int $gid
 *   Group ID.
 *
 * @return bool
 *   TRUE if node ($nid at path) is content of group with ID $gid.
 */
function _c4m_og_purl_node_at_path_is_content_of_group($path, $gid) {
  $path_element = explode('/', $path);

  if (count($path_element) < 2) {
    // Not a node view / manipulation path.
    return FALSE;
  }

  $nid = $path_element[1];
  if (!$node = node_load($nid)) {
    // Not a valid node.
    return FALSE;
  }

  $node_gid = c4m_og_get_gid_from_entity($node);

  return $gid == $node_gid;
}

/**
 * Determines if node ($nid at path) is content of group with ID $gid.
 *
 * @param string $path
 *   Menu item path.
 * @param int $gid
 *   Group ID.
 *
 * @return bool
 *   TRUE if node ($nid at path) is content of group with ID $gid.
 */
function _c4m_og_purl_path_is_add_group_content($path, $gid) {
  $path_element = explode('/', $path);

  if (count($path_element) <= 2) {
    // Not a node view / manipulation path.
    return FALSE;
  }

  if ($path_element[1] !== 'add') {
    return FALSE;
  }

  $node_type = str_replace('-', '_', $path_element[2]);

  return og_is_group_content_type('node', $node_type);
}

/**
 * Path prefixes, which we allow to be accessed under OG context.
 *
 * @todo Maybe it's best to implement this with a static cache and a custom hook
 *   to allow other modules to add new paths.
 *
 * @return array
 *   The allowed list.
 */
function _c4m_og_purl_allowed_paths() {
  return [
    'admin/statistics',
    'calendar',
    'comment',
    'dashboard',
    'draft-content',
    'discussions',
    'documents',
    'flag/confirm/%/%/%',
    'group',
    'manage',
    'media',
    'members',
    'news',
    'node',
    'overlay-file',
    'overlay-node',
    'flag/confirm/%/%/%',
    // @see c4m_og_context_handler_ajax_request()
    'file/ajax',
    'system/ajax',
    'quick-post',
    'searchgroup',
    'wiki',
  ];
}

/**
 * Implements hook_field_formatter_info().
 */
function c4m_og_purl_field_formatter_info() {
  return array(
    'c4m_og_purl_entityreference_link' => array(
      'label' => t('Purl link'),
      'description' => t('Link to entityreference with og purl.'),
      'field types' => array('entityreference'),
      'settings' => array(
        'link' => C4M_OG_PURL_LINK_AUTO,
      ),
    ),
  );
}

/**
 * Implements hook_ds_fields_info_alter().
 */
function c4m_og_purl_ds_fields_info_alter(&$fields, $entity_type) {
  // Replace the title render function for title fields.
  if (isset($fields['title'])) {
    $fields['title']['function'] = 'c4m_og_purl_ds_render_field';
  }

  // Add extra link type options.
  if (isset($fields['title']['properties']['settings']['link']['options'])) {
    $options = $fields['title']['properties']['settings']['link']['options'];
    $options[C4M_OG_PURL_LINK_AUTO] = t('Yes, auto PURL');
    $options[C4M_OG_PURL_LINK_DISABLED] = t('Yes, disable PURL');
    $options[C4M_OG_PURL_LINK_DASHBOARD] = t('Yes, to group dashboard');
    $fields['title']['properties']['settings']['link']['options'] = $options;
  }
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function c4m_og_purl_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  // Formatter is c4m_og_purl_entityreference_link.
  if ($display['type'] === 'c4m_og_purl_entityreference_link') {
    $options[C4M_OG_PURL_LINK_AUTO] = t('Auto PURL');
    $options[C4M_OG_PURL_LINK_DISABLED] = t('Disable PURL');
    $options[C4M_OG_PURL_LINK_DASHBOARD] = t('To group dashboard');

    $element['link'] = array(
      '#title'          => t('Link label to the referenced entity'),
      '#type'           => 'select',
      '#options'        => $options,
      '#default_value'  => $settings['link'],
    );
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function c4m_og_purl_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] === 'c4m_og_purl_entityreference_link') {
    switch ($settings['link']) {
      case C4M_OG_PURL_LINK_AUTO:
        $summary[] = t('Link to og purl referenced entity');
        break;

      case C4M_OG_PURL_LINK_DISABLED:
        $summary[] = t('Link to referenced entity');
        break;

      case C4M_OG_PURL_LINK_DASHBOARD:
        $summary[] = t('Link to group dashboard');
        break;
    }
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_prepare_view().
 */
function c4m_og_purl_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $target_ids = array();

  // Collect every possible entity attached to any of the entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      if (isset($item['target_id'])) {
        $target_ids[] = $item['target_id'];
      }
    }
  }

  $target_entities = array();
  if ($target_ids) {
    $target_entities = entity_load(
      $field['settings']['target_type'],
      $target_ids
    );
  }

  // Iterate through the fieldable entities again to attach the loaded data.
  foreach ($entities as $id => $entity) {
    $rekey = FALSE;

    foreach ($items[$id] as $delta => $item) {
      // Check whether the referenced entity could be loaded.
      if (isset($target_entities[$item['target_id']])) {
        // Replace the instance value with the term data.
        $items[$id][$delta]['entity'] = $target_entities[$item['target_id']];
        // Check whether the user has access to the referenced entity.
        $has_view_access = (entity_access('view', $field['settings']['target_type'], $target_entities[$item['target_id']]) !== FALSE);
        $has_update_access = (entity_access('update', $field['settings']['target_type'], $target_entities[$item['target_id']]) !== FALSE);
        $items[$id][$delta]['access'] = ($has_view_access || $has_update_access);
      }
      // Otherwise, unset the instance value, since the entity does not exist.
      else {
        unset($items[$id][$delta]);
        $rekey = TRUE;
      }
    }

    if ($rekey) {
      // Rekey the items array.
      $items[$id] = array_values($items[$id]);
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 */
function c4m_og_purl_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $result = array();
  $settings = $display['settings'];

  // Formatter is c4m_og_purl_entityreference_link.
  if ($display['type'] === 'c4m_og_purl_entityreference_link') {
    $handler = entityreference_get_selection_handler($field, $instance, $entity_type, $entity);

    foreach ($items as $delta => $item) {
      $label = $handler->getLabel($item['entity']);
      $uri = entity_uri($field['settings']['target_type'], $item['entity']);
      c4m_og_purl_alter_uri_info($settings['link'], $uri);
      $result[$delta] = array(
        '#markup' => l($label, $uri['path'], $uri['options']),
      );
    }
  }

  return $result;
}

/**
 * Return whether search string begins with  one of strings at array.
 *
 * @param array $strings
 *   Array of strings.
 * @param string $search_string
 *   String in which search is performed.
 *
 * @return bool
 *   Whether search string begins with  one of strings at array
 */
function _c4m_og_purl_starts_with_in_array(array $strings, $search_string) {
  foreach ($strings as $string) {
    if (_c4m_og_purl_starts_with($search_string, $string)) {

      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Returns whether search string begins with string.
 *
 * @param string $search_string
 *   String in which search is performed.
 * @param string $string
 *   String for which we check if it's search string prefix.
 *
 * @return bool
 *   Whether search string begins with string.
 */
function _c4m_og_purl_starts_with($search_string, $string) {
  return strpos($search_string, $string) === 0;
}

/**
 * Prepares an OG Purl aware 'destination' URL query parameter.
 *
 * This function works on top of the drupal_get_destination() which is not
 * aware of the OG Context / Purl.
 *
 * @return array
 *   An associative array containing the key:
 *   - destination: The path provided via the destination query string or, if
 *     not available, the current path.
 *
 * @see drupal_get_destination()
 *
 * @deprecated We can use request_path() instead.
 *   url(
 *     'user/logout', array(
 *       'absolute' => TRUE,
 *       'purl' => array(
 *          'disabled' => TRUE,
 *        ),
 *        'query' => array('destination' => request_path()),
 *      )
 *   );
 */
function c4m_og_purl_get_destination() {
  $destination = &drupal_static(__FUNCTION__);

  if (NULL !== $destination) {
    return $destination;
  }

  $destination = drupal_get_destination();

  if (isset($destination['destination'])) {
    if ($og_context = og_context('node')) {
      if (isset($og_context['gid']) && is_numeric($og_context['gid'])) {
        $destination['destination'] = ltrim(url($destination['destination']), '/');
      }
    }
  }

  return $destination;
}

/**
 * Implements hook_tokens_alter().
 *
 * Alter the comments url via tokens to display the purl.
 */
function c4m_og_purl_tokens_alter(array &$replacements, array $context) {
  if (empty($replacements['[message:field-comment:url]']) || empty($context['data']['comment'])) {
    return;
  }

  $comment = $context['data']['comment'];
  if (!$gid = c4m_comment_get_group_id($comment)) {
    return;
  }

  $url_options = array(
    'absolute' => TRUE,
    'fragment' => 'comment-' . $comment->cid,
    'purl' => array(
      'provider' => 'og_purl|node',
      'id' => $gid,
    ),
  );

  $replacements['[message:field-comment:url]'] = url('comment/' . $comment->cid, $url_options);
}

/**
 * Render the access deny page if the current page has context.
 */
function c4m_og_purl_deny_purl_access() {
  if ($context = og_context()) {
    c4m_content_deny_access();
  }
}

/**
 * Implements hook_views_access_callbacks().
 */
function c4m_og_purl_views_access_callbacks() {
  return array(
    'c4m_og_purl_global_content_access' => t('C4M Global content access'),
    'c4m_og_purl_group_content_access' => t('C4M Group content access'),
  );
}

/**
 * Global content should not be displayed under og_context.
 *
 * @return bool
 *   TRUE if context is not present, otherwise returns FALSE.
 */
function c4m_og_purl_global_content_access() {
  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);
    return TRUE;
  }

  return !og_context() && user_access('access content');
}

/**
 * Group content should be displayed under og_context only.
 *
 * @return bool
 *   TRUE if context is present, otherwise returns FALSE.
 */
function c4m_og_purl_group_content_access() {
  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);
    return FALSE;
  }

  return og_context() && user_access('access content');
}

/**
 * Implements hook_form_alter().
 */
function c4m_og_purl_form_alter(array &$form, array $form_state) {
  if (empty($form['#node_edit_form'])
    || !og_is_group_type(
      'node',
      $form['#node']->type
    )
  ) {
    return;
  }
  $form['og_purl']['purl']['value']['#title'] = t('Group path');
  $form['og_purl']['purl']['value']['#type'] = 'machine_name';
  $form['og_purl']['purl']['value']['#machine_name'] = array(
    'source' => array('title'),
    'label' => t('Group path'),
    'exists' => 'c4m_og_purl_exists',
    'replace' => '-',
    'replace_pattern' => '[^a-z0-9_-]+',
    'error_message' => t('The name is already taken. Please choose another.'),
  );
}

/**
 * Function to check if a path is a purl path.
 *
 * @param string $value
 *   Group path.
 *
 * @return bool
 *   TRUE or FALSE.
 */
function c4m_og_purl_exists($value) {
  $alias = db_query('SELECT old_path FROM {c4m_og_purl_aliases} WHERE old_path = :old_path', [':old_path' => $value])->fetchField();
  return (bool) $alias;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Put c4m_og_purl form_alter implementation after og_purl.
 */
function c4m_og_purl_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter' && isset($implementations['c4m_og_purl'])) {
    $c4m_og_purl = $implementations['c4m_og_purl'];
    unset($implementations['c4m_og_purl']);
    $implementations['c4m_og_purl'] = $c4m_og_purl;
  }
}

/**
 * Implements hook_node_update().
 */
function c4m_og_purl_node_update($node) {
  if (!og_is_group('node', $node)) {
    return;
  }

  if (!isset($node->purl) || !isset($node->original->purl) || !isset($node->purl['value'])) {
    return;
  }

  // $node->original->purl is a string containing the original path.
  if ($node->purl['value'] === $node->original->purl) {
    return;
  }

  c4m_og_purl_save_alias($node->original->purl, $node->purl['value']);
}

/**
 * Saves a purl redirect.
 *
 * @param string $old_path
 *   The old path.
 * @param string $new_path
 *   The new path.
 */
function c4m_og_purl_save_alias($old_path, $new_path) {
  $alias = [
    'old_path' => $old_path,
    'new_path' => $new_path,
  ];
  drupal_write_record('c4m_og_purl_aliases', $alias);

  // Update older aliases that point to the updated alias.
  db_update('c4m_og_purl_aliases')
    ->fields(['new_path' => $alias['new_path']])
    ->condition('new_path', $alias['old_path'])
    ->execute();

  // Avoid circular redirects.
  db_delete('c4m_og_purl_aliases')
    ->where('old_path = new_path')
    ->execute();
}

/**
 * Implements hook_c4m_group_merge().
 */
function c4m_og_purl_c4m_group_merge($group_id, $target_group_id) {
  $group = node_load($group_id);
  $target_group = node_load($target_group_id);
  c4m_og_purl_save_alias($group->purl, $target_group->purl);
}
