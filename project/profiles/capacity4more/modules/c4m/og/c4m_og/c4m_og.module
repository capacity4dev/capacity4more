<?php

/**
 * @file
 * General Organic Groups functionality.
 */

include_once 'c4m_og.features.inc';
include_once 'c4m_og.access.inc';

/**
 * The access realm of C4M group member.
 */
define('C4M_OG_ACCESS_REALM', 'c4m_og_access');

/**
 * The values of the groups access level as defined on its field base.
 */
define('C4M_OG_MODERATED_GROUP', 0);
define('C4M_OG_OPEN_GROUP', 1);
define('C4M_OG_PRIVATE_GROUP', 2);

/**
 * Batch related values.
 */
define('C4M_OG_BATCH_MERGE_LIMIT', 10);

/**
 * Helper to get the current active group (based on og_context()).
 *
 * @return object|false
 *   The group entity, or FALSE if no context was found.
 */
function c4m_og_current_group() {
  $context = og_context();
  if (!$context) {
    return FALSE;
  }

  $group = node_load($context['gid']);
  if (!$group) {
    return FALSE;
  }

  return $group;
}

/**
 * Helper to get the current active group id (based on og_context()).
 *
 * @return null|int
 *   The group id, or NULL if no context was found.
 */
function c4m_og_current_group_id() {
  $context = og_context();
  if (!$context) {
    return NULL;
  }

  return $context['gid'];
}

/**
 * Helper to get the current active group purl (based on og_context()).
 *
 * @return string
 *   The group purl, or empty string if no context was found.
 */
function c4m_og_current_group_purl() {
  if (!$group = c4m_og_current_group()) {
    return '';
  }

  return $group->purl;
}

/**
 * Helper to get the current value of the group membership request.
 *
 * @param object $group
 *   The group object.
 *
 * @return mixed|null
 *   Either 'open' or 'moderated' if it is a group type, otherwise NULL.
 */
function c4m_og_get_group_membership_request($group) {
  if (!og_context('node', $group)) {
    return NULL;
  }

  if ($group->type != 'group') {
    return NULL;
  }

  $wrapper = entity_metadata_wrapper('node', $group);
  $options = [
    C4M_OG_MODERATED_GROUP => 'moderated',
    C4M_OG_OPEN_GROUP => 'open',
  ];

  return $options[$wrapper->field_membership_open_request->value()];
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function c4m_og_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return 'plugins/' . $plugin;
  }
  elseif ($module == 'entityreference' && !empty($plugin)) {
    return "plugins/entityreference/$plugin";
  }
  elseif ($module == 'pluggable_node_access') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_menu().
 */
function c4m_og_menu() {
  $items['group/%/%/admin/owner'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_replace_owner_build_form', 1, 2],
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => [1, 2],
    'title' => 'Replace Owner',
  ];

  $items['project/%/%/admin/owner'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_replace_project_owner_build_form', 1, 2],
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => [1, 2],
    'title' => 'Replace Owner',
  ];
  // Auto-completes active group member's user names.
  $items['edit-author/autocomplete/%node'] = [
    'page callback' => 'c4m_og_edit_author_autocomplete',
    'page arguments' => [2, 3],
    'access callback' => '_c4m_features_og_members_is_power_user',
    'access arguments' => [2],
    'title' => 'Replace Author',
  ];

  // Menu item for approve membership request url.
  $items['group/%/%/admin/membership-approve/%user/%og_membership/%/%'] = [
    'page callback' => 'c4m_og_control_membership',
    'page arguments' => ['approve', 2, 5, 6, 7, 8],
    'access callback' => 'c4m_og_control_membership_access',
    'access arguments' => [1, 2],
  ];

  // Menu item for reject membership request url.
  $items['group/%/%/admin/membership-reject/%user/%og_membership/%/%'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_reject_membership_request', 2, 5, 6, 7, 8],
    'access callback' => 'c4m_og_control_membership_access',
    'access arguments' => [1, 2],
  ];

  // Menu item for approval of group request url.
  $items['node/%node/approve-group'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_approve_group_request', 1],
    'access callback' => 'c4m_og_control_group_request_access',
    'access arguments' => [1],
  ];

  // Menu item for rejection of group request url.
  $items['node/%node/reject-group'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_reject_group_request', 1],
    'access callback' => 'c4m_og_control_group_request_access',
    'access arguments' => [1],
  ];

  $items['group/%/%/admin/people/invitations'] = [
    'page callback' => '_c4m_og_invitations_overview',
    'page arguments' => [2],
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => [1, 2],
    'title' => 'Invitations',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  ];

  $items['group/%/%/admin/people/invitations/email/delete/%'] = [
    'page callback' => '_c4m_og_invitations_delete',
    'page arguments' => [6, 2, 8],
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => [1, 2],
  ];

  $items['group/%/%/admin/people/invitations/username/delete/%'] = [
    'page callback' => '_c4m_og_invitations_delete',
    'page arguments' => [6, 2, 8],
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => [1, 2],
  ];

  $items['admin/statistics'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_export_statistics_form'],
    'access callback' => 'c4m_features_og_members_is_power_user_access_callback',
    'title' => 'Statistics',
  ];

  $items['admin/statistics/results'] = [
    'page callback' => '_c4m_og_statistics_results',
    'access callback' => 'c4m_features_og_members_is_power_user',
    'title' => 'Data export',
  ];

  $items['node/%node/merge'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_og_merge_groups_form', 1],
    'access arguments' => ['merge group content'],
    'title' => 'Merge content',
  ];

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function c4m_og_menu_alter(&$items) {
  // Adding a member should be allow to SA only (CFM-1292).
  $items['group/%/%/admin/people/add-user']['access callback'] = 'c4m_og_add_member_to_group_access';

  // Assign access to Node Gallery API features, if user has permission to
  // edit the gallery.
  $node_galery_api_features = ['upload', 'items', 'manage', 'sort'];
  foreach ($node_galery_api_features as $suffix) {
    $items['node/%node_gallery_api_gallery/' . $suffix]['access callback'] = 'node_access';
    $items['node/%node_gallery_api_gallery/' . $suffix]['access arguments'] = [
      'update',
      1,
    ];
  }

  // Assign access to upload Node Gallery API item types, per upload access
  // function.
  // Node Gallery API item types are resolve in same manner
  // as at node_gallery_api_menu().
  $relationship_types = node_gallery_api_get_relationship_type(NULL, NULL, NULL, TRUE);
  foreach ($relationship_types as $relationship) {
    foreach ($relationship->item_types as $item_type) {
      $items['node/%node_gallery_api_gallery/upload/' . $item_type]['access callback'] = 'c4m_og_node_gallery_access';
      $items['node/%node_gallery_api_gallery/upload/' . $item_type]['access arguments'] = [
        1,
        $item_type,
      ];
    }
  }
}

/**
 * Access callback; Adding a member to a group is allowed for SA only.
 *
 * @see og_ui_user_access_group()
 */
function c4m_og_add_member_to_group_access($perm, $group_type, $gid) {
  return c4m_user_is_site_admin() && og_ui_user_access_group($perm, $group_type, $gid);
}

/**
 * Access to control group requests.
 *
 * Site administrators can access, as long as $node is OG group.
 *
 * @param object $node
 *   Group node.
 *
 * @return bool
 *   Whether access is allowed.
 */
function c4m_og_control_group_request_access($node) {
  if (!c4m_user_is_site_admin()) {
    // Current user is not site admin.
    return FALSE;
  }

  return og_is_group('node', $node);
}

/**
 * Function initializes form with input values, and returns confirm form.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 * @param object $node
 *   Group node.
 *
 * @return object
 *   Approve group form.
 */
function c4m_og_approve_group_request($form, &$form_state, $node) {
  if (!_c4m_og_group_at_initial_state($node->nid)) {
    // If group is not at initial state, present form with failure reason.
    $message = _c4m_og_format_group_request_failure_reason_message($node->nid);
    drupal_set_message($message, 'warning');

    return $form;
  }

  $form['message_from_admin'] = [
    '#type' => 'textarea',
  ];

  $form['gid'] = [
    '#type' => 'value',
    '#value' => $node->nid,
  ];

  $form['#submit'][] = 'c4m_og_approve_group_request_submit';
  $form['#submit'][] = 'c4m_og_notify_user_group_approved';
  $form['#submit'][] = 'c4m_user_notifications_log_group_approved';
  $form['#submit'][] = 'c4m_og_route_to_group';

  return confirm_form($form, t('Please enter your comments:'), 'node/' . $node->nid . '/group', '', t('Approve'), t('Cancel'));
}

/**
 * Function initializes form with input values, and returns confirm form.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 * @param object $node
 *   Group node.
 *
 * @return object
 *   Approve group request form.
 */
function c4m_og_reject_group_request($form, &$form_state, $node) {
  if (!_c4m_og_group_at_initial_state($node->nid)) {
    // If group is not at initial state, present form with failure reason.
    $message = _c4m_og_format_group_request_failure_reason_message($node->nid);
    drupal_set_message($message, 'warning');

    return $form;
  }

  $form['message_from_admin'] = [
    '#type' => 'textarea',
  ];

  $form['gid'] = [
    '#type' => 'value',
    '#value' => $node->nid,
  ];

  $form['#submit'][] = 'c4m_og_reject_group_request_submit';
  $form['#submit'][] = 'c4m_user_notifications_log_group_rejected';
  $form['#submit'][] = 'c4m_og_route_to_group';

  return confirm_form($form, t('Please enter a reason:'), 'node/' . $node->nid . '/group', '', t('Reject'), t('Cancel'));
}

/**
 * Submits approve group request form.
 *
 * Gets inputs from form, and activates c4m_og_control_group_request() function
 * with action = 'approve'.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_approve_group_request_submit($form, &$form_state) {
  $gid = $form_state['values']['gid'];

  c4m_og_control_group_request('approve', $gid);
}

/**
 * Submits reject group request form.
 *
 * Gets inputs from form, and activates c4m_og_control_group_request() function
 * with action = 'reject'.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_reject_group_request_submit($form, &$form_state) {
  $gid = $form_state['values']['gid'];

  c4m_og_control_group_request('reject', $gid);
}

/**
 * Changes group state to approved / rejected (per $action).
 *
 * @param string $action
 *   Use 'approve' when group is approved.
 *   Use 'reject' when group is rejected.
 * @param int $gid
 *   Group ID.
 */
function c4m_og_control_group_request($action, $gid) {
  // If group is not at initial state => request was already handled.
  if (!_c4m_og_group_at_initial_state($gid)) {
    $message = _c4m_og_format_group_request_failure_reason_message($gid);

    drupal_set_message($message, 'warning');
    return;
  }

  $group_state = [
    'approve' => 'draft',
    'reject' => 'deleted',
  ];

  $message_action = [
    'approve' => 'approved',
    'reject' => 'rejected',
  ];

  $group = node_load($gid);
  $wrapper = entity_metadata_wrapper('node', $group);

  // Property instructs c4m_user_notification model to abort sending
  // 'group approved' notification, since is sent by
  // c4m_og_notify_user_group_approved().
  $group->abort_group_approved_notification = TRUE;
  $wrapper->c4m_og_status->set($group_state[$action]);

  // Save group and present success message.
  $wrapper->save();
  $message = t('@bundle request @action', [
    '@bundle' => ucfirst($wrapper->getBundle()),
    '@action' => $message_action[$action],
  ]);

  drupal_set_message($message);
}

/**
 * Invokes notification about approved group.
 *
 * @param array $form
 *   Form array.
 * @param array $form_state
 *   Form state array.
 */
function c4m_og_notify_user_group_approved(array &$form, array &$form_state) {
  $gid = $form_state['values']['gid'];
  $admin_comment = $form_state['values']['message_from_admin'];

  _c4m_user_notifications_notify_og_group_status_approved($gid, $admin_comment);
}

/**
 * Returns groups state.
 *
 * @param int $gid
 *   Group ID.
 *
 * @return string
 *   Group state.
 */
function _c4m_og_get_group_state($gid) {
  // Check that group is at initial ('pending') state.
  $wrapper = entity_metadata_wrapper('node', $gid);

  return $wrapper->c4m_og_status->value();
}

/**
 * Returns whether group is at initial ('pending') state.
 *
 * @param int $gid
 *   Group ID.
 *
 * @return bool
 *   Whether the group is at initial state.
 */
function _c4m_og_group_at_initial_state($gid) {
  return _c4m_og_get_group_state($gid) == 'pending';
}

/**
 * Returns a failure reason message for invalid group request.
 *
 * @param int $gid
 *   Group ID.
 *
 * @return bool
 *   Failure reason message if for invalid group request.
 */
function _c4m_og_format_group_request_failure_reason_message($gid) {
  $state = _c4m_og_get_group_state($gid);
  $wrapper = entity_metadata_wrapper('node', $gid);

  return t('@bundle request was already @action', [
    '@bundle' => ucfirst($wrapper->getBundle()),
    // State is other than 'deleted' => group was approved.
    '@action' => ($state == 'deleted') ? ' rejected' : 'approved',
  ]);
}

/**
 * Function initializes form with input values, and returns confirm form.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 * @param int $gid
 *   Group ID.
 * @param object $account
 *   Administrator user that performs the action.
 * @param object $membership
 *   OG membership on which action is performed.
 * @param int $timestamp
 *   Timestamp of the moment action was requested.
 * @param string $hashed_pass
 *   Validation for executing user.
 *
 * @return object
 *   Confirm reject form.
 */
function c4m_og_reject_membership_request($form, &$form_state, $gid, $account, $membership, $timestamp = 0, $hashed_pass = '') {
  $form['reject_membership_request_message'] = [
    '#type' => 'textarea',
  ];

  // Add group membership form.
  $form_state['membership'] = $membership;
  field_attach_form('membership', $membership, $form, $form_state);
  $form_state['account'] = $account;
  field_attach_form('account', $account, $form, $form_state);

  $form['gid'] = [
    '#type' => 'value',
    '#value' => $gid,
  ];

  $form['timestamp'] = [
    '#type' => 'value',
    '#value' => $timestamp,
  ];

  $form['hashed_pass'] = [
    '#type' => 'value',
    '#value' => $hashed_pass,
  ];

  return confirm_form($form, t('Please enter reject reason:'), 'group/node/' . $gid . '/admin/people', '', t('Reject'), t('Cancel'));
}

/**
 * Submits reject membership request form.
 *
 * Gets inputs from form, and activates c4m_og_control_membership() function
 * with action = 'reject'.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_reject_membership_request_submit($form, &$form_state) {
  $membership = $form_state['membership'];
  $account = $form_state['account'];
  $gid = $form_state['values']['gid'];
  $timestamp = $form_state['values']['timestamp'];
  $hashed_pass = $form_state['values']['hashed_pass'];

  c4m_og_control_membership('reject', $gid, $account, $membership, $timestamp, $hashed_pass);
}

/**
 * Function builds and returns a link for membership request control.
 *
 * Includes a token for auto login.
 *
 * @param object $account
 *   Account which performs the action.
 * @param object $membership
 *   Membership for which action is performed.
 * @param string $action
 *   Approve / Reject.
 *
 * @return string
 *   A link for membership request control.
 */
function c4m_og_autologin_control_membership_link($account, $membership, $action) {
  $timestamp = REQUEST_TIME;
  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  $path = 'group/node/' . $membership->gid . '/admin/membership-' . $action . '/' . $account->uid . '/' . $membership->id . '/' . $timestamp . '/' . user_pass_rehash($account->pass, $timestamp, $account->login, $account->uid);

  return url($path, $options);
}

/**
 * Forwards the page to group's People page.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_route_to_group_people($form, &$form_state) {
  $gid = $form_state['values']['gid'];

  drupal_goto('group/node/' . $gid . '/admin/people');
}

/**
 * Forwards the page to group admin page.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_route_to_group($form, &$form_state) {
  $gid = $form_state['values']['gid'];

  drupal_goto('node/' . $gid . '/group');
}

/**
 * Function approves / rejects membership request, submitted by user.
 *
 * Verifies auto login token, and if valid, logs in the administrator and
 * performs required state change to membership request. If not valid, forwards
 * to login page.
 *
 * @param string $action
 *   Approve / Reject.
 * @param int $gid
 *   Group ID.
 * @param object $account
 *   Administrator user that performs the action.
 * @param object $membership
 *   OG membership on which action is performed.
 * @param int $timestamp
 *   Timestamp of the moment action was requested.
 * @param string $hashed_pass
 *   Validation for executing user.
 */
function c4m_og_control_membership($action, $gid, $account, $membership, $timestamp = 0, $hashed_pass = '') {
  global $user;
  // Time out in seconds, until auto login token expires.
  // 24 hours = 86400 seconds.
  $timeout = variable_get('autologin_timeout', 86400);
  $current = REQUEST_TIME;

  // If not logged in, or logged in as different user.
  if (user_is_anonymous() || $account->uid != $user->uid) {
    $timestamp_valid = $timestamp <= $current && $timestamp >= $account->login;
    $timeout_occurred = $current - $timestamp > $timeout;
    $rehashed_pass = user_pass_rehash($account->pass, $timestamp, $account->login, $account->uid);

    // Validate expiration and hashed password/login.
    if ($timestamp_valid && !$timeout_occurred && $account->uid && $hashed_pass == $rehashed_pass) {
      // If link data validated, perform automatic login.
      $user = $account;
      drupal_session_regenerate();
    }
    else {
      // If not valid, forward to login page, with forwarding to membership
      // edit page, after successful login.
      drupal_set_message('Auto login token expired', 'warning');
      $query = ['destination' => 'group/node/' . $gid . '/admin/people/edit-membership/' . $membership->id];
      drupal_goto('user/login', ['query' => $query]);
    }
  }

  // Approve/Reject membership request.
  if ($membership->state == OG_STATE_PENDING) {
    $membership->state = $action == 'approve' ? OG_STATE_ACTIVE : OG_STATE_BLOCKED;
    og_membership_save($membership);
    $message = $action == 'approve' ? t('Membership approved') : t('Membership rejected');
    drupal_set_message($message);
  }
  else {
    $message = '';
    if ($membership->state == OG_STATE_ACTIVE) {
      $message = t('This request was already approved');
    }
    elseif ($membership->state == OG_STATE_BLOCKED) {
      $message = t('This request was already rejected');
    }

    drupal_set_message($message, 'warning');
  }

  if ($action == 'approve') {
    // For 'reject' route will be performed by form['#submit'].
    drupal_goto('group/node/' . $gid . '/admin/people');
  }
}

/**
 * Callback to display group's pending invitations.
 *
 * @param string $group_id
 *   Group ID.
 *
 * @return string
 *   Output.
 */
function _c4m_og_invitations_overview($group_id) {
  $output = '';

  $output .= c4m_og_invite_visitors_pending_invitations($group_id);
  $output .= c4m_og_invite_users_pending_invitations($group_id);

  return $output;
}

/**
 * Callback to delete an invitation.
 *
 * @param string $invitation_type
 *   Invitation type.
 * @param string $group_id
 *   The group id.
 * @param string $id
 *   The invitation id or the og_membership id.
 */
function _c4m_og_invitations_delete($invitation_type, $group_id, $id) {
  if ($invitation_type == 'email') {
    $result = c4m_og_invite_visitors_delete_invitation($group_id, $id);
  }
  else {
    og_membership_delete($id);
    // og_membership_delete doesn't return any results.
    $result = TRUE;
  }
  if ($result) {
    drupal_set_message('Invitation was deleted.');
  }
  else {
    drupal_set_message('Could not delete the invitation.');
  }

  drupal_goto('group/node/' . $group_id . '/admin/people/invitations');
}

/**
 * Menu access; Check if entity is a group.
 */
function c4m_og_control_membership_access($group_type, $gid) {
  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Extract the group's bundle.
  list(, , $bundle) = entity_extract_ids($group_type, $group);
  // Verify 'node' bundle has roles.
  if (!og_roles($group_type, $bundle, $gid)) {
    return FALSE;
  }

  $entity_info = entity_get_info($group_type);
  if (!$group_type || !$entity_info) {
    // Not a valid entity type.
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements hook_og_ui_get_group_admin_alter().
 *
 * Adding a link to the replace owner page.
 */
function c4m_og_og_ui_get_group_admin_alter(&$data, $context) {
  if (!c4m_og_user_is_owner($context['entity_type'], $context['etid'])) {
    return;
  }

  $data['replace_owner'] = [
    'title' => t('Replace Owner'),
    'description' => t('Replacing the owner of the group or project.'),
    'href' => 'admin/owner',
  ];
}

/**
 * Form builder.
 *
 * Group owner replace form.
 */
function c4m_og_replace_owner_build_form($form, $form_state, $entity_type, $etid) {
  og_set_breadcrumb($entity_type, $etid, [l(t('Group'), "$entity_type/$etid/group")]);

  $admins = [];
  // Setting the list of the group admins.
  foreach (c4m_og_get_group_admins($etid) as $admin) {
    $admins[$admin->uid] = c4m_user_name($admin);
  }

  if (!empty($admins)) {
    $form['new_owner'] = [
      '#type' => 'select',
      '#required' => TRUE,
      '#options' => $admins,
      '#title' => t('Select new owner'),
      '#description' => t('Select the name of the group admin you wish to be the new owner.'),
    ];

    $form['group'] = [
      '#type' => 'value',
      '#value' => $etid,
    ];

    $form['type'] = [
      '#type' => 'value',
      '#value' => $entity_type,
    ];

    $form['submit'] = [
      '#type' => 'submit',
      '#value' => t('Replace'),
    ];
  }
  else {
    $link = l(t('Visit the members admin page'), 'group/node/' . $etid . '/admin/people');
    $message = t('The group does not have any administrators to be the new owner. !link', ['!link' => $link]);
    drupal_set_message($message, 'warning');
  }

  return $form;
}

/**
 * Submit handler.
 *
 * Replacing the owner of a group.
 */
function c4m_og_replace_owner_build_form_submit($form, &$form_state) {
  $new_owner = [
    'uid' => $form_state['values']['new_owner'],
    'name' => $form['new_owner']['#options'][$form_state['values']['new_owner']],
  ];
  c4m_og_replace_owner($form_state['values']['type'], $form_state['values']['group'], $new_owner);

  // Redirect back to the group page.
  $form_state['redirect'] = 'node/' . $form_state['values']['group'];
}

/**
 * Form builder.
 *
 * Group owner replace form.
 */
function c4m_og_export_statistics_form($form, $form_state) {
  $format = 'Y-m-d';

  $intervals = [
    'today' => [
      'label' => t('Today'),
      'startDate' => date($format, time()),
      'endDate' => date($format, time()),
    ],
    'yesterday' => [
      'label' => t('Yesterday'),
      'startDate' => date($format, strtotime("-1 day", time())),
      'endDate' => date($format, strtotime("-1 day", time())),
    ],
    'last_week' => [
      'label' => t('Last 7 days'),
      'startDate' => date($format, strtotime("-1 week", time())),
      'endDate' => date($format, time()),
    ],
    'last_month' => [
      'label' => t('Last month'),
      'startDate' => date($format, strtotime("-1 month", time())),
      'endDate' => date($format, time()),
    ],
  ];

  $form['predefined_intervals'] = [
    '#type' => 'fieldset',
    '#title' => t('Predefined periods'),
    '#collapsible' => FALSE,
    '#attributes' => [
      'id' => ['predefined-intervals'],
    ],
  ];
  foreach ($intervals as $key => $interval) {
    $form['predefined_intervals'][$key] = [
      '#markup' => l($interval['label'], "", [
        'attributes' => [
          'start' => $interval['startDate'],
          'end' => $interval['endDate'],
        ],
        'fragment' => ' ',
        'external' => TRUE,
      ]),
    ];
  }

  $form['#attached']['js'] = [
    drupal_get_path('module', 'c4m_og') . '/js/group-export.js',
  ];
  $form['#attached']['css'] = [
    drupal_get_path('module', 'c4m_og') . '/css/group-export.css',
  ];

  if (!empty($form_state['input']['start_date']['date'])) {
    $default_start_date = $form_state['input']['start_date']['date'];
  }
  else {
    $default_start_date = date($format, strtotime("-1 month", time()));
  }
  $form['start_date'] = [
    '#title' => t('Start Date'),
    '#type' => 'date_popup',
    '#date_format' => $format,
    '#description' => t('Select the start date'),
    '#required' => TRUE,
    '#default_value' => $default_start_date,
  ];

  if (!empty($form_state['input']['end_date']['date'])) {
    $default_end_date = $form_state['input']['end_date']['date'];
  }
  else {
    $default_end_date = date($format, time());
  }
  $form['end_date'] = [
    '#title' => t('End Date'),
    '#type' => 'date_popup',
    '#date_format' => $format,
    '#description' => t('Select the end date'),
    '#required' => TRUE,
    '#default_value' => $default_end_date,
  ];

  $form['content'] = [
    '#type' => 'submit',
    '#value' => t('Content Export'),
  ];

  $form['members'] = [
    '#type' => 'submit',
    '#value' => t('Members Export'),
  ];

  return $form;
}

/**
 * Validate callback for c4m_og_export_statistics_form.
 */
function c4m_og_export_statistics_form_validate($form, &$form_state) {
  $values = $form_state['values'];
  if ($values['start_date'] > $values['end_date']) {
    form_set_error('start_date', t('Please select valid dates.'));
  }
}

/**
 * Submit handler for c4m_og_export_statistics_form form.
 */
function c4m_og_export_statistics_form_submit($form, &$form_state) {
  $values = $form_state['values'];
  $group = og_context();

  $start_date = new DateTime($values['start_date']);
  $end_date = new DateTime($values['end_date']);
  $end_date->add(DateInterval::createFromDateString('1 day'));
  $type_of_content = $form_state['values']['op'] === $form_state['values']['content'] ? 'content' : 'members';

  $operations[] = [
    '_c4m_og_export_statistics_form_batch',
    [$type_of_content, $group['gid'], $start_date, $end_date],
  ];

  $batch = [
    'title' => t('Exporting data'),
    'operations' => $operations,
  ];

  $options = [
    'purl' => ['enabled' => TRUE],
  ];
  $path = 'admin/statistics/results';
  $form_state['redirect'] = url($path, $options);

  batch_set($batch);
}

/**
 * Submit handler.
 *
 * Export content from group.
 */
function _c4m_og_export_statistics_form_batch($type_of_content, $gid, $start_date, $end_date, array &$context) {
  $limit = 10;

  // Init the batch.
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = $start_date->diff($end_date)->days;
  }

  // Set the start and end date for the current batch operation.
  $current_start_date = clone $start_date;
  $current_end_date = clone $start_date;
  $current_start_date->add(DateInterval::createFromDateString($context['sandbox']['progress'] . ' days'));
  $current_end_date->add(DateInterval::createFromDateString(($context['sandbox']['progress'] + $limit) . ' days'));
  if ($current_end_date > $end_date) {
    $current_end_date = $end_date;
  }

  // TRUE if the file was not created yet.
  $first_run = !isset($context['sandbox']['fid']);

  if ($type_of_content === 'members') {
    $content = _c4m_og_export_statistics_form_submit_members($gid, $current_start_date, $current_end_date, $first_run);
  }
  else {
    $content = _c4m_og_export_statistics_form_submit_content($gid, $current_start_date, $current_end_date, $first_run);
  }

  if ($content) {
    if ($first_run) {
      $dir = 'private://c4m_og/exports/';

      // Make sure the directory exists first.
      if (!file_prepare_directory($dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
        drupal_set_message(t('Could not create directory for the export file.'), 'error');
      }
      $group = node_load($gid);
      $path = $dir . $group->purl . '-' . $type_of_content . '-' . $start_date->format('Ymd') . '-' . $end_date->format('Ymd') . '.csv';

      // Save the file into the DB.
      $file = file_save_data('', $path, FILE_EXISTS_REPLACE);

      // Make sure the file is marked as temporary.
      // There is no FILE_STATUS_TEMPORARY constant.
      $file->status = 0;
      file_save($file);

      $context['sandbox']['fid'] = $file->fid;
    }
    else {
      $file = file_load($context['sandbox']['fid']);
    }

    if (file_put_contents($file->uri, $content, FILE_APPEND) === FALSE) {
      drupal_set_message(t('Could not update the export file.'), 'error');
    }
  }

  $context['sandbox']['progress'] += $limit;
  if ($context['sandbox']['progress'] < $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
  else {
    $context['finished'] = 1;
    if (isset($context['sandbox']['fid'])) {
      // Load the file from the filesystem to save its size.
      $file = file_load($context['sandbox']['fid']);
      $file = file_uri_to_object($file->uri);
      file_save($file);
      $_SESSION['c4m_og_statistics_fid'] = $context['sandbox']['fid'];
    }
    else {
      $_SESSION['c4m_og_statistics_fid'] = '';
    }
  }
}

/**
 * Callback for admin/statistics/results page.
 */
function _c4m_og_statistics_results() {
  $token_prefix = 'c4m_og_statistics::';
  if (isset($_SESSION['c4m_og_statistics_fid'])) {
    $options = [
      'purl' => ['enabled' => TRUE],
      'query' => [
        'fid' => $_SESSION['c4m_og_statistics_fid'],
        'token' => drupal_get_token($token_prefix . $_SESSION['c4m_og_statistics_fid']),
      ],
    ];
    $path = 'admin/statistics/results';
    unset($_SESSION['c4m_og_statistics_fid']);
    drupal_goto($path, $options);
  }

  if (empty($_GET['fid'])) {
    $output = t('<p>No data found for the selected interval.</p>');
  }
  elseif (empty($_GET['token']) || !drupal_valid_token($_GET['token'], $token_prefix . $_GET['fid']) || !($file = file_load($_GET['fid']))) {
    $output = t('<p>Export data is not available.</p>');
  }
  else {
    drupal_add_html_head([
      '#tag' => 'meta',
      '#attributes' => ['http-equiv' => 'Refresh', 'content' => '3;url=' . file_create_url($file->uri)],
    ], 'c4m_og_statistics_download');

    $output = t('<p>Your export has been created. Download the file <a href="@link">here</a> (will automatically download in 3 seconds.)</p>', ['@link' => $file->uri]);
  }

  $options = [
    'purl' => ['enabled' => TRUE],
  ];
  $return_url = 'admin/statistics';
  $output .= '<p>' . l(t('Return to previous page'), $return_url, $options) . '</p>';
  return $output;
}

/**
 * Submit handler.
 *
 * Export content from group.
 */
function _c4m_og_export_statistics_form_submit_content($gid, $start_date, $end_date, $first_run) {
  $query = db_select('og_membership', 'ogm');
  $query->join('node', 'n', "n.nid = ogm.etid AND ogm.entity_type = 'node'");
  $query->join('users', 'u', 'u.uid = n.uid');
  $query->leftJoin('node_counter', 'nc', 'nc.nid = n.nid');
  $query->leftJoin('comment', 'c', 'c.nid = n.nid');
  $query->leftJoin('flag_counts', 'fc', 'n.nid = fc.entity_id AND fc.fid = 2');
  $query->leftJoin('file_usage', 'fu', 'fu.id = n.nid');
  $query->leftJoin('file_download_count', 'fd', 'fu.fid = fd.fid');
  $query->leftJoin('field_data_c4m_source_entity', 'se', 'se.c4m_source_entity_target_id = n.nid');
  $query->fields('n', ['title', 'type']);
  $query->fields('u', ['name']);
  $query->fields('nc', ['totalcount']);
  $query->groupBy('n.nid');
  $query->fields('fc', ['count']);
  $query->addExpression('COUNT(c.cid)', 'comments');
  $query->addExpression('COUNT(fd.uid)', 'downloads');
  $query->addExpression('COUNT(se.entity_id)', 'shares');
  $query->condition('ogm.gid', $gid);
  $query->condition('n.created', $start_date->getTimestamp(), '>=');
  $query->condition('n.created', $end_date->getTimestamp(), '<=');

  $content = $query->execute()->fetchAll();

  if (!$content) {
    return '';
  }

  $output = '';
  if ($first_run) {
    $output .= "Title|Type|Author|Views|Recommendations|Comments|Downloads|Shares\n";
  }

  foreach ($content as $item) {
    $output .= '"' . (!empty($item->title) ? str_replace("|", "", $item->title) : '');
    $output .= '"|"' . (!empty($item->type) ? str_replace("|", "", $item->type) : '');
    $output .= '"|"' . (!empty($item->name) ? str_replace("|", "", $item->name) : '');
    $output .= '"|' . (!empty($item->totalcount) ? $item->totalcount : 0);
    $output .= '|' . (!empty($item->count) ? $item->count : 0);
    $output .= '|' . (!empty($item->comments) ? $item->comments : 0);
    $output .= '|' . (!empty($item->downloads) ? $item->downloads : 0);
    $output .= '|' . (!empty($item->shares) ? $item->shares : 0);
    $output .= "\n";
  }

  return $output;
}

/**
 * Submit handler.
 *
 * Export members from group.
 */
function _c4m_og_export_statistics_form_submit_members($gid, $start_date, $end_date, $first_run) {
  $query = db_select('og_membership', 'ogm');
  $query->join('users', 'u', "u.uid = ogm.etid AND ogm.entity_type = 'user'");
  $query->leftJoin('field_data_c4m_first_name', 'fn', 'fn.entity_id = ogm.etid');
  $query->leftJoin('field_data_c4m_last_name', 'ln', 'ln.entity_id = ogm.etid');
  $query->leftJoin('field_data_c4m_organisation_type', 'ot', 'ot.entity_id = u.uid');
  $query->leftJoin('field_data_c4m_organisation', 'oname', 'oname.entity_id = u.uid');
  $query->leftJoin('field_data_c4m_country', 'country', 'country.entity_id = ogm.etid');
  $query->leftJoin('og_membership', 'ogmc', 'ogmc.gid = ' . $gid . ' AND ogmc.entity_type = \'node\'');
  $query->leftJoin('node', 'n', 'n.nid = ogmc.etid AND n.uid = ogm.etid');
  $query->leftJoin('comment', 'c', 'c.uid = ogm.etid AND c.nid = ogmc.etid');
  $query->leftJoin('c4m_og_invite_visitors', 'inv', 'inv.inv_uid = ogm.etid AND inv.inv_group_id = ' . $gid);
  $query->leftJoin('node_revision', 'nr', 'nr.uid = ogm.etid AND nr.nid = ogmc.etid');
  $query->leftJoin('og_users_roles', 'ur', 'ur.uid = ogm.etid AND ur.gid = ' . $gid);
  $query->leftJoin('og_role', 'r', 'r.rid = ur.rid');
  $query->fields('u', ['login']);
  $query->fields('ogm', ['created', 'state', 'etid']);
  $query->fields('fn', ['c4m_first_name_value']);
  $query->fields('ln', ['c4m_last_name_value']);
  $query->fields('ot', ['c4m_organisation_type_value']);
  $query->fields('oname', ['c4m_organisation_value']);
  $query->fields('country', ['c4m_country_value']);
  $query->fields('inv', ['inv_inviter_id']);
  $query->addExpression('COUNT(n.nid)', 'content');
  $query->addExpression('COUNT(c.cid)', 'comments');
  $query->addExpression('MAX(c.changed)', 'comments_action');
  $query->addExpression('MAX(nr.timestamp)', 'node_action');
  $query->fields('r', ['name']);
  $query->groupBy('ogm.etid');
  $query->condition('ogm.gid', $gid);
  $query->condition('ogm.created', $start_date->getTimestamp(), '>=');
  $query->condition('ogm.created', $end_date->getTimestamp(), '<=');

  $members = $query->execute()->fetchAll();

  if (empty($members)) {
    return '';
  }

  $group_users = [];
  foreach ($members as $item) {
    if (!empty($item->etid)) {
      $group_users[$item->etid] = (!empty($item->c4m_first_name_value) ? $item->c4m_first_name_value . ' ' : '');
      $group_users[$item->etid] .= (!empty($item->c4m_last_name_value) ? $item->c4m_last_name_value : '');
    }
  }

  $output = "First name|Last name|Total content posted|Total comments posted|Invited by|Group Member since|Membership status|Member role|Last login on c4d|Last activity in group|Organisation name|Organisation type|Country\n";
  foreach ($members as $item) {
    $output .= '"' . (!empty($item->c4m_first_name_value) ? str_replace("|", "", $item->c4m_first_name_value) : '');
    $output .= '"|"' . (!empty($item->c4m_last_name_value) ? str_replace("|", "", $item->c4m_last_name_value) : '');
    $output .= '"|' . (!empty($item->content) ? $item->content : 0);
    $output .= '|' . (!empty($item->comments) ? $item->comments : 0);
    $output .= '|' . (!empty($group_users[$item->inv_inviter_id]) ? $group_users[$item->inv_inviter_id] : '');
    $output .= '|"' . (!empty($item->created) ? date('d/m/Y h:i', $item->created) : '');
    $output .= '"|' . (!empty($item->status) ? $item->status : 0);
    $output .= '|"' . (!empty($item->name) ? str_replace("|", "", $item->name) : '');
    $output .= '"|"' . (!empty($item->login) ? date('d/m/Y h:i', $item->login) : '');
    $last_activity = 0;
    if (!empty($item->node_action)) {
      $last_activity = $item->node_action;
    }
    if (!empty($item->comments_action)) {
      if ($item->comments_action > $last_activity) {
        $last_activity = $item->comments_action;
      }
    }
    $output .= '"|"' . (!empty($last_activity) ? date('d/m/Y h:i', $last_activity) : '');
    $output .= '"|"' . (!empty($item->c4m_organisation_value) ? str_replace("|", "", $item->c4m_organisation_value) : '');
    $output .= '"|"' . (!empty($item->c4m_organisation_type_value) ? str_replace("|", "", $item->c4m_organisation_type_value) : '');
    $output .= '"|"' . (!empty($item->c4m_country_value) ? str_replace("|", "", $item->c4m_country_value) : '') . '"';
    $output .= "\n";
  }
  return $output;
}

/**
 * Form builder.
 *
 * Project owner replace form.
 */
function c4m_og_replace_project_owner_build_form($form, $form_state, $entity_type, $etid) {
  og_set_breadcrumb($entity_type, $etid, [l(t('Project'), "$entity_type/$etid/project")]);

  // Setting the list of the group admins.
  $admins = [];
  foreach (c4m_og_get_group_members($etid) as $admin) {
    $admins[$admin->uid] = c4m_user_name($admin);
  }

  if (!empty($admins)) {
    $form['new_owner'] = [
      '#type' => 'select',
      '#required' => TRUE,
      '#options' => $admins,
      '#title' => t('Select new owner'),
      '#description' => t('Select the name of the project admin you wish to be the new owner.'),
    ];

    $form['group'] = [
      '#type' => 'value',
      '#value' => $etid,
    ];

    $form['type'] = [
      '#type' => 'value',
      '#value' => $entity_type,
    ];

    $form['submit'] = [
      '#type' => 'submit',
      '#value' => t('Replace'),
    ];
  }
  else {
    $link = l(t('Visit the members admin page'), 'group/node/' . $etid . '/admin/people');
    $message = t('The project does not have any administrators to be the new owner. !link', ['!link' => $link]);
    drupal_set_message($message, 'warning');
  }

  return $form;
}

/**
 * Submit handler.
 *
 * Replacing the owner of a project.
 */
function c4m_og_replace_project_owner_build_form_submit($form, &$form_state) {
  $new_owner = [
    'uid' => $form_state['values']['new_owner'],
    'name' => $form['new_owner']['#options'][$form_state['values']['new_owner']],
  ];
  c4m_og_replace_owner($form_state['values']['type'], $form_state['values']['group'], $new_owner);

  // Redirect back to the project page.
  $form_state['redirect'] = 'node/' . $form_state['values']['group'];
}

/**
 * Replacing the owner of a group.
 *
 * After replacing the owner of the group we grant "group administrator member"
 * role to the old owner and revoke this role from the new one.
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 * @param array $new_owner
 *   An array containing the ID and the name of the new owner.
 */
function c4m_og_replace_owner($group_type, $gid, array $new_owner) {
  $group = entity_load_single($group_type, $gid);
  $old_owner_id = $group->uid;

  // Update the uid on the entity.
  $group->uid = $new_owner['uid'];

  // Save the entity.
  if (entity_save($group_type, $group)) {
    drupal_set_message(t('Failed to change manager to @user.', ['@user' => $new_owner['name']]), 'error');
  }
  else {
    drupal_set_message(t('Owner changed to @user.', ['@user' => $new_owner['name']]));

    $group_admin_role = c4m_og_user_role_load_by_name('administrator member', 'group');
    // Grant admin role to the old owner.
    og_role_grant($group_type, $gid, $old_owner_id, $group_admin_role->rid);
    // Revoke admin role from the new owner.
    og_role_revoke($group_type, $gid, $new_owner['uid'], $group_admin_role->rid);
  }
}

/**
 * Access callback for manage group pages.
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 *
 * @return bool
 *   TRUE if the current user has access to the group, FALSE otherwise.
 */
function c4m_og_user_is_owner($group_type, $gid) {
  global $user;

  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Make sure the current user is the group manager.
  return user_access('administer group') || $user->uid == $group->uid;
}

/**
 * Check if the current user is group member (or has the access of a member).
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 *
 * @return void|bool
 *   TRUE if the current user is group member, FALSE otherwise.
 */
function c4m_og_user_is_member($group_type = NULL, $gid = NULL) {
  if (empty($gid)) {
    $context = og_context('node');

    if (!isset($context['gid'])) {
      return FALSE;
    }

    $gid = $context['gid'];
    $group_type = $context['group_type'];
  }

  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Make sure the current user is the group manager.
  return user_access('administer group') || og_is_member('node', $gid);
}

/**
 * Check weather a user is banned (blocked) from a specific group.
 *
 * @param int $gid
 *   The ID of the group.
 * @param object $account
 *   (optional) The object of the user to check - Default is the current user.
 *
 * @return bool
 *   TRUE weather the user is banned from the group.
 */
function c4m_og_user_is_banned($gid, $account = NULL) {
  return og_is_member('node', $gid, 'user', $account, [OG_STATE_BLOCKED]);
}

/**
 * Fetches an og user role by its name and group bundle.
 *
 * @param string $role_name
 *   A string representing the role name.
 * @param string $group_bundle
 *   A string representing the group bundle.
 *
 * @return mixed
 *   A fully-loaded og role object if a role with the given name and group
 *   bundle exists, or FALSE otherwise.
 */
function c4m_og_user_role_load_by_name($role_name, $group_bundle) {
  $cache = &drupal_static(__FUNCTION__);
  $key = $role_name . '::' . $group_bundle;
  if (!isset($cache[$key])) {
    $cache[$key] = db_select('og_role', 'r')
      ->fields('r')
      ->condition('name', $role_name)
      ->condition('group_bundle', $group_bundle)
      ->execute()
      ->fetchObject();
  }

  return $cache[$key];
}

/**
 * Returns all group member ids.
 *
 * @param int $gid
 *   The ID of the group.
 * @param bool $verify_owner_added
 *   Whether to return group owner id, even if group owner does not
 *   have 'member' role.
 * @param bool $filter_event_user
 *   Whether to filter out current user ID from result, or not.
 *
 * @return array
 *   An array of all group admins ids.
 */
function c4m_og_get_group_member_ids($gid, $verify_owner_added = FALSE, $filter_event_user = FALSE) {
  $membership_ids = c4m_og_get_all_group_memberships_by_state($gid, OG_STATE_ACTIVE);
  $memberships = og_membership_load_multiple($membership_ids);

  $group = node_load($gid);
  $members = [];

  foreach ($memberships as $membership) {
    if ($membership->etid == $group->uid) {
      if ($verify_owner_added) {
        $members[] = $membership->etid;
      }
    }
    else {
      $members[] = $membership->etid;
    }
  }

  if ($filter_event_user) {
    // Filter current user ID from array with member ids.
    global $user;

    if (($index = array_search($user->uid, $members)) !== FALSE) {
      unset($members[$index]);
    }
  }

  return $members;
}

/**
 * Returns all group members.
 *
 * @param int $gid
 *   The ID of the group.
 *
 * @return array
 *   An array of all group admins.
 */
function c4m_og_get_group_members($gid) {
  return user_load_multiple(c4m_og_get_group_member_ids($gid));
}

/**
 * Returns all group admins ids.
 *
 * @param int $gid
 *   The ID of the group.
 * @param bool $verify_owner_added
 *   Whether to return group owner id, even if group owner does not
 *   have 'administrator member' role.
 * @param bool $filter_event_user
 *   Whether to filter out current user ID from result, or not.
 * @param string $group_type
 *   The group node type to filter for, defaults to "group".
 *
 * @return array
 *   An array of all group admins ids.
 */
function c4m_og_get_group_admins_ids($gid, $verify_owner_added = FALSE, $filter_event_user = FALSE, $group_type = 'group') {
  $group_admin_role = c4m_og_user_role_load_by_name('administrator member', $group_type);
  $admins = c4m_og_get_users_by_roles($gid, [$group_admin_role->rid]);
  foreach ($admins as &$admin) {
    $admin = $admin->uid;
  }

  $group = node_load($gid);

  if ($verify_owner_added) {
    if ($group && og_is_group('node', $group)) {
      if (!in_array($group->uid, $admins)) {
        $admins[] = $group->uid;
      }
    }
  }
  else {
    if ($group && og_is_group('node', $group)) {
      if ($key = array_search($group->uid, $admins)) {
        unset($admins[$key]);
      }
    }
  }

  if ($filter_event_user) {
    // Filter current user ID from array with admins ids.
    global $user;

    if (($index = array_search($user->uid, $admins)) !== FALSE) {
      unset($admins[$index]);
    }
  }

  return $admins;
}

/**
 * Returns the ids of group owner and group admins.
 *
 * Filters out current user, and admins that are blocked at that group.
 *
 * @param int $gid
 *   The ID of the group.
 *
 * @return array
 *   An array of all group admins ids.
 */
function c4m_og_get_group_admins_and_owner_ids_for_notification($gid) {
  $admins_ids = c4m_og_get_group_admins_ids($gid, TRUE, TRUE);
  $group = node_load($gid);
  $admins = user_load_multiple($admins_ids);

  $index = 0;
  foreach ($admins as $admin) {
    // Do not return users that are blocked (banned from group).
    if (c4m_user_og_get_role_in_group($admin, $group) == 'blocked') {
      unset($admins_ids[$index]);
    }

    $index++;
  }

  return $admins_ids;
}

/**
 * Returns all group admins.
 *
 * @param int $gid
 *   The ID of the group.
 * @param bool $verify_owner_added
 *   Whether to return group owner, even if group owner does not
 *   have 'administrator member' role.
 * @param string $group_type
 *   The group node type to filter for, defaults to "group".
 *
 * @return array
 *   An array of all group admins.
 */
function c4m_og_get_group_admins($gid, $verify_owner_added = FALSE, $group_type = 'group') {
  return user_load_multiple(c4m_og_get_group_admins_ids($gid, $verify_owner_added, FALSE, $group_type));
}

/**
 * Implements hook_module_implements_alter().
 */
function c4m_og_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter' && isset($implementations['c4m_og'])) {
    $c4m_og = $implementations['c4m_og'];
    unset($implementations['c4m_og']);
    $implementations['c4m_og'] = $c4m_og;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the Project creation form.
 */
function c4m_og_form_project_node_form_alter(array &$form, array &$form_state) {
  _c4m_og_alter_group_form($form, $form_state);
}

/**
 * Alters the add/edit form for group content types.
 *
 * @param array $form
 *   Form array.
 * @param array $form_state
 *   Form state array.
 * @param string $title
 *   (optional) Title used for page title.
 */
function _c4m_og_alter_group_form(array &$form, array &$form_state, $title = '') {
  // Form changes on creation.
  if (!$form['nid']['#value']) {
    // Change title.
    drupal_set_title('Request ' . $title ? $title : $form['#bundle']);

    // Change submit button on creation.
    $form['actions']['submit']['#value'] = t('Request');

    // Remove "Save as draft" button.
    $form['actions']['draft']['#access'] = FALSE;
  }
}

/**
 * Function to get roles per group bundle.
 *
 * @return array
 *   Array of roles per group bundle
 */
function c4m_og_get_group_bundles() {
  $roles = [];
  $result = db_select('og_role', 'ogr')->fields('ogr', [
    'group_bundle',
    'rid',
    'name',
  ])->execute()->fetchAll();
  foreach ($result as $row) {
    $roles[$row->group_bundle][$row->rid] = $row->name;
  }

  return $roles;
}

/**
 * Function to get OG permissions by OG role.
 *
 * @param int $rid
 *   The role ID.
 *
 * @return array
 *   Array of OG permissions
 */
function c4m_og_get_permissions_by_role($rid, $module = 'c4m_og') {
  $perms = [];
  $result = db_select('og_role_permission', 'ogrp')
    ->fields('ogrp', ['permission'])
    ->condition('rid', $rid)
    ->condition('module', $module)
    ->execute()
    ->fetchAll();
  foreach ($result as $row) {
    $perms[$row->permission] = $row->permission;
  }

  return $perms;
}

/**
 * Function to get OG roles by OG permission.
 *
 * @param string $permission
 *   The permission.
 * @param string $module
 *   The module name.
 *
 * @return array
 *   Array of role ids.
 */
function c4m_og_get_roles_by_permission($permission, $module = 'c4m_og') {
  $roles = [];
  $result = db_select('og_role_permission', 'ogrp')
    ->fields('ogrp', ['rid'])
    ->condition('permission', $permission)
    ->condition('module', $module)
    ->execute()
    ->fetchAll();
  foreach ($result as $row) {
    $roles[$row->rid] = $row->rid;
  }

  return $roles;
}

/**
 * Get all the users with certain roles in a group.
 *
 * @param int $gid
 *   The group unique ID.
 * @param array $rids
 *   Array with the role IDs to query.
 */
function c4m_og_get_users_by_roles($gid, array $rids = []) {
  $query = db_select('og_users_roles', 'og_users_roles');

  return $query->fields('og_users_roles', ['uid'])
    ->condition('gid', $gid)
    ->condition('rid', $rids, 'IN')
    ->execute()
    ->fetchAll();
}

/**
 * Implements hook_views_api().
 */
function c4m_og_views_api() {
  return ['api' => 3.0];
}

/**
 * Access callback for the c4m_og_access_plugin access plugin.
 *
 * @param string $feature
 *   Determine if the specified user has access to a given feature.
 * @param object $account
 *   If the $account argument is omitted, the current user is used.
 *
 * @return bool
 *   TRUE or FALSE whether access is granted or not.
 */
function c4m_og_access($feature = NULL, $account = NULL) {
  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);
    return FALSE;
  }

  // Check if the user has access to the group context.
  $og_context = og_context();
  if (!$og_context) {
    return FALSE;
  }

  // Check if the feature is enabled.
  if (empty($feature) || c4m_og_feature_enabled($feature)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_og_permission().
 *
 * Add group permissions.
 */
function c4m_og_og_permission() {
  return [
    'view unpublished group content' => [
      'title' => t('View unpublished group content'),
      'description' => t("Allow user to view unpublished content of a group."),
      'roles' => [OG_AUTHENTICATED_ROLE],
      'default role' => [OG_ANONYMOUS_ROLE, OG_ADMINISTRATOR_ROLE],
    ],
  ];
}

/**
 * Function to filter all groups of a user by a certain permission.
 *
 * It returns only the gids of the groups for which the user has the permission.
 *
 * We do this by retrieving roles of the user for the groups
 * and then check per role if it has that permission.
 *
 * We assemble all the permissions this user has in a group and with those we
 * filter out the groups which do not contain the desired permission.
 *
 * @param string $uid
 *   User id needed to collect the user roles for this user.
 * @param string $perm
 *   The permission to check on.
 * @param array $gids
 *   The group ID's to fetch the permissions for.
 */
function c4m_og_user_has_permission_in($uid, $perm, array &$gids) {
  foreach ($gids as $membership_id => $gid) {
    $roles = og_get_user_roles('node', $gid, $uid);
    $rids = array_keys($roles);
    $perms_for_gid = [];
    foreach ($rids as $rid) {
      $perms_for_gid = array_merge($perms_for_gid, c4m_og_get_permissions_by_role($rid));
    }
    if (!in_array($perm, $perms_for_gid)) {
      unset($gids[$gid]);
    }
  }
}

/**
 * Implements hook_node_grants().
 */
function c4m_og_node_grants($account, $op) {
  switch ($op) {
    case 'view':
      // Only grant group members and users with the appropriate role within
      // the group the right to view unpublished nodes.
      if ($groups = og_get_entity_groups('user', $account)) {
        // We need to know if the user has the right role within these
        // groups, meaning a role with the right permission.
        foreach ($groups as $group_type => $gids) {
          $perm = 'view unpublished group content';
          c4m_og_user_has_permission_in($account->uid, $perm, $gids);
          foreach ($gids as $gid) {
            $realm = C4M_OG_ACCESS_REALM . ':' . $perm;
            $grants[$realm][] = $gid;
          }
        }
        return !empty($grants) ? $grants : [];
      }
      break;
  }
}

/**
 * Implements hook_node_access_records_alter().
 *
 * We could use hook_node_access_records for this because node module and
 * og_access module do not deliver grants for unpublished nodes so there is no
 * real need to alter grants.
 * But then we would have an implementation of hook_node_access_records and
 * possibly in the future one of hook_node_access_records_alter.
 *
 * It's clearer to have our node_access_records logic in one place.
 */
function c4m_og_node_access_records_alter(&$grants, $node) {
  // Allow group members with the right permission to view unpublished group
  // content nodes.
  if (empty($node->status) && og_is_group_content_type('node', $node->type)) {
    // Node is unpublished, so og_access will not deliver grants, nor will node
    // (module).
    // We allow a view grant within our realm
    // 'c4m_og_access:view unpublished group content' for the groups of
    // which this node is content.
    $perm = 'view unpublished group content';
    // Retrieve groups of this node.
    $entity_groups = og_get_entity_groups('node', $node);
    foreach ($entity_groups as $group_type => $values) {
      foreach ($values as $gid) {
        $list_gids[$group_type][] = $gid;
        $grants[] = [
          'realm' => C4M_OG_ACCESS_REALM . ':' . $perm,
          'gid' => $gid,
          'grant_view' => 1,
          'grant_update' => 0,
          'grant_delete' => 0,
          'priority' => 0,
        ];
      }
    }
  }
}

/**
 * Counts the number of members in a given group.
 *
 * @param object $group
 *   The group entity.
 * @param int $state
 *   The status of the membership, Defaults to active.
 *
 * @return int
 *   The count of members in the group.
 */
function c4m_og_get_members_count($group, $state = OG_STATE_ACTIVE) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'og_membership')
    // This is the group ID.
    ->propertyCondition('gid', $group->nid)
    // Get only the active members.
    ->propertyCondition('state', $state)
    ->propertyCondition('entity_type', 'user')
    ->addTag('user_not_blocked')
    ->count()
    ->execute();

  return $result;
}

/**
 * Implements hook_query_TAG_alter().
 */
function c4m_og_query_user_not_blocked_alter(QueryAlterableInterface $query) {
  // Make sure to count only user who are not blocked.
  $query->innerjoin("users", "u", "u.uid = og_membership.etid AND u.status = '1'");
}

/**
 * Counts the number of posts in a given group.
 *
 * @param object $group
 *   The group entity.
 *
 * @return int
 *   The count of posts in the group.
 */
function c4m_og_get_posts_count($group) {
  $query = db_select('node', 'n');
  $query->join('og_membership', 'ogm', 'n.nid = ogm.etid');
  $query->fields('n', ['nid'])
    ->condition('n.status', 1)
    ->condition('ogm.gid', (int) $group->nid)
    ->condition('ogm.entity_type', 'node');

  return (int) $query->countQuery()->execute()->fetchField();
}

/**
 * Gets all group content bundles by entity type.
 *
 * @param string $entity_type
 *   Entity type (optional).
 *
 * @return array
 *   Bundles which are defined as group content.
 */
function c4m_og_get_all_group_content_bundles($entity_type = NULL) {
  $bundles = og_get_all_group_content_bundle();

  return $entity_type ? $bundles[$entity_type] : $bundles;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function c4m_og_entity_property_info_alter(&$info) {
  $info['node']['properties']['c4m_og_group_access_type'] = [
    'type' => 'text',
    'label' => t('Group access type'),
    'sanitized' => TRUE,
    'getter callback' => '_c4m_og_group_access_type_getter_callback',
  ];

  // Adding c4m_og_group_type to all group content bundles.
  $bundles = c4m_og_get_all_group_content_bundles('node');
  foreach (array_keys($bundles) as $bundle) {
    $info['node']['bundles'][$bundle]['properties']['c4m_og_group_type'] = [
      'type' => 'text',
      'label' => t('Group type'),
      'description' => t('The type of the group a content belongs to (group/project).'),
      'sanitized' => TRUE,
      'getter callback' => '_c4m_og_group_type_getter_callback',
    ];
  }
}

/**
 * Getter callback for c4m_og_group_access_type property.
 *
 * @param object $item
 *   The group object.
 *
 * @return string
 *   Type of group access.
 */
function _c4m_og_group_access_type_getter_callback($item) {
  // Get group type information.
  $group_access = c4m_og_get_access_type($item);
  if (!empty($group_access['type'])) {
    return ucfirst($group_access['type']);
  }
}

/**
 * Getter callback for c4m_og_group_type property.
 *
 * @param object $node
 *   A node object.
 *
 * @return string
 *   Type of group the node belongs to (group/project).
 */
function _c4m_og_group_type_getter_callback($node) {
  if (!$group = c4m_og_get_group_of_content($node)) {
    return '';
  }

  return $group->type;
}

/**
 * Get the group nid of the given entity.
 *
 * @param object $entity
 *   The entity we want the group id of.
 *
 * @return null|int
 *   The group ID if any.
 */
function c4m_og_get_gid_from_entity($entity) {
  // Check if entity has the "type" property.
  if (!property_exists($entity, 'type')) {
    return NULL;
  }

  if (og_is_group_type('node', $entity->type)) {
    return (int) $entity->nid;
  }

  if (og_is_group_content_type('node', $entity->type) && isset($entity->og_group_ref[LANGUAGE_NONE][0]['target_id'])) {
    return (int) $entity->og_group_ref[LANGUAGE_NONE][0]['target_id'];
  }

  return NULL;
}

/**
 * Load all group features info from implemented c4m_og_feature hooks.
 *
 * @param string $feature
 *   Only return data for a given feature.
 *
 * @return array
 *   Configuration as collected trough the implemented
 *   hook_c4m_og_feature_info hooks.
 */
function c4m_og_feature_info($feature = NULL) {
  $cache_key = 'c4m_og:feature_info';
  $data = &drupal_static($cache_key);

  // Retrieve from Cache if not loaded before.
  if (!isset($data)) {
    if (($cache = cache_get($cache_key)) && !empty($cache->data)) {
      $data = $cache->data;
    }
    else {
      $hook = 'c4m_og_feature_info';
      $data = module_invoke_all($hook);
      uasort($data, 'drupal_sort_weight');
      cache_set($cache_key, $data);
    }
  }

  // Only return data for a given feature.
  if (isset($data[$feature])) {
    return $data[$feature];
  }

  // Return all data.
  return $data;
}

/**
 * Check if a given feature is available for the active group.
 *
 * @param string $feature
 *   The feature to check.
 *
 * @return bool
 *   True if the feature is available for the active group.
 */
function c4m_og_feature_available($feature) {
  // Check if the feature exists.
  $og_feature = c4m_og_feature_info($feature);
  if (!isset($og_feature['machine_name'])) {
    return FALSE;
  }

  // Check if the feature should be enabled for the current group.
  $group = og_context();
  if ($group_type = c4m_og_get_group_type($group)) {
    if (!in_array($group_type, $og_feature['group_types'])) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Check if a given feature is enabled.
 *
 * @param string $feature
 *   The feature to check.
 *
 * @return bool
 *   True if the feature is enabled for the active group.
 */
function c4m_og_feature_enabled($feature) {
  if (c4m_og_feature_available($feature)) {
    // Check if the feature is enabled.
    $settings = variable_get('c4m_og_features_group', []);
    if (isset($settings[$feature]) && $settings[$feature] === $feature) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Get a list of enabled features for the active group.
 *
 * @return array
 *   An array with the features that are enabled for the active group.
 */
function c4m_og_feature_enabled_features() {
  $features = variable_get('c4m_og_features_group');

  foreach ($features as $feature => $status) {
    if (!$status) {
      unset($features[$feature]);
    }
  }

  return array_keys($features);
}

/**
 * Get a list of disabled features for the active group.
 *
 * @return array
 *   An array with the features that are disabled for the active group.
 */
function c4m_og_feature_disabled_features() {
  $features = variable_get('c4m_og_features_group');

  foreach ($features as $feature => $status) {
    if ($status) {
      unset($features[$feature]);
    }
  }

  return array_keys($features);
}

/**
 * Get a list of enabled content types for the active group.
 *
 * @return array
 *   An array with the content types that are enabled for the active group.
 */
function c4m_og_feature_enabled_content_types() {
  $content_types = [];

  $feature_info = c4m_og_feature_info();
  $features = c4m_og_feature_enabled_features();

  foreach ($features as $feature) {
    $group_content_types = $feature_info[$feature]['content_types'];
    $content_types = array_merge($content_types, $group_content_types);
  }

  return $content_types;
}

/**
 * Check if a given content type is enabled within the current group context.
 *
 * @param string $type
 *   The node type.
 *
 * @return bool
 *   Enabled?
 */
function c4m_og_feature_is_content_type_enabled($type) {
  $enabled_types = c4m_og_feature_enabled_content_types();
  return in_array($type, $enabled_types);
}

/**
 * Get a list of disabled content types for the active group.
 *
 * @return array
 *   An array with the content types that are disabled for the active group.
 */
function c4m_og_feature_disabled_content_types() {
  $content_types = [];

  $feature_info = c4m_og_feature_info();
  $features = c4m_og_feature_disabled_features();

  foreach ($features as $feature) {
    $group_content_types = $feature_info[$feature]['content_types'];
    $content_types = array_merge($content_types, $group_content_types);
  }

  return $content_types;
}

/**
 * Install a given feature.
 *
 * @param string $feature
 *   The feature to install.
 * @param bool $enabled
 *   Optional, if the feature should be enabled by default (default = TRUE).
 */
function c4m_og_feature_install($feature, $enabled = TRUE) {
  $settings = variable_get('c4m_og_features_group');
  if ($enabled) {
    $settings[$feature] = $feature;
  }
  else {
    $settings[$feature] = 0;
  }
  variable_set('c4m_og_features_group', $settings);
}

/**
 * Uninstall a given feature.
 *
 * @param string $feature
 *   The feature to uninstall.
 */
function c4m_og_feature_uninstall($feature) {
  $settings = variable_get('c4m_og_features_group');
  unset($settings[$feature]);
  variable_set('c4m_og_features_group', $settings);
}

/**
 * Get the group IDs of all the group nodes.
 *
 * For specific node type a user is an
 * approved member of.
 *
 * @param string $bundle
 *   (optional) The group node type.
 * @param object $account
 *   (optional) The user object to fetch group memberships for. Defaults to the
 *   acting user.
 *
 * @return array
 *   Returns array of group nodes IDs of specific node type.
 */
function c4m_og_get_user_group_ids_by_bundle($bundle = NULL, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  $groups = og_get_groups_by_user($account, 'node');
  if (!$groups || !$bundle) {
    return $groups;
  }

  // Apply bundle filter only for specific bundle type.
  $conditions = [];
  if ($bundle != 'showAll') {
    $conditions['type'] = $bundle;
  }

  $groups = node_load_multiple($groups, $conditions);

  $groups_ids = [];
  foreach ($groups as $group) {
    // Check whether the group has been published, or whether the user
    // is the group owner (applies only to 'My groups').
    if ($group->status == NODE_PUBLISHED || ($group->name == $account->name && $bundle == 'group')) {
      $groups_ids[] = $group->nid;
    }
  }

  return $groups_ids;
}

/**
 * Implements hook_node_update().
 */
function c4m_og_node_update($node) {
  if (!og_is_group_type('node', $node->type)) {
    return;
  }

  _c4m_og_handle_pending_members_when_going_private($node);
  c4m_og_open_group_access_activate_pending_members($node);
  c4m_og_handle_group_status_change($node);
}

/**
 * On group status change, trigger content realms update.
 *
 * @param object $node
 *   The node object of the group.
 */
function c4m_og_handle_group_status_change($node) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper_original = entity_metadata_wrapper('node', $node->original);

  if (!isset($wrapper->c4m_og_status) || !isset($wrapper_original->c4m_og_status)) {
    return;
  }

  $status = $wrapper->c4m_og_status->value();
  $former_status = $wrapper_original->c4m_og_status->value();

  // On status change, use OG Access mechanism to update realms of group
  // content. Update will be performed using Batch API.
  // Not required when group is approved (status changes from 'pending', as
  // group got no content at that point.
  if ($status != $former_status && $former_status != 'pending') {
    og_access_handle_group_privacy_change('node', $node);
  }
}

/**
 * Delete all pending memberships from a group the go private.
 *
 * @param object $node
 *   The node object of the group.
 */
function _c4m_og_handle_pending_members_when_going_private($node) {
  $access = c4m_og_get_access_type($node);
  if ($access['type'] != 'private') {
    return;
  }

  // Delete all pending memberships of this group.
  $ids = c4m_og_get_all_group_memberships_by_state($node->nid, OG_STATE_PENDING);
  og_membership_delete_multiple($ids);
}

/**
 * Activate pending members when access level of a group is changed.
 *
 * When changing the access level from 'Moderated' to 'Open', all pending
 * members should become active group members.
 *
 * @param object $node
 *   The node object while being updated.
 *
 * @throws \Exception
 *   When the node object doesn't contain the 'original' property.
 */
function c4m_og_open_group_access_activate_pending_members($node) {
  if (empty($node->original)) {
    throw new Exception('Node object must contain the original property.');
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $original_wrapper = entity_metadata_wrapper('node', $node->original);

  if (isset($wrapper->field_membership_open_request) && $wrapper->field_membership_open_request->value() != C4M_OG_OPEN_GROUP) {
    // Group is not "Open".
    return;
  }

  if (isset($original_wrapper->field_membership_open_request) && $original_wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // Previous group setting was not "Moderated".
    return;
  }

  // Activate all pending members of this group.
  $ids = c4m_og_get_all_group_memberships_by_state($node->nid, OG_STATE_PENDING);
  foreach (og_membership_load_multiple($ids) as $membership) {
    $membership->state = OG_STATE_ACTIVE;
    $membership->save();
  }
}

/**
 * Gets all the IDs of membership that has been added by invitation.
 *
 * @return array
 *   The IDs of the invited memberships.
 */
function c4m_og_get_invited_memberships_ids() {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache)) {
    $query = db_select('field_data_og_membership_invitation', 'ogm');
    $query->fields('ogm', ['entity_id']);

    $cache = array_keys($query->execute()->fetchAllAssoc(0, 0));
  }

  return $cache;
}

/**
 * Get the group membership entity by user, group and state.
 *
 * @param int $gid
 *   The group ID.
 * @param int $state
 *   The user current state.
 * @param bool $exclude_invitations
 *   A flag to determine if to exclude invited memberships.
 *
 * @return array
 *   Array of members UIDs, or an empty array.
 */
function c4m_og_get_all_group_memberships_by_state($gid, $state, $exclude_invitations = FALSE) {
  $cache = &drupal_static(__FUNCTION__ . (string) $exclude_invitations, []);

  $identifier = $gid . ':' . $state;

  if (isset($cache[$identifier])) {
    return $cache[$identifier];
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('gid', $gid)
    ->propertyCondition('state', $state)
    ->propertyCondition('group_type', 'node')
    ->propertyCondition('entity_type', 'user');

  if ($exclude_invitations) {
    // Add the condition only if there are invited memberships.
    if ($invited_memberships = c4m_og_get_invited_memberships_ids()) {
      $query->propertyCondition('id', $invited_memberships, 'NOT IN');
    }
  }

  $result = $query->execute();

  $cache[$identifier] = !empty($result['og_membership']) ? array_keys($result['og_membership']) : [];

  return $cache[$identifier];
}

/**
 * Returns the amount of nodes in the group of the specified bundles.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 * @param array $bundles
 *   The bundles to query for.
 *
 * @return int
 *   The amount of nodes in the group.
 */
function c4m_og_group_node_metric($og_id, array $bundles) {
  $arguments = [
    'entity_type' => 'node',
    'bundles' => $bundles,
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  ];

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Returns the amount of users in the group of the specified bundles.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 *
 * @return int
 *   The amount of users in the group.
 */
function c4m_og_group_user_metric($og_id) {
  $arguments = [
    'entity_type' => 'user',
    'bundles' => [],
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  ];

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Returns the amount of comments in the group.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 *
 * @return int
 *   The amount of comments in the group.
 */
function c4m_og_group_comment_metric($og_id) {
  $arguments = [
    'entity_type' => 'comment',
    'bundles' => [],
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  ];

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Implements hook_c4m_helper_entity_metrics_info().
 */
function c4m_og_c4m_helper_entity_metrics_info() {
  return [
    'c4m_og_content_recommendations' => [
      'type' => 'content_recommendations',
      'context' => 'group',
      'callback' => 'c4m_og_get_content_recommendations',
      'weight' => 100,
    ],
    'c4m_og_content_follows' => [
      'type' => 'content_follows',
      'context' => 'group',
      'callback' => 'c4m_og_get_content_follows',
      'weight' => 100,
    ],
    'c4m_user_group_memberships' => [
      'type' => 'group_memberships',
      'context' => 'user',
      'callback' => 'c4m_og_get_user_group_memberships_count',
    ],
    'c4m_user_group_pending_memberships' => [
      'type' => 'group_pending_memberships',
      'context' => 'user',
      'callback' => 'c4m_og_get_user_group_pending_memberships_count',
    ],
  ];
}

/**
 * Returns the total amount of recommendations on content of a group.
 *
 * @param int $og_id
 *   The Organic group ID to limit the query for.
 *
 * @return int
 *   The total amount of recommendations on the group content.
 */
function c4m_og_get_content_recommendations($og_id = NULL) {
  return c4m_og_get_content_flag_count($og_id, 'c4m_og_content_recommend');
}

/**
 * Returns the total number of follows on content of a group.
 *
 * @param int $og_id
 *   The Organic group ID to limit the query for.
 *
 * @return int
 *   The total amount of follows on the group content.
 */
function c4m_og_get_content_follows($og_id = NULL) {
  return c4m_og_get_content_flag_count($og_id, 'subscribe_c4m_follow_content');
}

/**
 * Returns the sum of flag counts for content inside a group for a flag.
 *
 * @param int $og_id
 *   The Organic group ID to limit the query for.
 * @param string $flag_name
 *   The name of the flag.
 *
 * @return int
 *   The sum of flag counts.
 */
function c4m_og_get_content_flag_count($og_id, $flag_name) {
  if (!is_numeric($og_id)) {
    return 0;
  }

  $query = db_select('node', 'n');
  $query->join('og_membership', 'ogm', 'ogm.etid = n.nid');
  $query->join('flag_counts', 'fc', 'fc.entity_id = n.nid');
  $query->join('flag', 'f', 'f.fid = fc.fid');
  $query->condition('n.status', NODE_PUBLISHED);
  $query->condition('ogm.gid', (int) $og_id);
  $query->condition('ogm.entity_type', 'node');
  $query->condition('fc.entity_type', 'node');
  $query->condition('f.name', $flag_name);
  $query->addExpression('SUM(fc.count)', 'count');

  $count = $query->execute()->fetchField();
  return empty($count) ? 0 : $count;
}

/**
 * Helper function to get group type (project|group).
 *
 * @param array $group
 *   The group to get the type from.
 * @param bool $subtype
 *   Return node bundle or dive deeper for subtypes.
 *
 * @return string
 *   Group type (project|group).
 */
function c4m_og_get_group_type(array $group, $subtype = FALSE) {
  if (!empty($group)) {
    if ($group_node = node_load($group['gid'])) {
      return c4m_og_get_group_type_from_node($group_node, $subtype);
    }
  }
  return FALSE;
}

/**
 * Helper function to get group type (project|group).
 *
 * @param object $group
 *   The node object to get the type from.
 * @param bool $subtype
 *   Return node bundle or dive deeper for subtypes.
 *
 * @return string
 *   Group type (project|group).
 */
function c4m_og_get_group_type_from_node($group, $subtype = FALSE) {
  if ($subtype && $group->type === 'project') {
    return $group->c4m_project_type[LANGUAGE_NONE][0]['value'];
  }

  return $group->type;
}

/**
 * Returns the group memberships count for an user.
 *
 * @param int $uid
 *   User id.
 * @param int $state
 *   Node type.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_group_memberships_count($uid, $state = OG_STATE_ACTIVE) {
  $query = db_select('og_membership', 'm');
  $query->fields('m', ['id']);
  $query->join('node', 'n', 'n.nid = m.gid');
  $query->condition('m.entity_type', 'user');
  $query->condition('m.etid', $uid);
  $query->condition('m.state', $state);
  $query->condition('n.type', 'group');

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns the group memberships count for an user.
 *
 * @param int $uid
 *   User id.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_group_pending_memberships_count($uid) {
  return c4m_og_get_user_group_memberships_count($uid, OG_STATE_PENDING);
}

/**
 * Returns the administered groups count for an user.
 *
 * Differentiate between projects and programmes.
 *
 * @param int $uid
 *   User id.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_administered_groups_count($uid) {
  $query = db_select('og_users_roles', 'ur');
  $query->fields('ur');
  $query->join('og_role', 'r', "ur.rid = r.rid AND name = 'administrator member' AND ur.uid = $uid");
  $query->join('node', 'n', "ur.gid = n.nid AND ur.group_type = 'node' AND n.type = 'group'");

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns the memberships in projects/programmes count for an user.
 *
 * @param int $uid
 *   User id.
 * @param int $is_programme
 *   Differentiate between projects and programmes.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_project_memberships_count($uid, $state = OG_STATE_ACTIVE, $is_programme = 0) {
  $query = db_select('og_membership', 'm');
  $query->fields('m', ['id']);
  $query->join('node', 'n', 'n.nid = m.gid');
  $query->condition('m.entity_type', 'user');
  $query->condition('m.etid', $uid);
  $query->condition('m.state', $state);
  $query->condition('n.type', 'project');

  $query->leftJoin('field_data_c4m_project_type', 'pt', 'pt.entity_id = n.nid');

  if ($is_programme) {
    $query->condition('pt.c4m_project_type_value', 'programme', '=');
  }
  else {
    $query->condition('pt.c4m_project_type_value', 'project', '=');
  }

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns the administered projects/programmes count for an user.
 *
 * @param int $uid
 *   User id.
 * @param int $is_programme
 *   Differentiate between projects and programmes.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_administered_projects_count($uid, $is_programme = 0) {
  $query = db_select('og_users_roles', 'ur');
  $query->fields('ur');
  $query->join('og_role', 'r', "ur.rid = r.rid AND name = 'administrator member' AND ur.uid = $uid");
  $query->join('node', 'n', "ur.gid = n.nid AND ur.group_type = 'node' AND n.type = 'project'");
  $query->leftJoin('field_data_c4m_project_type', 'pt', 'pt.entity_id = n.nid');

  if ($is_programme) {
    $query->condition('pt.c4m_project_type_value', 'programme', '=');
  }
  else {
    $query->condition('pt.c4m_project_type_value', 'project', '=');
  }

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns an array of all OG Group content bundles, of type 'node'.
 *
 * @return array
 *   OG Group content bundles, of type 'node'.
 */
function c4m_og_get_group_content_bundles() {
  $node_bundles = c4m_og_get_all_group_content_bundles('node');

  unset($node_bundles['news']);
  unset($node_bundles['share']);

  return array_keys($node_bundles);
}

/**
 * Returns an array of OG content types that require notification.
 *
 * @return array
 *   Notification types.
 */
function c4m_og_get_group_content_notification_types() {
  return ['discussion', 'document', 'event', 'wiki_page', 'news'];
}

/**
 * Returns extended list of content types that require notification.
 *
 * All group content types, and global content 'article'.
 *
 * @return array
 *   Content types (group and global), that require notifications.
 */
function c4m_og_get_extended_content_notification_types() {
  $comment_notification_types = c4m_og_get_group_content_notification_types();
  $comment_notification_types[] = 'article';

  return $comment_notification_types;
}

/**
 * Compares the OG type (project|group) to input.
 *
 * @param string $type
 *   The group to get the type from.
 *
 * @return bool
 *   Whether current OG group type matches the input.
 */
function c4m_og_is_of_group_type($type) {
  $context = og_context();
  if (!$context) {
    return FALSE;
  }

  $og_group_type = c4m_og_get_group_type($context);
  if (!$og_group_type || $og_group_type != $type) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns the groups owned by an user.
 *
 * @param int $uid
 *   User id.
 * @param string|array $node_type
 *   Node type or types.
 *
 * @return array
 *   Keyed array of Node IDs and titles.
 */
function c4m_og_get_user_owned_groups($uid, $node_type) {
  $query = db_select('node', 'n');
  $query->fields('n', ['nid', 'title']);
  $query->condition('n.uid', $uid);
  $query->condition('n.type', $node_type);

  $results = $query->execute();
  $nids = $results->fetchAllKeyed();

  return $nids;
}

/**
 * Gets the group node of the given node.
 *
 * @param object $node
 *   A node we wish to get its group node.
 *
 * @return bool|mixed
 *   The object of the group, FALSE if no results found.
 */
function c4m_og_get_group_of_content($node) {
  $result = og_get_entity_groups('node', $node);
  if (empty($result['node'])) {
    return FALSE;
  }

  $gid = reset($result['node']);

  return node_load($gid);
}

/**
 * Gets the state of a given group.
 *
 * Assuming the given group is a node with the type 'group'.
 *
 * @param object $group
 *   The object of the group.
 *
 * @return string
 *   The state of the group.
 */
function c4m_og_get_group_status($group) {
  $wrapper = entity_metadata_wrapper('node', $group);

  return $wrapper->c4m_og_status->value();
}

/**
 * Handles 'view' operation of hook_node_access().
 */
function c4m_og_view_node_access($node, $account) {
  if (og_is_group('node', $node)) {

    $allowed_states = [
      C4M_USER_TYPE_VISITOR => [],
      C4M_USER_TYPE_NON_MEMBER => [],
      C4M_USER_TYPE_GM => ['draft', 'archived', 'published'],
      C4M_USER_TYPE_GA => ['draft', 'archived', 'published'],
      C4M_USER_TYPE_GO => ['pending', 'draft', 'archived', 'published'],
    ];

    $group_access = c4m_og_get_access_type($node);

    if ($group_access['type'] == 'public') {
      // Archived and published states are allowed for public group.
      $allowed_states[C4M_USER_TYPE_VISITOR] = $allowed_states[C4M_USER_TYPE_NON_MEMBER] = [
        'archived',
        'published',
      ];
    }
    elseif ($group_access['type'] == 'restricted') {
      // User is not a member, but can access restricted group.
      if (c4m_og_user_can_access_restricted_group($node, $account, 'view')) {
        // Published state is allowed for restricted group.
        $allowed_states[C4M_USER_TYPE_NON_MEMBER][] = 'published';
        $allowed_states[C4M_USER_TYPE_NON_MEMBER][] = 'archived';
      }
    }

    $user_type = _c4m_features_og_members_get_user_type($node, $account);
    $group_state = c4m_og_get_group_status($node);

    // If group's state appears at allowed states array, for logged in
    // user type, access is allowed.
    return in_array($group_state, $allowed_states[$user_type]) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }
  elseif (og_is_group_content_type('node', $node->type)) {
    // We have a custom access handler for shares in.
    // @seealso c4m_content_share_node_access_records_alter().
    if ($node->type == 'share') {
      return NODE_ACCESS_IGNORE;
    }

    // Couldn't resolve the group of the content.
    if (!$group = c4m_og_get_group_of_content($node)) {
      return NODE_ACCESS_IGNORE;
    }

    // Group content is saved as draft.
    if ($node->status == NODE_NOT_PUBLISHED) {

      $user_type = _c4m_features_og_members_get_user_type($group, $account);
      // Not relevant for projects, as they do not have regular members.
      $allowed_wiki_page = $node->type == 'wiki_page' && $user_type == C4M_USER_TYPE_GM && c4m_content_wiki_page_is_editable_by_members($node);

      // Only power user or content author may view the node.
      if (c4m_features_og_members_is_power_user($group) || $node->uid == $account->uid || $allowed_wiki_page) {
        return NODE_ACCESS_ALLOW;
      }
      else {
        return NODE_ACCESS_DENY;
      }
    }

    // View access of content is same as view access of group it belongs to.
    $group_access = node_access('view', $group, $account);

    return $group_access ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }

  // The content is not OG. For example: article.
  return NODE_ACCESS_IGNORE;
}

/**
 * Handles 'create' operation of hook_node_access().
 */
function c4m_og_create_node_access($node, $account) {
  // When creating, $node is string that indicates bundle name.
  if (og_is_group_type('node', $node)) {

    // Any authenticated user may create groups and projects.
    return $account->uid === 0 ? NODE_ACCESS_DENY : NODE_ACCESS_ALLOW;
  }
  elseif (og_is_group_content_type('node', $node)) {

    $group = c4m_og_current_group();
    $user_type = _c4m_features_og_members_get_user_type($group, $account);
    // Can't resolve user type - couldn't get OG context to resolve group.
    if (!$user_type) {
      return NODE_ACCESS_IGNORE;
    }

    // Only group members or power users may create content.
    if ($user_type == C4M_USER_TYPE_VISITOR || $user_type == C4M_USER_TYPE_NON_MEMBER) {
      return NODE_ACCESS_DENY;
    }

    // We allow access only for draft / published groups.
    $group_state = c4m_og_get_group_status($group);
    $allowed_states = ['draft', 'published'];

    // Group state is not allowed.
    if (!in_array($group_state, $allowed_states)) {
      return NODE_ACCESS_DENY;
    }

    // We know that the user is member or power member.
    return NODE_ACCESS_ALLOW;
  }

  // The content is not OG. For example: article.
  return NODE_ACCESS_IGNORE;
}

/**
 * Handles 'update' operation of hook_node_access().
 */
function c4m_og_update_node_access($node, $account) {

  if (og_is_group('node', $node)) {
    // GA and GO get access to draft and published groups.
    // GO also gets access to pending groups.
    $allowed_states = [
      C4M_USER_TYPE_VISITOR => [],
      C4M_USER_TYPE_NON_MEMBER => [],
      C4M_USER_TYPE_GM => [],
      C4M_USER_TYPE_GA => ['draft', 'published'],
      C4M_USER_TYPE_GO => ['pending', 'draft', 'published'],
    ];

    $user_type = _c4m_features_og_members_get_user_type($node, $account);
    $group_state = c4m_og_get_group_status($node);

    // If group's state appears at allowed states array, for logged in
    // user type, access is allowed.
    return in_array($group_state, $allowed_states[$user_type]) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }
  elseif (og_is_group_content_type('node', $node->type)) {

    $group = c4m_og_get_group_of_content($node);
    $user_type = _c4m_features_og_members_get_user_type($group, $account);
    // Can't resolve user type - couldn't get OG context to resolve group.
    if (!$user_type) {
      return NODE_ACCESS_IGNORE;
    }

    // Only group members or power users may update content.
    if ($user_type == C4M_USER_TYPE_VISITOR || $user_type == C4M_USER_TYPE_NON_MEMBER) {
      return NODE_ACCESS_DENY;
    }

    // When updating published wiki page, deny access to group members,
    // if 'editable by members' option is not enabled for this page.
    // Not relevant for projects, as they do not have regular members.
    if ($group->type == 'group' && $node->type == 'wiki_page') {
      if ($user_type == C4M_USER_TYPE_GM && !c4m_content_wiki_page_is_editable_by_members($node)) {
        return NODE_ACCESS_DENY;
      }
      else {
        return NODE_ACCESS_ALLOW;
      }
    }

    // We allow access only for draft / published groups.
    $group_state = c4m_og_get_group_status($group);
    $allowed_states = ['draft', 'published'];

    // Group state is not allowed.
    if (!in_array($group_state, $allowed_states)) {
      return NODE_ACCESS_DENY;
    }

    // We allow access to power users, and member that is also content author.
    $allowed_user_types = [
      C4M_USER_TYPE_GA,
      C4M_USER_TYPE_GO,
      C4M_USER_TYPE_SA,
    ];

    if (in_array($user_type, $allowed_user_types)) {
      return NODE_ACCESS_ALLOW;
    }
    elseif ($user_type == C4M_USER_TYPE_GM) {
      // User is content author, or not.
      return ($node->uid == $account->uid) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
    }
  }

  // The content is not OG. For example: article.
  return NODE_ACCESS_IGNORE;
}

/**
 * Handles 'delete' operation of hook_node_access().
 */
function c4m_og_delete_node_access($node, $account) {

  if (og_is_group('node', $node)) {

    // Only site admin may delete groups.
    return c4m_user_is_site_admin($account) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }
  elseif (og_is_group_content_type('node', $node->type)) {

    $group = c4m_og_get_group_of_content($node);
    $user_type = _c4m_features_og_members_get_user_type($group, $account);
    // Can't resolve user type - couldn't get OG context to resolve group.
    if (!$user_type) {
      return NODE_ACCESS_IGNORE;
    }

    // Only group members or power users may delete content.
    if ($user_type == C4M_USER_TYPE_VISITOR || $user_type == C4M_USER_TYPE_NON_MEMBER) {
      return NODE_ACCESS_DENY;
    }

    // We allow access only for draft / published groups.
    $group_state = c4m_og_get_group_status($group);
    $allowed_states = ['draft', 'published'];

    // Group state is not allowed.
    if (!in_array($group_state, $allowed_states)) {
      return NODE_ACCESS_DENY;
    }

    // We allow access to power user, and member that is also content author.
    $allowed_user_types = [
      C4M_USER_TYPE_GA,
      C4M_USER_TYPE_GO,
      C4M_USER_TYPE_SA,
    ];

    if (in_array($user_type, $allowed_user_types)) {
      return NODE_ACCESS_ALLOW;
    }
    elseif ($user_type == C4M_USER_TYPE_GM) {
      // User is content author, or not.
      return ($node->uid == $account->uid) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
    }
  }

  // The content is not OG. For example: article.
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_node_access().
 */
function c4m_og_node_access($node, $op, $account) {

  switch ($op) {
    case 'view':
      return c4m_og_view_node_access($node, $account);

    case 'create':
      return c4m_og_create_node_access($node, $account);

    case 'update':
      return c4m_og_update_node_access($node, $account);

    case 'delete':
      return c4m_og_delete_node_access($node, $account);

  }
}

/**
 * Returns true is user has access to restricted group.
 *
 * @param object $group
 *   Restricted group, to which access is required.
 * @param object $account
 *   User that requests access.
 * @param string $op
 *   Operation, for which user requested the access.
 *
 * @return bool
 *   True if user got access to group.
 */
function c4m_og_user_can_access_restricted_group($group, $account, $op) {
  $node_grants = array_keys(pluggable_node_access_node_grants($account, $op));
  $node_access_records = pluggable_node_access_node_access_records($group);

  // If one of node grants matches a realm of node access record,
  // access is allowed.
  foreach ($node_grants as $node_grant) {
    foreach ($node_access_records as $node_access_record) {
      if ($node_grant == $node_access_record['realm']) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Add the `Authoring information` tab to the group content editing forms.
 *
 * Allows group owner and administrators to change the author of content in the
 * group. Limits possible authors to group members or anonymous user.
 */
function c4m_og_add_content_author_options_to_power_users(&$form) {
  // Site administrator already has these options by default.
  $site_admin_role = user_role_load_by_name('administrator');
  if (user_has_role($site_admin_role->rid)) {
    return;
  }

  $gid = c4m_og_current_group_id();
  // Return early if there is no group context.
  if (!$gid) {
    return;
  }

  // Show authoring information tab to GAs and GO, when editing group content.
  if (c4m_features_og_members_is_power_user()) {
    $form['author']['#access'] = TRUE;
    // Per https://issuetracker.amplexor.com/jira/browse/CFM-1248, there's
    // no need to present the 'Authored on' date field.
    $form['author']['date']['#access'] = FALSE;
  }

  // Limit possible authors to members of the group only.
  $form['author']['name']['#autocomplete_path'] = 'edit-author/autocomplete/' . $gid;
  $form['#validate'][] = 'c4m_og_form_valid_author';
}

/**
 * Added validation of the author for the group content editing forms.
 */
function c4m_og_form_valid_author($form, &$form_state) {
  $user = user_load_by_name($form_state['values']['name']);
  $gid = c4m_og_current_group_id();
  // Can't validate author if there is no group context.
  if (!$gid) {
    form_set_error('name', 'There was an error validating the author for this group.');
  }

  // Author may be anonymous (when a user cancel its account and choose to
  // anonymize the content.
  if ($user && $user->uid && !c4m_user_is_site_admin($user) && !og_is_member('node', $gid, 'user', $user)) {
    form_set_error('name', $form_state['values']['name'] . ' is not an active member of this group.');
  }
}

/**
 * Author autocomplete callback.
 *
 * Returns a JSON of all active members of an OG group where the username
 * contains the search string (for autocomplete author field).
 */
function c4m_og_edit_author_autocomplete($group, $string = '') {
  // Return early if no search string was received.
  if (!trim($string)) {
    return;
  }

  $query = db_select('users', 'u');
  $query->join('og_membership', 'ogm', 'u.uid = ogm.etid');
  $query->fields('u', ['name'])
    ->condition('ogm.group_type', 'node', '=')
    ->condition('ogm.gid', $group->nid, '=')
    ->condition('ogm.entity_type', 'user', '=')
    ->condition('ogm.state', OG_STATE_ACTIVE, '=')
    ->condition('u.name', '%' . db_like($string) . '%', 'LIKE');
  $result = $query->execute()->fetchAllKeyed(0, 0);

  drupal_json_output($result);
}

/**
 * Convert a human readable title to a machine readable name.
 *
 * The function replaces anything other than letters, numbers and underscores
 * in the $title string with the $delimiter and converts capital to lowercase.
 *
 * @return string
 *   The title in machine readable form.
 */
function c4m_og_human_to_machine_readable($title, $delimiter = '-') {
  return preg_replace('@[^a-z0-9_]+@', $delimiter, strtolower(trim($title)));
}

/**
 * Counts the content of a member in a given group.
 *
 * @param int $group_id
 *   The group entity id.
 * @param int $user_id
 *   The user entity id.
 * @param int $state
 *   (optional) The node status. Defaults to published.
 *
 * @return int
 *   The count of nodes of an user in the group.
 */
function c4m_og_get_content_count($group_id, $user_id, $state = NODE_PUBLISHED) {
  $query = db_select('node', 'n');
  // Draft.
  $query->condition('n.status', $state);
  $query->condition('n.uid', $user_id);
  $query->join('og_membership', 'og', 'n.nid = og.etid');
  $query->condition('og.entity_type', 'node');
  $query->condition('og.gid', $group_id);
  $query->addExpression('COUNT(n.nid)', 'nodes');
  $count = $query->execute()->fetchField();

  return $count;
}

/**
 * Comparison function for groups, will prioritize group statuses.
 *
 * @param object $a
 *   Group entity A to compare.
 * @param object $b
 *   Group entity B to compare.
 *
 * @return int
 *   Comparison value (-1 or 0 or 1).
 */
function _c4m_og_sort_by_status($a, $b) {
  $priorities = [
    'published',
    'archived',
    'draft',
    'pending',
    'deleted',
  ];

  $status_a = $a->c4m_og_status[LANGUAGE_NONE][0]['value'];
  $status_b = $b->c4m_og_status[LANGUAGE_NONE][0]['value'];

  $rank_a = array_search($status_a, $priorities);
  $rank_b = array_search($status_b, $priorities);

  if ($rank_a == $rank_b) {
    return strcmp($a->title, $b->title);
  }
  return ($rank_a < $rank_b) ? -1 : 1;
}

/**
 * Get the group IDs of all the groups a user is a pending member of.
 *
 * Function og_user_access() returns active memberships. This function returns
 * pending memberships.
 *
 * @see og_user_access()
 *
 * @return array
 *   An array with the group IDs or an empty array.
 */
function c4m_og_get_pending_groups_by_user($account = NULL, $group_type = NULL, $access_check = FALSE) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  $gids = [];

  if (!og_get_group_audience_fields()) {
    // User entity doesn't have group audience fields.
    return $gids;
  }

  // Get all active OG membership that belong to the user.
  $wrapper = entity_metadata_wrapper('user', $account->uid);
  $og_memberships = $wrapper->{'og_membership__' . OG_STATE_PENDING}->value();
  if (!$og_memberships) {
    return $gids;
  }

  $groups = [];
  foreach ($og_memberships as $og_membership) {
    if (empty($og_membership)) {
      // OG membership might have been just deleted.
      continue;
    }
    $groups[$og_membership->group_type][] = $og_membership->gid;
  }

  foreach ($groups as $entity_type => $ids) {
    foreach (entity_load($entity_type, $ids) as $entity) {
      if ($access_check && !entity_access('view', $entity_type, $entity, $account)) {
        // User doesn't have access to the group.
        continue;
      }
      list($id) = entity_extract_ids($entity_type, $entity);
      $gids[$entity_type][$id] = $id;
    }
  }

  if (empty($group_type)) {
    return $gids;
  }
  elseif (!empty($gids[$group_type])) {
    return $gids[$group_type];
  }
}

/**
 * Return true if the user is allowed to invite, and false if he isn't.
 *
 * Checks by og_permissions, group state and moderation type.
 */
function c4m_og_invite_access($group_type, $gid) {
  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);

    return FALSE;
  }

  if (!$current_gid = c4m_og_current_group_id()) {
    return FALSE;
  }

  // Validate the current group is the one a user is trying to invite to.
  if ($current_gid != $gid) {
    drupal_set_message("Something went wrong, please click on the 'Invite a member' from the group homepage.", 'error');

    return FALSE;
  }

  if (c4m_user_is_site_admin()) {
    return TRUE;
  }

  // OG invite access is allowed for group members and administrators.
  if (!_og_invite_access($group_type, $gid)) {
    return FALSE;
  }

  $group = node_load($gid);
  $allowed_group_states = ['draft', 'published'];
  $group_state = c4m_og_get_group_status($group);

  // Invite is allowed at groups with Draft/Published state.
  if (!in_array($group_state, $allowed_group_states)) {
    return FALSE;
  }

  // Either 'open' or 'moderated'.
  $group_moderation_state = c4m_og_get_group_membership_request($group);
  $user_type = _c4m_features_og_members_get_user_type($group);
  $group_access = c4m_og_get_access_type($group);

  // Group members can't invite to private group, or group that is moderated.
  if ($user_type == C4M_USER_TYPE_GM && ($group_access == 'private' || $group_moderation_state != 'open')) {
    return FALSE;
  }

  // If we got so far, user is allowed to invite.
  return TRUE;
}

/**
 * Access function for gallery items uploads.
 *
 * @see node_gallery_api_upload_access()
 */
function c4m_og_node_gallery_access($gallery, $item_type = NULL) {
  $relationship_types = node_gallery_api_get_relationship_type($gallery->type, $item_type);

  // Assign access to Node Gallery API item type upload, there's a relationship
  // for gallery item type, and user got permission to edit the gallery.
  return (!empty($relationship_types) && node_access('update', $gallery));
}

/**
 * A helper function; Determine the labels to display on the registration form.
 *
 * The labels should be different by the 'membership_open_request' field of the
 * group.
 *
 * @param int $gid
 *   The ID of the group.
 *
 * @return array
 *   An array with the values of the 'join phrase' and the 'button label'.
 */
function _c4m_og_registration_form_labels_by_group($gid) {
  $wrapper = entity_metadata_wrapper('node', $gid);

  // Get membership request type (open/moderated).
  $group_membership_request_type = _c4m_user_notifications_get_group_membership_request_type($wrapper);
  if ($group_membership_request_type == C4M_OG_MODERATED_GROUP) {
    $join_phrase = t('request membership for');
    $button_label = t('Request membership for group');
  }
  else {
    $join_phrase = t('join the');
    $button_label = t('Register to join');
  }

  return [$join_phrase, $button_label];
}

/**
 * Implements hook_drupal_goto().
 *
 * When drupal base_path is not trivial, remove it, in case
 * $path includes it as prefix.
 * This is required to avoid duplicate base_path at redirect url, since
 * base_path is added by url() function, which is executed by drupal_goto().
 */
function c4m_og_drupal_goto_alter(&$path, &$options, &$http_response_code) {
  $base_path = base_path();

  if ($base_path == '/') {
    return;
  }

  if (_c4m_og_purl_starts_with($path, $base_path)) {
    $path = substr($path, strlen($base_path));
  }
}

/**
 * Implements hook_node_insert().
 *
 * Increase users posts number count, when user posts at group.
 */
function c4m_og_node_insert($node) {
  if ($node->status == NODE_NOT_PUBLISHED) {
    // Do not handle unpublished nodes.
    return;
  }

  $group_content_types = array_keys(c4m_og_get_all_group_content_bundles('node'));
  if (!in_array($node->type, $group_content_types)) {
    // Node is not a post.
    return;
  }

  c4m_og_alter_membership_totals($node, 'node', 1);
}

/**
 * Implements hook_node_delete().
 *
 * Decrease users posts number count, when user deletes a post.
 */
function c4m_og_node_delete($node) {
  if ($node->status == NODE_NOT_PUBLISHED) {
    // Do not handle unpublished nodes.
    return;
  }

  $group_content_types = array_keys(c4m_og_get_all_group_content_bundles('node'));
  if (!in_array($node->type, $group_content_types)) {
    // Node is not a post.
    return;
  }

  c4m_og_alter_membership_totals($node, 'node', -1);
}

/**
 * Implements hook_comment_insert().
 *
 * Increase users comments number count, when user comments at group.
 */
function c4m_og_comment_insert($comment) {
  if ($comment->status == NODE_NOT_PUBLISHED) {
    // Do not handle unpublished comments.
    return;
  }

  $node = node_load($comment->nid);
  $group_content_types = array_keys(c4m_og_get_all_group_content_bundles('node'));
  if (!in_array($node->type, $group_content_types)) {
    // Comment is not on group content.
    return;
  }

  $group = c4m_og_get_group_of_content($node);
  if (!$group) {
    // Failed to resolve the group.
    return;
  }

  c4m_og_alter_membership_totals($comment, 'comment', 1);
}

/**
 * Implements hook_comment_delete().
 *
 * Decrease users comments number count, when user deletes a comment at group.
 */
function c4m_og_comment_delete($comment) {
  if ($comment->status == NODE_NOT_PUBLISHED) {
    // Do not handle unpublished comments.
    return;
  }

  $node = node_load($comment->nid);
  $group_content_types = array_keys(c4m_og_get_all_group_content_bundles('node'));
  if (!in_array($node->type, $group_content_types)) {
    // Comment is not on group content.
    return;
  }

  c4m_og_alter_membership_totals($comment, 'comment', -1);
}

/**
 * Implements hook_entity_update().
 *
 * When user publishes node/comment, increase membership totals field.
 * When user unpublishes node/comment, decrease membership totals field.
 */
function c4m_og_entity_update($entity, $type) {
  if (!in_array($type, ['node', 'comment'])) {
    // We process only nodes and comments.
    return;
  }

  if ($entity->status == $entity->original->status) {
    // Entity status did not change.
    return;
  }

  $step = ($entity->status === NODE_PUBLISHED) ? 1 : -1;
  c4m_og_alter_membership_totals($entity, $type, $step);
}

/**
 * Increase/decrease value of membership posts/comments count field.
 *
 * @param object $entity
 *   Group node ID.
 * @param string $entity_type
 *   Either 'node', or 'comment'.
 * @param int $step
 *   Increase/decrease step.
 */
function c4m_og_alter_membership_totals($entity, $entity_type, $step) {
  if ($entity_type == 'comment') {
    $node = node_load($entity->nid);
    $field = 'c4m_og_total_comments';
  }
  elseif ($entity_type == 'node') {
    $node = $entity;
    $field = 'c4m_og_total_posts';
  }
  else {
    // Invalid entity type.
    return;
  }

  $user_id = $entity->uid;

  $group = c4m_og_get_group_of_content($node);
  if (!$group) {
    // Failed to resolve the group.
    return;
  }

  $membership = og_get_membership('node', $group->nid, 'user', $user_id);
  if (!$membership) {
    // User is not group member.
    return;
  }

  $wrapper = entity_metadata_wrapper('og_membership', $membership);
  $current_totals = $wrapper->{$field}->value();
  $new_totals = empty($current_totals) ? $step : $current_totals + $step;

  if ($new_totals < 0) {
    // Negative totals are illegal.
    return;
  }

  $wrapper->{$field}->set($new_totals);
  $wrapper->save();
}

/**
 * Updates total number of posts and comments, for all members at all groups.
 */
function c4m_og_update_groups_contributions() {
  $query = db_select('og_membership', 'ogm')
    ->fields('ogm', ['id'])
    ->condition('entity_type', 'user');
  $ogmids = $query->execute()->fetchCol();

  foreach (og_membership_load_multiple($ogmids) as $membership) {
    $wrapper = entity_metadata_wrapper('og_membership', $membership);

    $current_total_posts = $wrapper->c4m_og_total_posts->value();
    $current_total_comments = $wrapper->c4m_og_total_comments->value();
    $total_posts = c4m_user_og_count_nodes_in_group($membership->etid, $membership->gid);
    $total_comments = c4m_user_og_count_comments_in_group($membership->etid, $membership->gid);

    if ($total_posts == $current_total_posts && $total_comments == $current_total_comments) {
      continue;
    }

    $wrapper->c4m_og_total_posts->set($total_posts);
    $wrapper->c4m_og_total_comments->set($total_comments);
    $wrapper->save();
  }
}

/**
 * Retrieves value of total posts/comments from membership object.
 *
 * @param int $gid
 *   Group ID.
 * @param int $uid
 *   User ID.
 * @param string $entity_type
 *   Either 'node', or 'comment'.
 *
 * @return bool|int
 *   Total posts/comments, FALSE on error.
 */
function c4m_og_get_membership_totals($gid, $uid, $entity_type) {
  if ($entity_type == 'comment') {
    $field = 'c4m_og_total_comments';
  }
  elseif ($entity_type == 'node') {
    $field = 'c4m_og_total_posts';
  }
  else {
    // Invalid entity type.
    return FALSE;
  }

  $membership = og_get_membership('node', $gid, 'user', $uid);
  if (!$membership) {
    // Failed to resolve user's membership.
    return FALSE;
  }

  $wrapper = entity_metadata_wrapper('og_membership', $membership);
  $result = $wrapper->{$field}->value();

  return empty($result) ? 0 : $result;
}

/**
 * Implements hook_entity_delete().
 *
 * Delete related vocabularies.
 */
function c4m_og_entity_delete($entity, $entity_type) {
  if ($entity_type != 'node') {
    return;
  }
  if (!in_array($entity->type, ['group', 'project'])) {
    return;
  }
  $categories = c4m_og_vocab_load_group_vocabulary($entity, 'c4m_vocab_category');
  $tags = c4m_og_vocab_load_group_vocabulary($entity, 'c4m_vocab_tag');
  if (!empty($categories) && !empty($categories->vid)) {
    taxonomy_vocabulary_delete($categories->vid);
  }
  if (!empty($tags) && !empty($tags->vid)) {
    taxonomy_vocabulary_delete($tags->vid);
  }
}

/**
 * Returns content type labels.
 *
 * @param array $machine_names
 *   Content type machine names.
 *
 * @return array
 *   Returns array of content type labels.
 */
function c4m_og_get_content_type_labels(array $machine_names) {
  $query = db_select('node_type', 'nt')
    ->fields('nt', ['type', 'name'])
    ->condition('type', $machine_names, 'IN');
  $results = $query->execute()->fetchAll();
  $content_types = [];
  foreach ($results as $result) {
    $content_types[$result->type] = $result->name;
  }
  return $content_types;
}

/**
 * Form builder.
 *
 * Merge group content.
 */
function c4m_og_merge_groups_form($form, $form_state, $group) {
  $node = menu_get_object();
  if (!og_is_group('node', $node)) {
    drupal_goto('<front>');
  }
  $content_types = c4m_og_feature_enabled_content_types();
  if (!empty($content_types)) {
    $options = c4m_og_get_content_type_labels($content_types);
    $form['content_types'] = [
      '#title' => t('Select the different content types to merge to the target @group_type. Note that all other  (unselected) content will be deleted permanently.', ['@group_type' => $node->type]),
      '#type' => 'checkboxes',
      '#options' => $options,
      '#default_value' => $content_types,
    ];
  }

  $form['users'] = [
    '#type' => 'checkbox',
    '#title' => t('Merge users'),
    '#default_value' => 1,
  ];

  $form['target_group'] = [
    '#type' => 'textfield',
    '#title' => t('Merge to'),
    '#after_build' => ['_c4m_og_merge_groups_form_target_group_after_build'],
    '#required' => TRUE,
    '#entityreference' => [
      'target_type' => 'node',
      'handler' => 'c4m_selection',
      'type' => 'single',
      'handler_settings' => [
        'target_bundles' => ['group' => $node->type],
        'skip_status_check' => TRUE,
        'sort' => [
          'direction' => 'ASC',
          'property' => 'title',
          'type' => 'property',
        ],
      ],
    ],
  ];

  $form['#validate'][] = '_c4m_og_merge_groups_validation';

  $form['merge'] = [
    '#type' => 'submit',
    '#value' => 'Merge',
  ];

  return $form;
}

/**
 * After build callback for target_group in c4m_og_merge_groups_form.
 *
 * Remove the validator added by entity reference module.
 *
 * @param array $element
 *   The FORM API element.
 * @param array $form_state
 *   Form state.
 *
 * @return array
 *   Form element.
 */
function _c4m_og_merge_groups_form_target_group_after_build(array &$element, array $form_state) {
  $element['#element_validate'] = ['_c4m_og_merge_groups_form_target_group_validate'];
  return $element;
}

/**
 * Validate callback for target_group in c4m_og_merge_groups_form.
 *
 * @param array $element
 *   The form element.
 * @param array $form_state
 *   The form state array.
 * @param array $form
 *   The form array.
 */
function _c4m_og_merge_groups_form_target_group_validate(array $element, array &$form_state, array $form) {
  // Field is required so no need to extra validation.
  $target_group = $form_state['values']['target_group'];
  if (!$target_group) {
    return;
  }

  // Take "label (entity id)', match the id from parenthesis.
  if (preg_match("/.+\((\d+)\)/", $target_group, $matches)) {
    $group_id = $matches[1];
    $group = node_load($group_id);
  }
  else {
    $group = node_load_multiple(NULL, [
      'title' => $target_group,
      'type' => 'group',
    ]);
    if ($group) {
      $group = array_shift($group);
    }
  }

  if ($group) {
    form_set_value($element, $group->nid, $form_state);
  }
  else {
    form_set_error('target_group', t("Please select a valid target group."));
  }
}

/**
 * Validates group merge form.
 */
function _c4m_og_merge_groups_validation($form, &$form_state) {
  $current_group = og_context();
  if ($form_state['values']['target_group'] == $current_group['gid']) {
    $current_group = node_load($current_group['gid']);
    form_set_error('target_group', t("Target @group_type can't be the same with the source @group_type.", ['@group_type' => $current_group->type]));
  }
}

/**
 * Submit action for group merge form.
 */
function c4m_og_merge_groups_form_submit($form, &$form_state) {
  $values = $form_state['values'];
  $group = og_context();

  // Add merge users operation to batch.
  $operations = [];

  if (!empty($values['users'])) {
    $operations[] = [
      '_c4m_og_merge_users_batch',
      [$group['gid'], $values['target_group']],
    ];
  }

  if (!empty($values['content_types'])) {
    // Add merge wiki pages operation to batch.
    if (!empty($values['content_types']['wiki_page'])) {
      $operations[] = [
        '_c4m_og_merge_wiki_pages_batch',
        [
          $group['gid'],
          $values['target_group'],
        ],
      ];
    }

    // Add merge content types operation to batch.
    $operations[] = [
      '_c4m_og_merge_content_batch',
      [
        $group['gid'],
        $values['target_group'],
        $values['content_types'],
      ],
    ];
  }

  // Add merge taxonomies operation to batch.
  $operations[] = [
    '_c4m_og_merge_taxonomies_batch',
    [
      $group['gid'],
      $values['target_group'],
      'c4m_vocab_category',
    ],
  ];
  $operations[] = [
    '_c4m_og_merge_taxonomies_batch',
    [
      $group['gid'],
      $values['target_group'],
      'c4m_vocab_tag',
    ],
  ];

  // Add the delete group operations to batch.
  $operations[] = [
    '_c4m_og_merge_group_delete_batch',
    [
      $group['gid'],
      $values['target_group'],
    ],
  ];

  $_SESSION['http_request_count'] = 0;
  $batch = [
    'title' => t('Content is being merged'),
    'operations' => $operations,
    'finished' => '_c4m_og_merge_finished',
  ];
  batch_set($batch);
}

/**
 * Merge users to target group.
 */
function _c4m_og_merge_users_batch($gid, $target_gid, &$context) {
  if (empty($gid) || empty($target_gid)) {
    return;
  }

  if (!isset($context['sandbox']['results'])) {
    // Get users from the source group which are not members of the target
    // group.
    $users_query = db_select('og_membership', 'ogm')
      ->fields('ogm', ['etid'])
      ->condition('entity_type', 'user')
      ->condition('gid', $gid)
      ->condition('state', OG_STATE_ACTIVE);

    $context['sandbox']['results'] = $users_query->execute()->fetchCol();
    $context['sandbox']['count'] = count($context['sandbox']['results']);
  }

  $user_ids = array_splice($context['sandbox']['results'], 0, C4M_OG_BATCH_MERGE_LIMIT);
  $users = user_load_multiple($user_ids);
  if (!empty($users)) {
    foreach ($users as $user) {
      og_group('node', $target_gid, ['entity' => $user]);
    }
  }

  // Check how many items we still have in the results.
  if ($count = count($context['sandbox']['results'])) {
    // Not finished.
    $context['finished'] = ($context['sandbox']['count'] - $count) / $context['sandbox']['count'];
  }
  else {
    // Finished.
    $context['results']['target_gid'] = $target_gid;
  }
}

/**
 * Merge wiki pages to target group.
 */
function _c4m_og_merge_wiki_pages_batch($gid, $target_gid, &$context) {
  if (empty($gid) || empty($target_gid)) {
    return;
  }

  if (!isset($context['sandbox']['results'])) {
    $content_query = db_select('og_membership', 'ogm');
    $content_query->leftJoin('node', 'n', 'n.nid = ogm.etid');
    $content_query->fields('ogm', ['etid']);
    $content_query->condition('ogm.entity_type', 'node')
      ->condition('ogm.gid', $gid)
      ->condition('ogm.state', 1)
      ->condition('n.type', 'wiki_page');

    $context['sandbox']['results'] = $content_query->execute()->fetchCol();
    $context['sandbox']['count'] = count($context['sandbox']['results']);
  }

  $n_ids = array_splice($context['sandbox']['results'], 0, C4M_OG_BATCH_MERGE_LIMIT);
  if (!empty($n_ids)) {
    $nodes = node_load_multiple($n_ids);
    if (!empty($nodes)) {
      $target_group = node_load($target_gid);
      foreach ($nodes as $node) {
        if (empty($target_group->book['bid']) || empty($target_group->book['mlid'])) {
          $node->book['bid'] = 'new';
          $node->book['plid'] = 0;
        }
        else {
          // Move the wiki page to the book of the target group.
          // The book merge will be completed after the content batch is done.
          $node->book['bid'] = $target_group->book['bid'];
          $node->book['plid'] = $target_group->book['mlid'];
        }
        book_node_update($node);
      }
    }
  }

  // Check how many items we still have in the results.
  if ($count = count($context['sandbox']['results'])) {
    // Not finished.
    $context['finished'] = ($context['sandbox']['count'] - $count) / $context['sandbox']['count'];
  }
  else {
    // Finished.
    $context['results']['target_gid'] = $target_gid;
  }
}

/**
 * Merge content from selected content types to target group.
 */
function _c4m_og_merge_content_batch($gid, $target_gid, $content_types, &$context) {
  if (empty($gid) || empty($content_types) || empty($target_gid)) {
    return;
  }

  if (!isset($context['sandbox']['results'])) {
    $content_query = db_select('og_membership', 'ogm');
    $content_query->leftJoin('node', 'n', 'n.nid = ogm.etid');
    $content_query->fields('ogm', ['etid']);
    $content_query->condition('ogm.entity_type', 'node')
      ->condition('ogm.gid', $gid)
      ->condition('ogm.state', 1)
      ->condition('n.type', $content_types, 'IN');

    $context['sandbox']['results'] = $content_query->execute()->fetchCol();
    $context['sandbox']['count'] = count($context['sandbox']['results']);
  }

  $n_ids = array_splice($context['sandbox']['results'], 0, C4M_OG_BATCH_MERGE_LIMIT);
  if (!empty($n_ids)) {
    if (empty($content_types['document'])) {
      $doc_agenda_query = db_select('field_data_c4m_document_agenda', 'da')
        ->fields('da', ['c4m_document_agenda_target_id'])
        ->condition('entity_id', $n_ids, 'IN');
      $doc_agenda_ids = $doc_agenda_query->execute()->fetchCol();
      if (!empty($doc_agenda_ids)) {
        $n_ids = array_merge($n_ids, $doc_agenda_ids);
      }
      $doc_presentation_query = db_select('field_data_c4m_document_presentation', 'dp')
        ->fields('dp', ['c4m_document_presentation_target_id'])
        ->condition('entity_id', $n_ids, 'IN');
      $doc_presentation_ids = $doc_presentation_query->execute()->fetchCol();
      if (!empty($doc_presentation_ids)) {
        $n_ids = array_merge($n_ids, $doc_presentation_ids);
      }
      $related_doc_query = db_select('field_data_c4m_related_document', 'rd')
        ->fields('rd', ['c4m_related_document_target_id'])
        ->condition('entity_id', $n_ids, 'IN');
      $doc_ids = $related_doc_query->execute()->fetchCol();
      if (!empty($doc_ids)) {
        $n_ids = array_merge($n_ids, $doc_ids);
      }
    }
    $nodes = node_load_multiple($n_ids);
    if (!empty($nodes)) {
      foreach ($nodes as $node) {
        $node_wrapper = entity_metadata_wrapper('node', $node);
        $node_wrapper->og_group_ref->set($target_gid);
        $node_wrapper->save();
      }
    }
  }

  // Check how many items we still have in the results.
  if ($count = count($context['sandbox']['results'])) {
    // Not finished.
    $context['finished'] = ($context['sandbox']['count'] - $count) / $context['sandbox']['count'];
  }
  else {
    // Finished.
    $context['results']['target_gid'] = $target_gid;
  }
}

/**
 * Merges groups' taxonomy terms by vocabulary.
 *
 * @param object $gid
 *   Merged group.
 * @param object $target_gid
 *   Target group.
 * @param string $vocabulary_name
 *   Vocabulary name.
 */
function _c4m_og_merge_taxonomies_batch($gid, $target_gid, $vocabulary_name, &$context) {
  if (empty($gid) || empty($target_gid)) {
    return;
  }

  if (!isset($context['sandbox']['results'])) {
    $context['sandbox']['group'] = node_load($gid);
    $context['sandbox']['target_group'] = node_load($target_gid);

    $context['sandbox']['vocabulary'] = c4m_og_vocab_load_group_vocabulary($context['sandbox']['group'], $vocabulary_name);
    $context['sandbox']['target_vocabulary'] = c4m_og_vocab_load_group_vocabulary($context['sandbox']['target_group'], $vocabulary_name);
    $context['sandbox']['results'] = taxonomy_get_tree($context['sandbox']['vocabulary']->vid);
    $context['sandbox']['count'] = count($context['sandbox']['results']);
  }

  $terms = array_splice($context['sandbox']['results'], 0, C4M_OG_BATCH_MERGE_LIMIT);
  foreach ($terms as $term) {
    $term->vid = $context['sandbox']['target_vocabulary']->vid;
    taxonomy_term_save($term);
  }

  // Check how many items we still have in the results.
  if ($count = count($context['sandbox']['results'])) {
    // Not finished.
    $context['finished'] = ($context['sandbox']['count'] - $count) / $context['sandbox']['count'];
  }
  else {
    // Finished.
    taxonomy_vocabulary_delete($context['sandbox']['vocabulary']->vid);
    $context['results']['target_gid'] = $target_gid;
  }
}

/**
 * Delete merged group.
 */
function _c4m_og_merge_group_delete_batch($gid, $target_gid, &$context) {
  if (empty($gid)) {
    return;
  }
  $query = db_select('og_membership', 'ogm');
  $query->leftJoin('node', 'n', 'n.nid = ogm.etid');
  $query->fields('ogm', ['etid']);
  $query->condition('ogm.entity_type', 'node')->condition('ogm.gid', $gid);

  $n_ids = $query->execute()->fetchCol();
  if (!empty($n_ids)) {
    node_delete_multiple($n_ids);
  }
  module_invoke_all('c4m_group_merge', $gid, $target_gid);
  node_delete($gid);
}

/**
 * After group merge is completed.
 */
function _c4m_og_merge_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('Content was successfully merged.'));
    if (!empty($results['target_gid'])) {
      drupal_goto('node/' . $results['target_gid']);
    }
  }
  else {
    drupal_set_message(t('Finished with errors.'));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function c4m_og_form_node_delete_confirm_alter(&$form, &$form_state, $form_id) {
  if (empty($form['#node'])) {
    return;
  }
  $node = $form['#node'];

  if (!user_access('merge group content')) {
    return;
  }
  if (!in_array($node->type, ['group', 'project'])) {
    return;
  }

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => FALSE],
  ];
  $merge_url = url('node/' . $node->nid . '/merge', $options);

  $form['description']['#markup'] = t('Please note that deleting this 
  @type will also delete all content and memberships permanently. 
  <a href="@url">Click here</a> if you\'d like to merge this content to another 
  @type instead.', ['@type' => $node->type, '@url' => $merge_url]);
}

/**
 * Implements hook_permission().
 */
function c4m_og_permission() {
  $perms['merge group content'] = [
    'title' => t('Merge group content'),
    'description' => t('Allows the user to merge a group into another.'),
  ];

  return $perms;
}

/**
 * Implements hook_query_TAG_alter().
 */
function c4m_og_query_c4m_active_group_member_alter(QueryAlterableInterface $query) {
  $query->join('users', 'u', 'etid = u.uid AND u.status = ' . C4M_USER_STATUS_ACTIVE);
}
