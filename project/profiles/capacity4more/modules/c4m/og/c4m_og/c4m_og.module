<?php

/**
 * @file
 * General Organic Groups functionality.
 */

include_once 'c4m_og.features.inc';
include_once 'c4m_og.access.inc';

/**
 * The access realm of C4M group member.
 */
define('C4M_OG_ACCESS_REALM', 'c4m_og_access');

/**
 * The values of the groups access level as defined on its field base.
 */
define('C4M_OG_MODERATED_GROUP', 0);
define('C4M_OG_OPEN_GROUP', 1);
define('C4M_OG_PRIVATE_GROUP', 2);

/**
 * Helper to get the current active group (based on og_context()).
 *
 * @return object|false
 *   The group entity, or FALSE if no context was found.
 */
function c4m_og_current_group() {
  $context = og_context();
  if (!$context) {
    return FALSE;
  }

  $group = node_load($context['gid']);
  if (!$group) {
    return FALSE;
  }

  return $group;
}

/**
 * Helper to get the current active group id (based on og_context()).
 *
 * @return null|int
 *   The group id, or NULL if no context was found.
 */
function c4m_og_current_group_id() {
  $context = og_context();
  if (!$context) {
    return NULL;
  }

  return $context['gid'];
}

/**
 * Helper to get the current value of the group membership request.
 *
 * @param object $group
 *   The group object.
 *
 * @return mixed|null
 *   Either 'open' or 'moderated' if it is a group type, otherwise NULL.
 */
function c4m_og_get_group_membership_request($group) {
  if (!og_context('node', $group)) {
    return NULL;
  }

  if ($group->type != 'group') {
    return NULL;
  }

  $wrapper = entity_metadata_wrapper('node', $group);
  $options = array(
    C4M_OG_MODERATED_GROUP => 'moderated',
    C4M_OG_OPEN_GROUP => 'open',
  );

  return $options[$wrapper->field_membership_open_request->value()];
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function c4m_og_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return 'plugins/' . $plugin;
  }
  elseif ($module == 'entityreference' && !empty($plugin)) {
    return "plugins/entityreference/$plugin";
  }
  elseif ($module == 'pluggable_node_access') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Helper function to get the human readable name of a group type.
 *
 * @param object $node
 *    The node object.
 *
 * @internal param object $group
 *
 * @return string
 *    Human readable name of group type.
 */
function c4m_og_get_group_type_name($node = NULL) {
  if (!$node) {
    $node = c4m_og_current_group();
  }
  if (!$node || !og_is_group_type('node', $node->type)) {
    return NULL;
  }

  return strtolower(node_type_get_name($node));
}

/**
 * Implements hook_form_alter().
 */
function c4m_og_form_alter(&$form, $form_state) {
  if (empty($form['#node_edit_form'])
    || !og_is_group_type(
      'node',
      $form['#node']->type
    )
  ) {
    return;
  }
  $form['og_purl']['purl']['value']['#title'] = t('Group path');
  $form['og_purl']['purl']['value']['#type'] = 'machine_name';
  $form['og_purl']['purl']['value']['#machine_name'] = array(
    'source' => array('title'),
    'label' => t('Group path'),
    'exists' => 'c4m_og_purl_exists',
    'replace' => '-',
    'replace_pattern' => '[^a-z0-9_-]+',
  );
}

/**
 * Implements hook_menu().
 */
function c4m_og_menu() {
  $items['group/%/%/admin/owner'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('c4m_og_replace_owner_build_form', 1, 2),
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => array(1, 2),
    'title' => 'Replace Owner',
  );

  $items['project/%/%/admin/owner'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('c4m_og_replace_owner_build_form', 1, 2),
    'access callback' => 'c4m_og_user_is_owner',
    'access arguments' => array(1, 2),
    'title' => 'Replace Owner',
  );
  // Auto-completes active group member's user names.
  $items['edit-author/autocomplete/%node'] = array(
    'page callback' => 'c4m_og_edit_author_autocomplete',
    'access callback' => '_c4m_features_og_members_is_power_user',
    'access arguments' => array(2),
    'title' => 'Replace Author',
  );

  // Menu item for approve membership request url.
  $items['group/%/%/admin/membership-approve/%user/%og_membership/%/%'] = array(
    'page callback' => 'c4m_og_control_membership',
    'page arguments' => array('approve', 2, 5, 6, 7, 8),
    'access callback' => 'c4m_og_control_membership_access',
    'access arguments' => array(1, 2),
  );

  // Menu item for reject membership request url.
  $items['group/%/%/admin/membership-reject/%user/%og_membership/%/%'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('c4m_og_reject_membership_request', 2, 5, 6, 7, 8),
    'access callback' => 'c4m_og_control_membership_access',
    'access arguments' => array(1, 2),
  );

  return $items;
}

/**
 * Function initializes form with input values, and returns confirm form.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 * @param int $gid
 *   Group ID.
 * @param object $account
 *   Administrator user that performs the action.
 * @param object $membership
 *   OG membership on which action is performed.
 * @param int $timestamp
 *   Timestamp of the moment action was requested.
 * @param string $hashed_pass
 *   Validation for executing user.
 *
 * @return object
 *   Confirm reject form.
 */
function c4m_og_reject_membership_request($form, &$form_state, $gid, $account, $membership, $timestamp = 0, $hashed_pass = '') {
  $form['reject_membership_request_message'] = array(
    '#type' => 'textarea',
  );

  // Add group membership form.
  $form_state['membership'] = $membership;
  field_attach_form('membership', $membership, $form, $form_state);
  $form_state['account'] = $account;
  field_attach_form('account', $account, $form, $form_state);

  $form['gid'] = array(
    '#type' => 'value',
    '#value' => $gid,
  );

  $form['timestamp'] = array(
    '#type' => 'value',
    '#value' => $timestamp,
  );

  $form['hashed_pass'] = array(
    '#type' => 'value',
    '#value' => $hashed_pass,
  );

  return confirm_form($form, t('Please enter reject reason:'), 'group/node/' . $gid . '/admin/people', '', t('Reject'), t('Cancel'));
}

/**
 * Submits reject membership request form.
 *
 * Gets inputs from form, and activates c4m_og_control_membership() function
 * with action = 'reject'.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_reject_membership_request_submit($form, &$form_state) {
  $membership = $form_state['membership'];
  $account = $form_state['account'];
  $gid = $form_state['values']['gid'];
  $timestamp = $form_state['values']['timestamp'];
  $hashed_pass = $form_state['values']['hashed_pass'];

  c4m_og_control_membership('reject', $gid, $account, $membership, $timestamp, $hashed_pass);
}

/**
 * Function builds and returns a link for membership request control.
 *
 * Includes a token for auto login.
 *
 * @param object $account
 *   Account which performs the action.
 * @param object $membership
 *   Membership for which action is performed.
 * @param string $action
 *   Approve / Reject.
 *
 * @return string
 *   A link for membership request control.
 */
function c4m_og_autologin_control_membership_link($account, $membership, $action) {
  $timestamp = REQUEST_TIME;
  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  $path = 'group/node/' . $membership->gid . '/admin/membership-' . $action . '/' . $account->uid . '/'
    . $membership->id . '/' . $timestamp . '/' . user_pass_rehash($account->pass, $timestamp, $account->login, $account->uid);

  return url($path, $options);
}

/**
 * Forwards the page to group's People page.
 *
 * @param object $form
 *   Form array to populate.
 * @param object $form_state
 *   Form state array.
 */
function c4m_og_route_to_group_people($form, &$form_state) {
  $gid = $form_state['values']['gid'];

  drupal_goto('group/node/' . $gid . '/admin/people');
}

/**
 * Function approves / rejects membership request, submitted by user.
 *
 * Verifies auto login token, and if valid, logs in the administrator and
 * performs required state change to membership request. If not valid, forwards
 * to login page.
 *
 * @param string $action
 *   Approve / Reject.
 * @param int $gid
 *   Group ID.
 * @param object $account
 *   Administrator user that performs the action.
 * @param object $membership
 *   OG membership on which action is performed.
 * @param int $timestamp
 *   Timestamp of the moment action was requested.
 * @param string $hashed_pass
 *   Validation for executing user.
 */
function c4m_og_control_membership($action, $gid, $account, $membership, $timestamp = 0, $hashed_pass = '') {
  global $user;
  // Time out in seconds, until auto login token expires.
  // 24 hours = 86400 seconds.
  $timeout = variable_get('autologin_timeout', 86400);
  $current = REQUEST_TIME;

  // If not logged in, or logged in as different user.
  if (user_is_anonymous() || $account->uid != $user->uid) {
    $timestamp_valid = $timestamp <= $current && $timestamp >= $account->login;
    $timeout_occurred = $current - $timestamp > $timeout;
    $rehashed_pass = user_pass_rehash($account->pass, $timestamp, $account->login, $account->uid);

    // Validate expiration and hashed password/login.
    if ($timestamp_valid && !$timeout_occurred && $account->uid && $hashed_pass == $rehashed_pass) {
      // If link data validated, perform automatic login.
      $user = $account;
      drupal_session_regenerate();
    }
    else {
      // If not valid, forward to login page, with forwarding to membership
      // edit page, after successful login.
      drupal_set_message('Auto login token expired', 'warning');
      $query = array('destination' => 'group/node/' . $gid . '/admin/people/edit-membership/' . $membership->id);
      drupal_goto('user/login', array('query' => $query));
    }
  }

  // Approve/Reject membership request.
  if ($membership->state == OG_STATE_PENDING) {
    $membership->state = $action == 'approve' ? OG_STATE_ACTIVE : OG_STATE_BLOCKED;
    og_membership_save($membership);
    $message = $action == 'approve' ? t('Membership approved') : t('Membership rejected');
    drupal_set_message($message);
  }
  else {
    $message = '';
    if ($membership->state == OG_STATE_ACTIVE) {
      $message = t('This request was already approved');
    }
    elseif ($membership->state == OG_STATE_BLOCKED) {
      $message = t('This request was already rejected');
    }

    drupal_set_message($message, 'warning');
  }

  if ($action == 'approve') {
    // For 'reject' route will be performed by form['#submit'].
    drupal_goto('group/node/' . $gid . '/admin/people');
  }
}

/**
 * Menu access; Check if entity is a group.
 */
function c4m_og_control_membership_access($group_type, $gid) {
  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Extract the group's bundle.
  list(, , $bundle) = entity_extract_ids($group_type, $group);
  // Verify 'node' bundle has roles.
  if (!og_roles($group_type, $bundle, $gid)) {
    return FALSE;
  }

  $entity_info = entity_get_info($group_type);
  if (!$group_type || !$entity_info) {
    // Not a valid entity type.
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements hook_og_ui_get_group_admin_alter().
 *
 * Adding a link to the replace owner page.
 */
function c4m_og_og_ui_get_group_admin_alter(&$data, $context) {
  if (!c4m_og_user_is_owner($context['entity_type'], $context['etid'])) {
    return;
  }

  $data['replace_owner'] = array(
    'title' => t('Replace Owner'),
    'description' => t('Replacing the owner of the group or project.'),
    'href' => 'admin/owner',
  );
}

/**
 * Form builder.
 *
 * Group owner replace form.
 */
function c4m_og_replace_owner_build_form($form, $form_state, $entity_type, $etid) {
  og_set_breadcrumb($entity_type, $etid, array(l(t('Group'), "$entity_type/$etid/group")));

  $admins = array();
  // Setting the list of the group admins.
  foreach (c4m_og_get_group_admins($etid) as $admin) {
    $admins[$admin->uid] = c4m_user_name($admin);
  }

  $form['new_owner'] = array(
    '#type' => 'select',
    '#required' => TRUE,
    '#options' => $admins,
    '#title' => t('Select new owner'),
    '#description' => t('Select the name of the member you wish to be the new owner.'),
  );

  $form['group'] = array(
    '#type' => 'value',
    '#value' => $etid,
  );

  $form['type'] = array(
    '#type' => 'value',
    '#value' => $entity_type,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Replace'),
  );

  return $form;
}

/**
 * Submit handler.
 *
 * Replacing the owner of a group.
 */
function c4m_og_replace_owner_build_form_submit($form, &$form_state) {
  $new_owner = array(
    'uid' => $form_state['values']['new_owner'],
    'name' => $form['new_owner']['#options'][$form_state['values']['new_owner']],
  );
  c4m_og_replace_owner($form_state['values']['type'], $form_state['values']['group'], $new_owner);

  // Redirect back to the group page.
  $form_state['redirect'] = $form_state['values']['type'] . '/' . $form_state['values']['group'] . '/group';
}

/**
 * Replacing the owner of a group.
 *
 * After replacing the owner of the group we grant "group administrator member"
 * role to the old owner and revoke this role from the new one.
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 * @param array $new_owner
 *   An array containing the ID and the name of the new owner.
 */
function c4m_og_replace_owner($group_type, $gid, $new_owner) {
  $group = entity_load_single($group_type, $gid);
  $old_owner_id = $group->uid;

  // Update the uid on the entity.
  $group->uid = $new_owner['uid'];

  // Save the entity.
  if (entity_save($group_type, $group)) {
    drupal_set_message(t('Failed to change manager to @user.', array('@user' => $new_owner['name'])), 'error');
  }
  else {
    drupal_set_message(t('Owner changed to @user.', array('@user' => $new_owner['name'])));

    $group_admin_role = c4m_og_user_role_load_by_name('administrator member', 'group');
    // Grant admin role to the old owner.
    og_role_grant($group_type, $gid, $old_owner_id, $group_admin_role->rid);
    // Revoke admin role from the new owner.
    og_role_revoke($group_type, $gid, $new_owner['uid'], $group_admin_role->rid);
  }
}

/**
 * Access callback for the "Replace owner" form.
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 *
 * @return bool
 *   TRUE if the current user has access to the group, FALSE otherwise.
 */
function c4m_og_user_is_owner($group_type, $gid) {
  global $user;

  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Make sure the current user is the group manager.
  return user_access('administer groups', $user) || $user->uid == $group->uid;
}

/**
 * Check if the current user is group member (or has the access of a member).
 *
 * @param string $group_type
 *   The type of the group.
 * @param int $gid
 *   The ID of the group.
 *
 * @return void|bool
 *   TRUE if the current user is group member, FALSE otherwise.
 */
function c4m_og_user_is_member($group_type = NULL, $gid = NULL) {
  if (empty($gid)) {
    $context = og_context('node');

    if (!isset($context['gid'])) {
      return FALSE;
    }

    $gid = $context['gid'];
    $group_type = $context['group_type'];
  }

  $group = entity_load_single($group_type, $gid);
  if (!$group || !og_is_group($group_type, $group)) {
    return FALSE;
  }

  // Make sure the current user is the group manager.
  return user_access('administer groups') || og_is_member('node', $gid);
}

/**
 * Check weather a user is banned (blocked) from a specific group.
 *
 * @param int $gid
 *   The ID of the group.
 * @param object $account
 *   (optional) The object of the user to check - Default is the current user.
 *
 * @return bool
 *   TRUE weather the user is banned from the group.
 */
function c4m_og_user_is_banned($gid, $account = NULL) {
  return og_is_member('node', $gid, 'user', $account, array(OG_STATE_BLOCKED));
}

/**
 * Fetches an og user role by its name and group bundle.
 *
 * @param string $role_name
 *   A string representing the role name.
 * @param string $group_bundle
 *   A string representing the group bundle.
 *
 * @return mixed
 *   A fully-loaded og role object if a role with the given name and group
 *   bundle exists, or FALSE otherwise.
 */
function c4m_og_user_role_load_by_name($role_name, $group_bundle) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache)) {
    $cache = db_select('og_role', 'r')
      ->fields('r')
      ->condition('name', $role_name)
      ->condition('group_bundle', $group_bundle)
      ->execute()
      ->fetchObject();
  }

  return $cache;
}

/**
 * Fetch all group admins ids.
 *
 * @param int $gid
 *   The ID of the group.
 * @param bool $verify_owner_added
 *   Verifies that group owner id is returned, even if group owner does not
 *   have 'administrator member' role.
 *
 * @return array
 *   An array of all group admins ids.
 */
function c4m_og_get_group_admins_ids($gid, $verify_owner_added = FALSE) {
  $group_admin_role = c4m_og_user_role_load_by_name('administrator member', 'group');
  $admins = c4m_og_get_users_by_roles($gid, array($group_admin_role->rid));
  foreach ($admins as &$admin) {
    $admin = $admin->uid;
  }

  if ($verify_owner_added) {
    $group = node_load($gid);
    if ($group && og_is_group('node', $group)) {
      if (!in_array($group->uid, $admins)) {
        $admins[] = $group->uid;
      }
    }
  }

  return $admins;
}

/**
 * Fetch all group admins.
 *
 * @param int $gid
 *   The ID of the group.
 * @param bool $verify_owner_added
 *   Verifies that group owner is returned, even if group owner does not
 *   have 'administrator member' role.
 *
 * @return array
 *   An array of all group admins.
 */
function c4m_og_get_group_admins($gid, $verify_owner_added = FALSE) {
  return user_load_multiple(c4m_og_get_group_admins_ids($gid, $verify_owner_added));
}

/**
 * Implements hook_module_implements_alter().
 */
function c4m_og_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter' && isset($implementations['c4m_og'])) {
    $c4m_og = $implementations['c4m_og'];
    unset($implementations['c4m_og']);
    $implementations['c4m_og'] = $c4m_og;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the Project creation form.
 */
function c4m_og_form_project_node_form_alter(&$form, &$form_state) {
  _c4m_og_alter_group_form($form, $form_state);
}

/**
 * Alters the add/edit form for group content types.
 *
 * @param array $form
 *   Form array.
 * @param array $form_state
 *   Form state array.
 * @param string $title
 *   (optional) Title used for page title.
 */
function _c4m_og_alter_group_form(&$form, &$form_state, $title = '') {
  // Form changes on creation.
  if (!$form['nid']['#value']) {
    // Change title.
    drupal_set_title('Request ' . $title ? $title : $form['#bundle']);

    // Change submit button on creation.
    $form['actions']['submit']['#value'] = t('Request');

    // Remove "Save as draft" button.
    $form['actions']['draft']['#access'] = FALSE;
  }
}

/**
 * Function to check if a path is a purl path.
 *
 * @param string $value
 *    Group path.
 *
 * @return bool
 *    TRUE or FALSE.
 */
function c4m_og_purl_exists($value) {
  return FALSE;
}

/**
 * Function to get roles per group bundle.
 *
 * @return array
 *    Array of roles per group bundle
 */
function c4m_og_get_group_bundles() {
  $roles = array();
  $result = db_select('og_role', 'ogr')
    ->fields('ogr', array('group_bundle', 'rid', 'name'))
    ->execute()
    ->fetchAll();
  foreach ($result as $row) {
    $roles[$row->group_bundle][$row->rid] = $row->name;
  }

  return $roles;
}

/**
 * Function to get OG permissions by OG role.
 *
 * @param int $rid
 *   The role ID.
 *
 * @return array
 *    Array of OG permissions
 */
function c4m_og_get_permissions_by_role($rid, $module = 'c4m_og') {
  $perms = array();
  $result = db_select('og_role_permission', 'ogrp')
    ->fields('ogrp', array('permission'))
    ->condition('rid', $rid)
    ->condition('module', $module)
    ->execute()
    ->fetchAll();
  foreach ($result as $row) {
    $perms[$row->permission] = $row->permission;
  }

  return $perms;
}

/**
 * Function to get OG roles by OG permission.
 *
 * @param string $permission
 *    The permission.
 * @param string $module
 *    The module name.
 *
 * @return array
 *    Array of role ids.
 */
function c4m_og_get_roles_by_permission($permission, $module = 'c4m_og') {
  $roles = array();
  $result = db_select('og_role_permission', 'ogrp')
    ->fields('ogrp', array('rid'))
    ->condition('permission', $permission)
    ->condition('module', $module)
    ->execute()
    ->fetchAll();
  foreach ($result as $row) {
    $roles[$row->rid] = $row->rid;
  }

  return $roles;
}

/**
 * Get all the users with certain roles in a group.
 *
 * @param int $gid
 *   The group unique ID.
 * @param array $rids
 *   Array with the role IDs to query.
 */
function c4m_og_get_users_by_roles($gid, $rids = array()) {
  $query = db_select('og_users_roles', 'og_users_roles');

  return $query->fields('og_users_roles', array('uid'))
    ->condition('gid', $gid)
    ->condition('rid', $rids, 'IN')
    ->execute()
    ->fetchAll();
}

/**
 * Implements hook_views_api().
 */
function c4m_og_views_api() {
  return array('api' => 3.0);
}

/**
 * Access callback for the c4m_og_access_plugin access plugin.
 *
 * @param string $feature
 *   Determine if the specified user has access to a given feature.
 * @param object $account
 *   If the $account argument is omitted, the current user is used.
 *
 * @return bool
 *    TRUE or FALSE whether access is granted or not.
 */
function c4m_og_access($feature = NULL, $account = NULL) {
  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);
    return FALSE;
  }

  // Check if the user has access to the group context.
  $og_context = og_context();
  if (!$og_context) {
    return FALSE;
  }

  // Check if the feature is enabled.
  if (empty($feature) || c4m_og_feature_enabled($feature)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_og_permission().
 *
 * Add group permissions.
 */
function c4m_og_og_permission() {
  return array(
    'view unpublished group content' => array(
      'title' => t('View unpublished group content'),
      'description' => t("Allow user to view unpublished content of a group."),
      'roles' => array(OG_AUTHENTICATED_ROLE),
      'default role' => array(OG_ANONYMOUS_ROLE, OG_ADMINISTRATOR_ROLE),
    ),
  );
}

/**
 * Function to filter all groups of a user by a certain permission.
 *
 * It returns only the gids of the groups for which the user has the permission.
 *
 * We do this by retrieving roles of the user for the groups
 * and then check per role if it has that permission.
 *
 * We assemble all the permissions this user has in a group and with those we
 * filter out the groups which do not contain the desired permission.
 *
 * @param string $uid
 *    User id needed to collect the user roles for this user.
 * @param string $perm
 *    The permission to check on.
 * @param array $gids
 *    The group ID's to fetch the permissions for.
 */
function c4m_og_user_has_permission_in($uid, $perm, array &$gids) {
  foreach ($gids as $membership_id => $gid) {
    $roles = og_get_user_roles('node', $gid, $uid);
    $rids = array_keys($roles);
    $perms_for_gid = array();
    foreach ($rids as $rid) {
      $perms_for_gid = array_merge(
        $perms_for_gid,
        c4m_og_get_permissions_by_role($rid)
      );
    }
    if (!in_array($perm, $perms_for_gid)) {
      unset($gids[$gid]);
    }
  }
}

/**
 * Implements hook_node_grants().
 */
function c4m_og_node_grants($account, $op) {
  switch ($op) {
    case 'view':
      // Only grant group members and users with the appropriate role within
      // the group the right to view unpublished nodes.
      if ($groups = og_get_entity_groups('user', $account)) {
        // We need to know if the user has the right role within these
        // groups, meaning a role with the right permission.
        foreach ($groups as $group_type => $gids) {
          $perm = 'view unpublished group content';
          c4m_og_user_has_permission_in($account->uid, $perm, $gids);
          foreach ($gids as $gid) {
            $realm = C4M_OG_ACCESS_REALM . ':' . $perm;
            $grants[$realm][] = $gid;
          }
        }
        return !empty($grants) ? $grants : array();
      }
      break;
  }
}

/**
 * Implements hook_node_access_records_alter().
 *
 * We could use hook_node_access_records for this because node module and
 * og_access module do not deliver grants for unpublished nodes so there is no
 * real need to alter grants.
 * But then we would have an implementation of hook_node_access_records and
 * possibly in the future one of hook_node_access_records_alter.
 *
 * It's clearer to have our node_access_records logic in one place.
 */
function c4m_og_node_access_records_alter(&$grants, $node) {
  // Allow group members with the right permission to view unpublished group
  // content nodes.
  if (og_is_group_content_type('node', $node->type)) {
    // Node is unpublished, so og_access will not deliver grants, nor will node
    // (module).
    // We allow a view grant within our realm
    // 'c4m_og_access:view unpublished group content' for the groups of
    // which this node is content.
    $perm = 'view unpublished group content';
    // Retrieve groups of this node.
    $entity_groups = og_get_entity_groups('node', $node);
    foreach ($entity_groups as $group_type => $values) {
      foreach ($values as $gid) {
        $list_gids[$group_type][] = $gid;
        $grants[] = array(
          'realm' => C4M_OG_ACCESS_REALM . ':' . $perm,
          'gid' => $gid,
          'grant_view' => 1,
          'grant_update' => 0,
          'grant_delete' => 0,
          'priority' => 0,
        );
      }
    }
  }
}

/**
 * Counts the number of members in a given group.
 *
 * @param object $group
 *    The group entity.
 * @param int $state
 *    The status of the membership, Defaults to active.
 *
 * @return int
 *    The count of members in the group.
 */
function c4m_og_get_members_count($group, $state = OG_STATE_ACTIVE) {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'og_membership')
    // This is the group ID.
    ->propertyCondition('gid', $group->nid)
    // Get only the active members.
    ->propertyCondition('state', $state)
    ->propertyCondition('entity_type', 'user')
    ->addTag('user_not_blocked')
    ->count()
    ->execute();

  return $result;
}

/**
 * Implements hook_query_TAG_alter().
 */
function c4m_og_query_user_not_blocked_alter(QueryAlterableInterface $query) {
  // Make sure to count only user who are not blocked.
  $query->innerjoin("users", "u", "u.uid = og_membership.etid AND u.status = '1'");
}

/**
 * Counts the number of posts in a given group.
 *
 * @param object $group
 *    The group entity.
 *
 * @return int
 *    The count of posts in the group.
 */
function c4m_og_get_posts_count($group) {
  $query = db_select('node', 'n');
  $query->join('og_membership', 'ogm', 'n.nid = ogm.etid');
  $query->fields('n', array('nid'))
    ->condition('n.status', 1)
    ->condition('ogm.gid', (int) $group->nid)
    ->condition('ogm.entity_type', 'node');

  return (int) $query->countQuery()->execute()->fetchField();
}

/**
 * Implements hook_entity_property_info_alter().
 */
function c4m_og_entity_property_info_alter(&$info) {
  $info['node']['properties']['c4m_og_group_type'] = array(
    'type' => 'text',
    'label' => t('Group type'),
    'sanitized' => TRUE,
    'getter callback' => '_c4m_og_group_type_getter_callback',
  );
}

/**
 * Getter callback for created_week_day property.
 *
 * @param object $item
 *    The group object.
 *
 * @return string
 *    Type of group access.
 */
function _c4m_og_group_type_getter_callback($item) {
  // Get group type information.
  $group_access = c4m_og_get_access_type($item);
  if (!empty($group_access['type'])) {
    return ucfirst($group_access['type']);
  }
}

/**
 * Get the group nid of the given entity.
 *
 * @param object $entity
 *   The entity we want the group id of.
 *
 * @return null|int
 *   The group ID if any.
 */
function c4m_og_get_gid_from_entity($entity) {
  // Check if entity has the "type" property.
  if (!property_exists($entity, 'type')) {
    return NULL;
  }

  if (og_is_group_type('node', $entity->type)) {
    return (int) $entity->nid;
  }

  if (og_is_group_content_type('node', $entity->type)
    && isset($entity->og_group_ref[LANGUAGE_NONE][0]['target_id'])
  ) {
    return (int) $entity->og_group_ref[LANGUAGE_NONE][0]['target_id'];
  }

  return NULL;
}

/**
 * Load all group features info from implemented c4m_og_feature hooks.
 *
 * @param string $feature
 *   Only return data for a given feature.
 *
 * @return array
 *   Configuration as collected trough the implemented
 *   hook_c4m_og_feature_info hooks.
 */
function c4m_og_feature_info($feature = NULL) {
  $cache_key = 'c4m_og:feature_info';
  $data = &drupal_static($cache_key);

  // Retrieve from Cache if not loaded before.
  if (!isset($data)) {
    if (($cache = cache_get($cache_key)) && !empty($cache->data)) {
      $data = $cache->data;
    }
    else {
      $hook = 'c4m_og_feature_info';
      $data = module_invoke_all($hook);
      uasort($data, 'drupal_sort_weight');
      cache_set($cache_key, $data);
    }
  }

  // Only return data for a given feature.
  if (isset($data[$feature])) {
    return $data[$feature];
  }

  // Return all data.
  return $data;
}

/**
 * Check if a given feature is enabled.
 *
 * @param string $feature
 *   The feature to check.
 *
 * @return bool
 *   True if the feature is enabled for the active group.
 */
function c4m_og_feature_enabled($feature) {
  // Check if the feature exists.
  $og_feature = c4m_og_feature_info($feature);
  if (!isset($og_feature['machine_name'])) {
    return FALSE;
  }

  // Check if the feature should be enabled for the current group.
  $group = og_context();
  if ($group_type = c4m_og_get_group_type($group)) {
    if (!in_array($group_type, $og_feature['group_types'])) {
      return FALSE;
    }
  }

  // Check if the feature is enabled.
  $settings = variable_get('c4m_og_features_group', array());
  if (isset($settings[$feature]) && $settings[$feature] === $feature) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Get a list of enabled features for the active group.
 *
 * @return array
 *   An array with the features that are enabled for the active group.
 */
function c4m_og_feature_enabled_features() {
  $features = variable_get('c4m_og_features_group');

  foreach ($features as $feature => $status) {
    if (!$status) {
      unset($features[$feature]);
    }
  }

  return array_keys($features);
}

/**
 * Get a list of disabled features for the active group.
 *
 * @return array
 *   An array with the features that are disabled for the active group.
 */
function c4m_og_feature_disabled_features() {
  $features = variable_get('c4m_og_features_group');

  foreach ($features as $feature => $status) {
    if ($status) {
      unset($features[$feature]);
    }
  }

  return array_keys($features);
}

/**
 * Get a list of enabled content types for the active group.
 *
 * @return array
 *   An array with the content types that are enabled for the active group.
 */
function c4m_og_feature_enabled_content_types() {
  $content_types = array();

  $feature_info = c4m_og_feature_info();
  $features = c4m_og_feature_enabled_features();

  foreach ($features as $feature) {
    $group_content_types = $feature_info[$feature]['content_types'];
    $content_types = array_merge($content_types, $group_content_types);
  }

  return $content_types;
}

/**
 * Check if a given content type is enabled within the current group context.
 *
 * @param string $type
 *   The node type.
 *
 * @return bool
 *   Enabled?
 */
function c4m_og_feature_is_content_type_enabled($type) {
  $enabled_types = c4m_og_feature_enabled_content_types();
  return in_array($type, $enabled_types);
}

/**
 * Get a list of disabled content types for the active group.
 *
 * @return array
 *   An array with the content types that are disabled for the active group.
 */
function c4m_og_feature_disabled_content_types() {
  $content_types = array();

  $feature_info = c4m_og_feature_info();
  $features = c4m_og_feature_disabled_features();

  foreach ($features as $feature) {
    $group_content_types = $feature_info[$feature]['content_types'];
    $content_types = array_merge($content_types, $group_content_types);
  }

  return $content_types;
}

/**
 * Install a given feature.
 *
 * @param string $feature
 *   The feature to install.
 * @param bool $enabled
 *   Optional, if the feature should be enabled by default (default = TRUE).
 */
function c4m_og_feature_install($feature, $enabled = TRUE) {
  $settings = variable_get('c4m_og_features_group');
  if ($enabled) {
    $settings[$feature] = $feature;
  }
  else {
    $settings[$feature] = 0;
  }
  variable_set('c4m_og_features_group', $settings);
}

/**
 * Uninstall a given feature.
 *
 * @param string $feature
 *   The feature to uninstall.
 */
function c4m_og_feature_uninstall($feature) {
  $settings = variable_get('c4m_og_features_group');
  unset($settings[$feature]);
  variable_set('c4m_og_features_group', $settings);
}

/**
 * Get the group IDs of all the group nodes.
 *
 * For specific node type a user is an
 * approved member of.
 *
 * @param string $bundle
 *    (optional) The group node type.
 * @param object $account
 *    (optional) The user object to fetch group memberships for. Defaults to the
 *   acting user.
 *
 * @return array $groups
 *    Returns array of group nodes IDs of specific node type.
 */
function c4m_og_get_user_group_ids_by_bundle($bundle = NULL, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  $groups = og_get_groups_by_user($account, 'node');
  if (!$groups || !$bundle) {
    return $groups;
  }

  // Apply bundle filter only for specific bundle type.
  $conditions = array();
  if ($bundle != 'showAll') {
    $conditions['type'] = $bundle;
  }

  $groups = node_load_multiple($groups, $conditions);

  $groups_ids = array();
  foreach ($groups as $group) {
    // Check whether the group has been published, or whether the user
    // is the group owner (applies only to 'My groups').
    if ($group->status == NODE_PUBLISHED  || ($group->name == $account->name && $bundle == 'group')) {
      $groups_ids[] = $group->nid;
    }
  }

  return $groups_ids;
}

/**
 * Implements hook_node_update().
 */
function c4m_og_node_update($node) {
  if (!og_is_group_type('node', $node->type)) {
    return;
  }

  _c4m_og_handle_pending_members_when_going_private($node);
  c4m_og_open_group_access_activate_pending_members($node);
}

/**
 * Delete all pending memberships from a group the go private.
 *
 * @param object $node
 *   The node object of the group.
 */
function _c4m_og_handle_pending_members_when_going_private($node) {
  $access = c4m_og_get_access_type($node);
  if ($access['type'] != 'private') {
    return;
  }

  // Delete all pending memberships of this group.
  $ids = c4m_og_get_all_group_memberships_by_state($node->nid, OG_STATE_PENDING);
  og_membership_delete_multiple($ids);
}

/**
 * Activate pending members when access level of a group is changed.
 *
 * When changing the access level from 'Moderated' to 'Open', all pending
 * members should become active group members.
 *
 * @param object $node
 *   The node object while being updated.
 *
 * @throws \Exception
 *   When the node object doesn't contain the 'original' property.
 */
function c4m_og_open_group_access_activate_pending_members($node) {
  if (empty($node->original)) {
    throw new Exception('Node object must contain the original property.');
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $original_wrapper = entity_metadata_wrapper('node', $node->original);

  if (isset($wrapper->field_membership_open_request) &&
    $wrapper->field_membership_open_request->value() != C4M_OG_OPEN_GROUP) {
    // Group is not "Open".
    return;
  }

  if (isset($original_wrapper->field_membership_open_request) &&
    $original_wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // Previous group setting was not "Moderated".
    return;
  }

  // Activate all pending members of this group.
  $ids = c4m_og_get_all_group_memberships_by_state($node->nid, OG_STATE_PENDING);
  foreach (og_membership_load_multiple($ids) as $membership) {
    $membership->state = OG_STATE_ACTIVE;
    $membership->save();
  }
}

/**
 * Get the group membership entity by user, group and state.
 *
 * @param int $gid
 *   The group ID.
 * @param int $state
 *   The user current state.
 *
 * @return array
 *   Array of members UIDs, or an empty array.
 */
function c4m_og_get_all_group_memberships_by_state($gid, $state) {
  $cache = &drupal_static(__FUNCTION__, array());

  $identifier = $gid . ':' . $state;

  if (isset($cache[$identifier])) {
    return $cache[$identifier];
  }

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('gid', $gid)
    ->propertyCondition('state', $state)
    ->propertyCondition('group_type', 'node')
    ->propertyCondition('entity_type', 'user')
    ->execute();

  $cache[$identifier] = !empty($result['og_membership']) ? array_keys($result['og_membership']) : array();

  return $cache[$identifier];
}

/**
 * Returns the amount of nodes in the group of the specified bundles.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 * @param array $bundles
 *   The bundles to query for.
 *
 * @return int
 *   The amount of nodes in the group.
 */
function c4m_og_group_node_metric($og_id, $bundles) {
  $arguments = array(
    'entity_type' => 'node',
    'bundles' => $bundles,
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  );

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Returns the amount of users in the group of the specified bundles.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 *
 * @return int
 *   The amount of users in the group.
 */
function c4m_og_group_user_metric($og_id) {
  $arguments = array(
    'entity_type' => 'user',
    'bundles' => array(),
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  );

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Returns the amount of comments in the group.
 *
 * @param int $og_id
 *   The Organic Group ID to gather the metrics for.
 *
 * @return int
 *   The amount of comments in the group.
 */
function c4m_og_group_comment_metric($og_id) {
  $arguments = array(
    'entity_type' => 'comment',
    'bundles' => array(),
    'state' => 1,
    'og_id' => $og_id,
    'topic' => NULL,
    'c4m_status' => NULL,
  );

  return c4m_helper_entity_get_number_of_entities($arguments);
}

/**
 * Implements hook_c4m_helper_entity_metrics_info().
 */
function c4m_og_c4m_helper_entity_metrics_info() {
  return array(
    'c4m_og_content_recommendations' => array(
      'type'     => 'content_recommendations',
      'context'  => 'group',
      'callback' => 'c4m_og_get_content_recommendations',
      'weight'   => 100,
    ),
    'c4m_user_group_memberships' => array(
      'type' => 'group_memberships',
      'context'  => 'user',
      'callback' => 'c4m_og_get_user_group_memberships_count',
    ),
    'c4m_user_group_pending_memberships' => array(
      'type' => 'group_pending_memberships',
      'context'  => 'user',
      'callback' => 'c4m_og_get_user_group_pending_memberships_count',
    ),
  );
}

/**
 * Returns the total amount of recommendations on content of a group.
 *
 * @param int $og_id
 *   The Organic group ID to limit the query for.
 *
 * @return int
 *   The total amount of recommendations on the group content.
 */
function c4m_og_get_content_recommendations($og_id = NULL) {
  if (!is_numeric($og_id)) {
    return 0;
  }

  $query = db_select('node', 'n');
  $query->join('og_membership', 'ogm', 'ogm.etid = n.nid');
  $query->join('flag_counts', 'fc', 'fc.entity_id = n.nid');
  $query->join('flag', 'f', 'f.fid = fc.fid');
  $query->condition('n.status', 1);
  $query->condition('ogm.gid', (int) $og_id);
  $query->condition('ogm.entity_type', 'node');
  $query->condition('fc.entity_type', 'node');
  $query->condition('f.name', 'c4m_og_content_recommend');
  $query->addExpression('SUM(fc.count)', 'recommendations');

  $count = $query->execute()->fetchField();
  return empty($count) ? 0 : $count;
}

/**
 * Helper function to get group type (project|group).
 *
 * @param array $group
 *   The group to get the type from.
 *
 * @return string
 *   Group type (project|group).
 */
function c4m_og_get_group_type($group) {
  if (!empty($group)) {
    if ($group_node = node_load($group['gid'])) {
      return $group_node->type;
    }
  }
  return FALSE;
}

/**
 * Returns the group memberships count for an user.
 *
 * @param int $uid
 *   User id.
 * @param int $state
 *   Node type.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_group_memberships_count($uid, $state = OG_STATE_ACTIVE) {
  $query = db_select('og_membership', 'm');
  $query->fields('m', array('id'));
  $query->condition('entity_type', 'user');
  $query->condition('etid', $uid);
  $query->condition('state', $state);

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns the group memberships count for an user.
 *
 * @param int $uid
 *   User id.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_group_pending_memberships_count($uid) {
  return c4m_og_get_user_group_memberships_count($uid, OG_STATE_PENDING);
}

/**
 * Returns the administered groups count for an user.
 *
 * @param int $uid
 *   User id.
 * @param string $node_type
 *   Node type.
 *
 * @return int
 *   Count.
 */
function c4m_og_get_user_administered_groups_count($uid, $node_type) {
  $query = db_select('og_users_roles', 'ur');
  $query->fields('ur');
  $query->join('og_role', 'r', "ur.rid = r.rid AND name = 'administrator member' AND ur.uid = $uid");
  $query->join('node', 'n', "ur.gid = n.nid AND ur.group_type = 'node' AND n.type = '$node_type'");

  $query = $query->execute();
  $amount = $query->rowCount();

  return $amount;
}

/**
 * Returns an array of OG content types that require notification.
 *
 * @return array
 *   Notification types.
 */
function c4m_og_get_group_content_notification_types() {
  return array('discussion', 'document', 'event', 'wiki_page');
}

/**
 * Compares the OG type (project|group) to input.
 *
 * @param string $type
 *   The group to get the type from.
 *
 * @return bool
 *   Whether current OG group type matches the input.
 */
function c4m_og_is_of_group_type($type) {
  $context = og_context();
  if (!$context) {
    return FALSE;
  }

  $og_group_type = c4m_og_get_group_type($context);
  if (!$og_group_type || $og_group_type != $type) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns the groups owned by an user.
 *
 * @param int $uid
 *   User id.
 * @param string|array $node_type
 *   Node type or types.
 *
 * @return array.
 *   Keyed array of Node IDs and titles.
 */
function c4m_og_get_user_owned_groups($uid, $node_type) {
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'title'));
  $query->condition('n.uid', $uid);
  $query->condition('n.type', $node_type);

  $results = $query->execute();
  $nids = $results->fetchAllKeyed();

  return $nids;
}

/**
 * Add the `Authoring information` tab to the group content editing forms.
 *
 * Allows group owner and administrators to change the author of content in the
 * group. Limits possible authors to group members or anonymous user.
 */
function c4m_og_add_content_author_options_to_power_users(&$form) {
  // Site administrator already has these options by default.
  $site_admin_role = user_role_load_by_name('administrator');
  if (user_has_role($site_admin_role->rid)) {
    return;
  }

  $gid = c4m_og_current_group_id();
  // Return early if there is no group context.
  if (!$gid) {
    return;
  }

  // Show authoring information tab to GAs and GO when editing group content.
  $form['author']['#access'] = _c4m_features_og_members_is_power_user();

  // Limit possible authors to members of the group only.
  $form['author']['name']['#autocomplete_path'] = 'edit-author/autocomplete/' . $gid;
  $form['#validate'][] = 'c4m_og_form_valid_author';
}

/**
 * Added validation of the author for the group content editing forms.
 */
function c4m_og_form_valid_author($form, &$form_state) {
  $user = user_load_by_name($form_state['values']['name']);
  $gid = c4m_og_current_group_id();
  // Can't validate author if there is no group context.
  if (!$gid) {
    form_set_error('name', 'There was an error validating the author for this group.');
  }

  if ($user && !og_is_member('node', $gid, 'user', $user)) {
    form_set_error('name', $form_state['values']['name'] . ' is not an active member of this group.');
  }
}

/**
 * Author autocomplete callback.
 *
 * Returns a JSON of all active members of an OG group where the username
 * contains the search string (for autocomplete author field).
 */
function c4m_og_edit_author_autocomplete($string = '') {
  // Return early if no search string was received.
  if (!trim($string)) {
    return;
  }

  $gid = c4m_og_current_group_id();
  // Return early if there is no group context.
  if (!$gid) {
    return;
  }

  $query = db_select('users', 'u');
  $query
    ->condition('u.status', C4M_USER_STATUS_ACTIVE, '=')
    ->condition('u.name', '%' . db_like($string) . '%', 'LIKE')
    ->fields('u', array('uid', 'name'))
    ->fields('ogm', array('state'))
    ->join('og_membership', 'ogm', "ogm.gid = :gid AND u.uid = ogm.etid AND ogm.entity_type = 'user'", array(':gid' => $gid));
  $result = $query->execute();

  foreach ($result as $member) {
    if ($member->state == OG_STATE_ACTIVE) {
      $user[$member->name] = $member->name;
    }
  }

  // Convert to object to prevent drupal bug, see http://drupal.org/node/175361
  drupal_json_output((object) $user);
}

/**
 * Convert a human readable title to a machine readable name.
 *
 * The function replaces anything other than letters, numbers and underscores
 * in the $title string with the $delimiter and converts capital to lowercase.
 *
 * @return string.
 *   The title in machine readable form.
 */
function c4m_og_human_to_machine_readable($title, $delimiter = '-') {
  return preg_replace('@[^a-z0-9_]+@', $delimiter, strtolower(trim($title)));
}
