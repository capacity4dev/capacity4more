<?php

/**
 * @file
 * Code for the Article content type feature.
 */

/**
 * Render a message to the user about the draft entity.
 *
 * @param string $type
 *   A bundle machine name.
 *
 * @return string
 *   The rendered message as an HTML element.
 */
function _c4m_content_get_draft_message_rendered($type) {
  $params = ['@type' => str_replace('_', ' ', $type)];

  $tag['element'] = [
    '#tag' => 'span',
    '#attributes' => [
      'class' => ['control-label'],
    ],
    '#value' => t("By pressing 'Save', you will save this @type as a draft - please press 'Publish' to create and publish this @type.", $params),
  ];

  $tag['element'] = [
    '#tag' => 'div',
    '#attributes' => [
      'class' => ['has-error'],
    ],
    '#value' => theme_html_tag($tag),
  ];

  return theme_html_tag($tag);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Hide Book tab for all content types.
 * Add a cancel button to all node forms.
 */
function c4m_content_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Checks if the form's content type is being used as a message,
  // to add a send notification option.
  $types_required_notification_checkbox = c4m_og_get_group_content_notification_types();

  // Since 'article' is not a content type that actually sends a notification
  // then we add it manually so the checkbox will appear on the form as
  // requested in CFM-1583.
  $types_required_notification_checkbox[] = 'article';

  if (in_array($form_state['node']->type, $types_required_notification_checkbox)) {

    $form['additional_settings']['#weight'] = 97;

    // Adding the message to the user about the draft entity.
    if (isset($form_state['node']->status) && $form_state['node']->status == NODE_NOT_PUBLISHED) {
      $form['draft-content-message'] = [
        '#markup' => _c4m_content_get_draft_message_rendered($form['type']['#value']),
        '#weight' => 99,
      ];
    }

    $form['send_notification'] = [
      '#type' => 'checkbox',
      '#title' => t('Send Notification'),
      // Default to true only on new content.
      '#default_value' => empty($form_state['node']->nid),
      '#limit_validation_errors' => [],
      '#weight' => 101,
    ];
  };

  $form['post_activity'] = [
    '#type' => 'checkbox',
    '#title' => t('Post Activity'),
    // Default to true only on new content.
    '#default_value' => empty($form_state['node']->nid),
    '#access' => _c4m_content_post_activity_access($form_state),
    '#weight' => 100,
  ];

  // Hide Book tab for all content types.
  if (isset($form['book'])) {
    // Check if outline is allowed.
    // - User has to have the right administration permission.
    // - Access to outline has to be enabled (admin/config/c4m/book).
    if (!variable_get('open_book_outline', FALSE) || !user_access('administer book outlines')) {
      $form['book']['#access'] = FALSE;
    }
    else {
      // Some of our books have outlines from -76 to 78 or more,
      // so we increase the range from -100 < 0 > 100.
      $form['book']['#delta'] = 100;
    }
  }

  // Add a cancel button to all node forms.
  // Check if a cancel button should be added to node forms.
  $cancel = variable_get('c4m_content_cancel_button', FALSE);
  if (!$cancel) {
    return;
  }

  // Disable form validation when a user deletes a node.
  $form['actions']['delete']['#limit_validation_errors'] = [];

  // Use destination parameter when set.
  $params = drupal_get_query_parameters();
  if (empty($params['destination'])) {
    $node = $form['#node'];

    if (!empty($node->nid)) {
      // Editing content - build path to edited node.
      $destination_on_cancel = '/node/' . $node->nid;
    }
    else {
      // Creating content (at this stage, node id is not set yet).
      $destination_on_cancel = c4m_content_construct_path_to_content_page($node->type);
    }

    $form_state['destination_on_cancel'] = [
      '#type' => 'hidden',
      '#value' => $destination_on_cancel,
    ];
  }

  // Put actions after "Send Notification" and "Post Activity" checkboxes.
  $form['actions']['#weight'] = 200;
  $form['actions']['cancel'] = [
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#submit' => ['c4m_content_cancel_button_callback'],
    '#limit_validation_errors' => [],
    '#weight' => 14,
  ];

  $is_unpublish = $form['actions']['draft']['#value'] == t('Unpublish');
  $is_og_group = in_array($form['type']['#value'], ['group', 'project']);
  // Removes Unpublish button from forms.
  if ($is_unpublish && $is_og_group) {
    $form['actions']['draft']['#access'] = FALSE;
  }
}

/**
 * Access callback for the "Post Activity" checkbox.
 *
 * @param array $form_state
 *   The $form_state array.
 *
 * @return bool
 *   TRUE if the checkbox should be displayed.
 */
function _c4m_content_post_activity_access(array $form_state) {
  $op = empty($form_state['node']->nid) ? 'insert' : 'update';
  $content_types = c4m_message_get_valid_node_types($op);
  if (in_array($form_state['node']->type, $content_types) && c4m_features_og_members_is_power_user()) {
    return TRUE;
  }

  if ($form_state['node']->type === 'article' && c4m_user_is_site_admin()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Returns path to content page.
 *
 * @param string $content_type
 *   The name of content type.
 *
 * @return string
 *   Path to group content page
 *   If $content_type is not group ('group'/'project') or group content,
 *   defaults to site homepage.
 */
function c4m_content_construct_path_to_content_page($content_type) {
  $group_content_types = array_keys(c4m_og_get_all_group_content_bundles('node'));

  // Handling types that are not content of a group.
  if (!in_array($content_type, $group_content_types)) {
    // Cancel path for 'group'/'project' types should point to
    // their view.
    $types_path = [
      'group' => 'groups',
      'project' => 'projects',
    ];

    if (in_array($content_type, array_keys($types_path))) {
      return $types_path[$content_type];
    }

    // Cancel path for others (article, book, etc...) should point to
    // site homepage.
    return '<front>';
  }

  // Handling types that are content of a group.
  $types_path = [
    'wiki_page' => 'wiki',
    'document' => 'documents',
    'discussion' => 'discussions',
    'photo' => 'media',
    'photoalbum' => 'media',
    'event' => 'calendar',
    'news' => 'news',
    'share' => '',
  ];

  // Cancel path should point to types view, under purl.
  return c4m_og_current_group_purl() . '/' . $types_path[$content_type];
}

/**
 * Implements hook_node_submit().
 *
 * If 'Send Notification' checkbox exists, add a parameter with value to the
 * node in order to determine if we should send the notification on the
 * hook_node_update / insert.
 *
 * If 'Post Activity' checkbox is present in the form but it's not checked, set
 * _skip_message parameter so the activity will not be posted on
 * hook_node_update / insert.
 */
function c4m_content_node_submit(&$node, $form, $form_state) {
  if (isset($form_state['values']['send_notification'])) {
    $node->c4m_send_notification = $form_state['values']['send_notification'];
  }

  $skip_message = _c4m_content_post_activity_access($form_state) && empty($form_state['values']['post_activity']);
  if ($skip_message) {
    $node->_skip_message = TRUE;
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * Since form_alter hook is being called after this (c4m_content) module,
 * we need to change the call order.
 */
function c4m_content_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter' && isset($implementations['c4m_content'])) {
    $c4m_content = $implementations['c4m_content'];
    unset($implementations['c4m_content']);
    $implementations['c4m_content'] = $c4m_content;
  }
}

/**
 * Cancel button callback when a destination parameter was set.
 */
function c4m_content_cancel_button_callback($form, $form_state) {
  if (empty($form_state['destination_on_cancel'])) {
    drupal_goto();
  }

  drupal_goto($form_state['destination_on_cancel']['#value']);
}

/**
 * Implements hook_block_info().
 */
function c4m_content_block_info() {
  $blocks['global_statistics_summary'] = [
    'info' => t('Global website statistics'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function c4m_content_block_view($delta = '') {
  $block = [];

  switch ($delta) {
    case 'global_statistics_summary':
      $stats_summary = [
        '#theme' => 'c4m_website_statistics_summary',
        '#data' => c4m_content_get_global_statistics(),
      ];
      $block['content'] = render($stats_summary);
      break;
  }
  return $block;
}

/**
 * Load all statistics info from implemented hook_c4m_content_statistics_info.
 *
 * @param string $context
 *   The context to load the info for.
 *   Supported contexts:
 *   - global.
 *   - group.
 *   - topic.
 *
 * @return array
 *   Configuration as collected through the implemented
 *   hook_c4m_content_statistics_info hooks.
 */
function c4m_content_statistics_info($context) {
  $cache_key = 'c4m_content:statistics_info';
  $data = &drupal_static($cache_key);

  // Retrieve from Cache if not loaded before.
  if (!isset($data)) {
    if (($cache = cache_get($cache_key)) && !empty($cache->data)) {
      $data = $cache->data;
    }
    else {
      $data = module_invoke_all('c4m_content_statistics_info');

      // Sort the contexts.
      foreach ($data as $key => $info) {
        uasort($info, 'drupal_sort_weight');
        $data[$key] = $info;
      }

      // Save in cache.
      cache_set($cache_key, $data);
    }
  }

  return (isset($data[$context]))
    ? $data[$context]
    : [];
}

/**
 * Get the global statistics.
 *
 * @return array
 *   The collected statistics.
 */
function c4m_content_get_global_statistics() {
  $list = c4m_content_statistics_info('global');
  $data = _c4m_content_statistics_collect_data($list);
  return $data;
}

/**
 * Get the topic statistics.
 *
 * @return array
 *   The collected statistics.
 */
function c4m_content_get_topic_statistics() {
  $list = c4m_content_statistics_info('topic');

  $node = menu_get_object('node');

  if (!$node || $node->type != 'topic') {
    return [];
  }

  $topic_wrapper = entity_metadata_wrapper('node', $node);
  $topic_term = $topic_wrapper->c4m_vocab_topic_mapping->value();

  foreach ($list as $key => &$info) {
    $info['topic'] = $topic_term->tid;
  }

  $data = _c4m_content_statistics_collect_data($list);
  return $data;
}

/**
 * Get the statistics specific for the current group.
 *
 * @return array
 *   The collected statistics.
 */
function c4m_content_get_current_group_statistics() {
  $og_context = og_context();
  return c4m_content_get_group_statistics($og_context);
}

/**
 * Get the statistics specific for the given group.
 *
 * @param object $og_context
 *   The group to gather the statistics for.
 *
 * @return array
 *   The collected statistics.
 */
function c4m_content_get_group_statistics($og_context = NULL) {
  if (!$og_context) {
    return [];
  }

  $group = node_load($og_context['gid']);

  $list = c4m_content_statistics_info($group->type);

  // Filter the list & limit to only content types that are enabled for the
  // given group.
  foreach ($list as $key => &$info) {

    if ($info['entity_type'] === 'node'
      && !c4m_og_feature_is_content_type_enabled($info['type'])
    ) {
      unset($list[$key]);
      continue;
    }

    // Add the current og_id to the info.
    $info['og_id'] = $og_context['gid'];
  }

  $data = _c4m_content_statistics_collect_data($list);
  return $data;
}

/**
 * Helper to collect the statistics data based on the given list.
 *
 * @param array $list
 *   Statistics configuration list retrieved from c4m_content_statistics_info().
 *
 * @return array
 *   The collected data.
 */
function _c4m_content_statistics_collect_data(array $list) {
  $data = [];

  foreach ($list as $key => $info) {
    $type = isset($info['aggregate']['type'])
      ? $info['aggregate']['type']
      : $info['type'];

    $og_id = isset($info['og_id'])
      ? $info['og_id']
      : NULL;

    $topic = isset($info['topic'])
      ? $info['topic']
      : NULL;

    $status = isset($info['c4m_status'])
      ? $info['c4m_status']
      : NULL;

    $skip_access_check = isset($info['skip_access_check'])
      ? $info['skip_access_check']
      : NULL;

    $arguments = [
      'entity_type' => $info['entity_type'],
      'bundles' => $info['bundles'],
      'state' => $info['state'],
      'og_id' => $og_id,
      'topic' => $topic,
      'c4m_status' => $status,
      'skip_access_check' => $skip_access_check,
    ];
    $count = c4m_helper_entity_get_number_of_entities($arguments);

    $link = isset($info['link'])
      ? $info['link']
      : FALSE;

    if (isset($link['options']['query']) && $topic) {
      $link['options']['query']['f'] = str_replace(
        '@TOPIC_ID',
        $topic,
        $link['options']['query']['f']
      );
    }

    if (!isset($data[$type])) {
      $data[$type] = [
        'title' => [
          'singular' => $info['singular'],
          'plural' => $info['plural'],
        ],
        'count' => 0,
        'attributes' => $info['attributes'],
        'link' => $link,
      ];
    }

    $data[$type]['count'] += $count;
  }

  return $data;
}

/**
 * Implements hook_theme().
 */
function c4m_content_theme() {
  $theme['c4m_website_statistics_summary'] = [
    'variables' => [
      'data' => [],
      'more_link' => [],
    ],
    'file' => 'c4m_content.theme.inc',
    'path' => drupal_get_path('module', 'c4m_content') . '/includes',
  ];

  $theme['c4m_taxonomy_tree'] = [
    'template' => 'c4m_taxonomy_tree',
    'path' => drupal_get_path('module', 'c4m_content') . '/templates',
    'variables' => [
      'root' => '',
      'local_tree' => '',
      'class' => '',
    ],
  ];

  return $theme;
}

/**
 * Helper to determine the current context.
 *
 * @return string
 *   Returns one of the following contexts:
 *   - group: we are in a group
 *   - global: we are outside a group
 */
function c4m_content_current_context() {
  $gid = c4m_og_current_group_id();
  if ($gid) {
    return 'group';
  }
  else {
    return 'global';
  }
}

/**
 * Helper function to generate markup for OG group image.
 *
 * Generates output on front page, manage group/project page, and on any
 * group/project page for group administrator users.
 *
 * @param object $group
 *   OG group.
 *
 * @return string
 *   Generated markup for group/project banner image.
 */
function c4m_content_get_og_image_markup($group) {
  // First establish the current group.
  $markup = '';
  $wrapper = entity_metadata_wrapper('node', $group);

  $menu_item = menu_get_item();
  if (drupal_is_front_page() || ($menu_item['path'] == 'manage' && og_user_access(
        'node',
        $group->nid,
        'administer group'
      ))
  ) {
    // Add group image.
    $file = $wrapper->c4m_banner->value();
    if (!empty($file)) {
      $file['style_name'] = 'banner';
      $file['path'] = $file['uri'];
      $file['attributes'] = ['class' => 'group-banner'];
      // If current page is the Group Management page,
      // Add an edit link to the banner.
      if ($menu_item['path'] == 'manage') {
        $edit_link['element'] = [
          '#tag' => 'span',
          '#attributes' => [
            'class' => ['edit-link'],
          ],
          '#value' => t('Edit'),
        ];
        $options = [
          'html' => TRUE,
          'attributes' => [
            'class' => [
              'edit-banner',
            ],
          ],
        ];
        $markup .= l(
          theme_html_tag($edit_link) . theme_image_style($file),
          url(
            'node/' . $group->nid . '/edit',
            [
              'absolute' => TRUE,
              'fragment' => 'edit-image-banner',
            ]
          ),
          $options
        );
      }
      else {
        $markup .= theme_image_style($file);
      }
    }
  }

  return $markup;
}

/**
 * Implements hook_field_formatter_info().
 */
function c4m_content_field_formatter_info() {
  return [
    'c4m_formatter_ec_money' => [
      'label' => t('EC money'),
      'field types' => ['money'],
    ],
  ];
}

/**
 * Implements hook_field_formatter_view().
 */
function c4m_content_field_formatter_view(
  $entity_type,
  $entity,
  $field,
  $instance,
  $langcode,
  $items,
  $display
) {
  $element = $used = [];

  switch ($display['type']) {
    case 'c4m_formatter_ec_money':
      foreach ($items as $delta => $item) {
        // Code inspired from money_field_formatter_view().
        $currency = $item['currency'];
        $currency_object = currency_load($currency);

        $symbol = $currency_object->sign;
        // Amount with currency-based decimal and grouping separators.
        $amount = c4m_content_ec_number_format(
          $item['amount'],
          $field['settings']['scale']
        );

        // Amount with currency-based decimal and grouping separators and a
        // currency symbol.
        $amount_with_symbol = $currency_object->format($item['amount']);

        $output = '';
        foreach (explode(
                   '|',
                   $instance['widget']['settings']['currency_display_mode']
                 ) as $option) {
          switch ($option) {
            case 'a':
              // The amount.
              $output .= $amount;
              break;

            case 'as':
              // Amount with currency symbol.
              $output .= $amount_with_symbol;
              break;

            case 'c':
              // Currency code.
              $output .= $currency;
              break;

            case 's':
              // Currency symbol.
              $output .= $symbol;
              break;

            case '+':
              // Separator.
              $output .= '&nbsp;';
              break;
          }
        }

        $element[$delta] = ['#markup' => $output];
      }

      break;
  }
  return $element;
}

/**
 * Format a number according to EC format.
 *
 * @param float $number
 *   Number to be formatted.
 * @param int $decimals
 *   (optional) Number of decimals. Defaults to 0.
 *
 * @return string
 *   Formatted number.
 */
function c4m_content_ec_number_format($number, $decimals = 0) {
  $decimal_separator = '.';
  $grouping_separator = '&nbsp;';

  // Amount with currency-based decimal and grouping separators.
  $amount = number_format(
    $number,
    $decimals,
    $decimal_separator,
    $grouping_separator
  );
  return $amount;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Overrides the default confirm node delete form to offer the possibility to
 * anonymize the content.
 */
function c4m_content_form_node_delete_confirm_alter(array &$form, array &$form_state) {
  $node = $form['#node'];
  $comments = $node->comment_count;

  if ($comments) {
    // Handle sentence plural when multiple comments.
    $text = $comments > 1 ? t('comments') : t('comment');

    $replacements = [
      '@comment_count' => $comments,
      '@comment_text' => $text,
    ];

    $form['message'] = [
      '#type' => 'markup',
      '#markup' => '<p>' . t('This content has @comment_count @comment_text - by deleting this post, you will also delete the @comment_text. If you would rather preserve this content, please select the check box below to remove your name and editorial rights; the author will become anonymous, and all content will be preserved.', $replacements) . '</p>',
      '#weight' => -10,
    ];

    $form['anonymize'] = [
      '#type' => 'checkbox',
      '#title' => t('Update the author to anonymous'),
    ];
  }

  // We override the default submit.
  $form['#submit'] = ['c4m_content_custom_node_delete_confirm'];
}

/**
 * Custom submit callback for deleting nodes to anonymize content if requested.
 */
function c4m_content_custom_node_delete_confirm($form, &$form_state) {
  $node = $form['#node'];
  $group = c4m_og_get_group_of_content($node);

  // If anonymize is requested, update node author to anonymous user.
  if (!empty($form_state['values']['anonymize'])) {
    $node->uid = 0;

    node_save($node);
  }
  // Anonymize not requested. Call default submit.
  else {
    node_delete_confirm_submit($form, $form_state);
  }

  // If node is content of group / project,  when operation is completed,
  // redirect to it's homepage. Otherwise, redirect to site front page.
  if ($group) {
    $form_state['redirect'] = $group->purl;
  }
  else {
    $form_state['redirect'] = '<front>';
  }
}

/**
 * Returns the list of content types that can be highlighted.
 *
 * @return array
 *   The node types that can be highlighted.
 */
function c4m_content_highlightable_node_types() {
  return [
    'group',
    'project',
    'discussion',
    'document',
    'event',
    'wiki_page',
    'photo',
    'photoalbum',
    'news',
  ];
}

/**
 * Returns the list of content types that can be promoted.
 *
 * @return array
 *   The node types that can be promoted.
 */
function c4m_content_promotable_node_types() {
  return [
    'discussion',
    'document',
    'event',
    'wiki_page',
  ];
}

/**
 * Implements hook_menu().
 *
 * Add menu item to change the promote property of a node.
 */
function c4m_content_menu() {
  $items = [];

  $items['group/%node/promote_content/%node/%/%'] = [
    'title' => 'Toggle highlight',
    'description' => 'Toggle the promote property of a node.',
    'page callback' => 'c4m_content_toggle_highlight',
    'page arguments' => [1, 3, 4, 5],
    'access callback' => 'c4m_content_toggle_highlight_access',
    'access arguments' => [1, 3, 4],
  ];

  return $items;
}

/**
 * Check access to change the promote value of the node.
 *
 * @param object $group
 *   The group of the node.
 * @param object $node
 *   The node with to promote value.
 * @param int $status
 *   The value to change the promote to.
 *
 * @return bool
 *   TRUE|FALSE
 */
function c4m_content_toggle_highlight_access($group, $node, $status) {
  if (empty($node)) {
    return FALSE;
  }

  if ($status != NODE_PROMOTED && $status != NODE_NOT_PROMOTED) {
    return FALSE;
  }

  // Verify the type of the node.
  if (!in_array($node->type, c4m_content_highlightable_node_types())) {
    return NULL;
  }

  if (!og_is_group('node', $group)) {
    return FALSE;
  }

  // Allow SA only to highlight a group/project.
  if (og_is_group('node', $node)) {
    return c4m_user_is_site_admin();
  }

  // Verify that the node being highlighted belongs to this group.
  if (!og_is_member('node', $group->nid, 'node', $node)) {
    return FALSE;
  }

  // Allow power users (SA, GO and GA) to highlight group content.
  return c4m_features_og_members_is_power_user($group);
}

/**
 * Change the promote property in a node.
 *
 * @param object $group
 *   The group of the node.
 * @param object $node
 *   The node to be changed.
 * @param int $status
 *   The value to change to.
 * @param string $ajax
 *   The link ajax.
 */
function c4m_content_toggle_highlight($group, $node, $status, $ajax = 'nojs') {
  $wrapper = entity_metadata_wrapper('node', $node);

  // Add parameter to node that will signal to cancel notification that is
  // triggered, as a result of node update, because we should not send
  // a notification for de-highlighting.
  if ($status) {
    $node->c4m_send_notification = FALSE;
  }

  // Setting the new value.
  // When generating the link, we create it with the current status. So, when
  // updating the node, we have to change it to the opposite status.
  $wrapper->promote->set(!$status);
  $wrapper->save();

  if ($ajax != 'ajax') {
    // Return a Drupal message if js in disabled or not found.
    drupal_set_message(t('Change the promote value.'));
    drupal_goto();
  }
  else {
    // After success we should replace the current button with a
    // new button link - the toggled one.
    $link = c4m_content_create_highlight_link(
      $group->nid,
      $node->nid,
      $wrapper->promote->value()
    );

    $commands[] = ajax_command_replace('#highlight-content' . $node->nid, $link);
    $page = ['#type' => 'ajax', '#commands' => $commands];
    ajax_deliver($page);
  }
}

/**
 * Create the highlight button link.
 *
 * @param int $gid
 *   The group id.
 * @param int $nid
 *   The node id.
 * @param int $highlight
 *   Determinant if the node highlight or not.
 *
 * @return string
 *   The link created for the highlight button.
 */
function c4m_content_create_highlight_link($gid, $nid, $highlight) {
  $url = 'group/' . $gid . '/promote_content/' . $nid . '/' . $highlight . '/nojs';

  $options = [
    'attributes' => [
      'title' => t('Highlight'),
      'class' => ['use-ajax', 'highlight-link'],
      'id' => 'highlight-content' . $nid,
    ],
    'purl' => ['disabled' => TRUE],
    'html' => TRUE,
  ];

  // Determine if the the star type should be full or not,
  // by the highlight property.
  $star_class = [
    NODE_NOT_PROMOTED => 'fa-star-o',
    NODE_PROMOTED => 'fa-star',
  ];
  $star = '<i class="fa ' . $star_class[$highlight] . '" aria-hidden="true"></i>';

  if ($gid === $nid) {
    $action_text = $highlight ? t('Featured') : t('Feature');
  }
  else {
    $action_text = $highlight ? t('Highlighted') : t('Highlight');
  }

  $link_text = $star . '<span class="highlight-link-text">' . $action_text . '</span>';

  return l($link_text, $url, $options);
}

/**
 * Build a tree of a hierarchical taxonomy and theme it.
 *
 * @param array $items
 *   The items in the tree.
 * @param array $link_term_to_facet
 *   The current vocabulary machine name, for linking to facet.
 *
 * @return string
 *   The markup of the tree.
 */
function c4m_content_taxonomy_build_tree(
  array $items,
  array $link_term_to_facet = []
) {
  // Each item at $trees is an array, representing two level tree.
  // First node is tree root (level 1), and all others, if exist,
  // are children (level 2).
  $trees = [];

  // Stores positions of trees to be shifted right, as they present
  // second and third level, at 3 level taxonomy hierarchy.
  $shift_right_trees = [];

  while (!empty($items)) {
    // Extract first root item from $items array - level 1.
    if (!($root = _c4m_content_taxonomy_extract_root_item($items))) {
      // We get here in case of dis-attached terms - terms data
      // is corrupted.
      break;
    }
    // Extract all roots children from $items array - level 2.
    $children = _c4m_content_taxonomy_extract_child_items($items, $root->tid);
    // Items from $children array, that don't have children of their own.
    $childless_children = $children;

    // Handling 3-rd level (grand children), if exist.
    $sub_trees = [];
    foreach ($children as $child) {
      // For every 2-nd level item (child), fetch it's children from $items.
      $grand_children = _c4m_content_taxonomy_extract_child_items(
        $items,
        $child->tid
      );
      if (!empty($grand_children)) {
        // If grand children exist (3-rd level items), remove the child
        // from $childless_children array.
        $index = array_search($child, $childless_children);
        unset($childless_children[$index]);

        // Add array item that represents 2 level tree, where first level item
        // is a child, and 2-nd level items are grand children.
        $sub_trees[] = array_merge([$child], $grand_children);
      }
    }

    // Add array item for 1-st & 2-nd level tree.
    $root = empty($childless_children) ? [$root] : array_merge(
      [$root],
      $childless_children
    );
    $trees[] = $root;

    // For every sub tree created (2-nd & 3-rd level tree).
    foreach ($sub_trees as $sub_tree) {
      // Add it to to arrays tree, and store it's index, for shifting right.
      $trees[] = $sub_tree;
      $trees_keys = array_keys($trees);
      $shift_right_trees[] = end($trees_keys);
    }
  }

  // Link taxonomy terms to filtered page within OG context if provided.
  // If not under og context, link to global search.
  // Refactor is we WANT to break outside the silos.
  if (!$context = og_context()) {
    $path = 'search';
    $options = [
      'absolute' => TRUE,
      'purl' => ['disabled' => TRUE],
    ];
  }
  else {
    $path = 'searchgroup';
    $options = [
      'absolute' => TRUE,
      'purl' => [
        'provider' => 'og_purl|node',
        'id' => $context['gid'],
      ],
    ];
  }

  $tree = '';
  // Counting trees we theme, as some might need to be shifted right.
  $tree_index = 0;

  // Loop through all the taxonomy items and add them to the tree.
  foreach ($trees as $taxonomy_tree) {
    $local_tree = [];
    foreach ($taxonomy_tree as $taxonomy) {
      // If the link term was not provided, or it isn't the proper
      // one for the current vocabulary, create a default link to
      // the taxonomy term.
      if (empty($link_term_to_facet['vocabulary_name']) || $taxonomy->vocabulary_machine_name != $link_term_to_facet['vocabulary_name']) {
        $link = l($taxonomy->name, "/taxonomy/term/" . $taxonomy->tid);
      }
      else {
        $options['query'] = [
          'f[0]' => $link_term_to_facet['vocabulary_name'] . ':' . $taxonomy->tid,
        ];

        $link = l($taxonomy->name, $path, $options);
      }

      $local_tree[] = $link;
    }

    // If it's the first item on the local tree, it's the parent. We need
    // to distinguish between the parent and its children because the
    // parent needs to get a different style.
    $root = array_shift($local_tree);

    // Use the taxonomy tree theme to style the local tree.
    $variables = [
      'root' => $root,
      // Join the local_tree array to a string.
      'local_tree' => implode(', ', $local_tree),
    ];

    // Assign a dedicated class for trees that needs to be shifted right.
    if (array_search($tree_index, $shift_right_trees) !== FALSE) {
      $variables['class'] = 'shift-right';
    }
    $tree .= theme('c4m_taxonomy_tree', $variables);

    $tree_index++;
  }

  $tag['element'] = [
    '#tag' => 'div',
    '#value' => $tree,
  ];

  return theme_html_tag($tag);
}

/**
 * Helper function.
 *
 * Extracts all child taxonomy items from $items, and alter $items -
 * subtracted all items that function returns.
 *
 * @param array $items
 *   Taxonomies array, from which we extract all children of item with
 *   ID == $parent_id. $items array is altered by function.
 * @param int $parent_id
 *   The ID of taxonomy item, which children should be extracted.
 *
 * @return array
 *   All child items of input item with ID $parent_id.
 */
function _c4m_content_taxonomy_extract_child_items(array &$items, $parent_id) {
  $result = [];
  $remaining = [];

  foreach ($items as $item) {
    // Get the parent of $item.
    $parent = taxonomy_get_parents($item['tid']);
    if (!empty($parent) && key($parent) == $parent_id) {
      // If item's parent found, and it's ID equals to input $parent_id,
      // add it's 'taxonomy_term' into $result array.
      $result[] = $item['taxonomy_term'];
    }
    else {
      // $remaining array holds all the items that are not children of
      // item which ID == $parent_id.
      $remaining[] = $item;
    }
  }
  // Alter original $items array - subtract all the $result items.
  $items = $remaining;

  return $result;
}

/**
 * Helper function.
 *
 * Extracts first taxonomy item that got no parents from $items array
 * (alters the array), and returns it.
 *
 * @param array $items
 *   Taxonomies array, from which we extract all children of item with
 *   ID = $parent_id. $items array is altered by function.
 *
 * @return mixed
 *   First taxonomy item at $items array, that got no parents.
 *   FALSE, if all items got a parent.
 */
function _c4m_content_taxonomy_extract_root_item(array &$items) {
  foreach ($items as $key => $item) {
    $parent = taxonomy_get_parents($item['tid']);
    if (empty($parent)) {
      // First item that got no parent => remove it from $items,
      // and return it's term.
      unset($items[$key]);

      return $item['taxonomy_term'];
    }
  }

  // All items got a parent.
  return FALSE;
}

/**
 * Manages access to 'create group content' form.
 *
 * Allows access for group power users. Members allowed access, when creating
 * all content types, besides wiki page.
 */
function c4m_content_create_group_content_access() {
  $item = menu_get_item();

  $regex = '/node\/add\/(discussion|document|event|news|photo|photoalbum|wiki-page)/';

  // Making sure the current request is for the node/add form.
  preg_match($regex, $item['path'], $matches);
  if (empty($matches[0])) {
    return;
  }

  // If not under og context, deny access.
  if (!$context = og_context()) {
    c4m_content_deny_access();
  }

  // We allow access only for draft / published groups.
  $group = node_load($context['gid']);

  // News should not be added to a group.
  if ($matches[1] == 'news' && $group->type == 'group') {
    c4m_content_deny_access();
  }

  // Discussion should not be added to a project.
  if ($matches[1] == 'discussion' && $group->type == 'project') {
    c4m_content_deny_access();
  }

  $group_state = c4m_og_get_group_status($group);

  // Site admin may not add content to pending/deleted group.
  // No other restrictions.
  if (c4m_user_is_site_admin()) {

    if ($group_state == 'pending' || $group_state == 'deleted') {
      c4m_content_deny_access();
    }
    else {
      return;
    }
  }

  $allowed_states = ['draft', 'published'];
  // Deny access, if group state is not allowed.
  if (!in_array($group_state, $allowed_states)) {
    c4m_content_deny_access();
  }
  else {
    $user_type = _c4m_features_og_members_get_user_type($group);

    $allowed_user_types = [
      C4M_USER_TYPE_GA,
      C4M_USER_TYPE_GO,
    ];

    // If content is not wiki page, allow it's creation by group member.
    $bundle = explode('/', $item['path']);
    if ($bundle[2] != 'wiki-page') {
      $allowed_user_types[] = C4M_USER_TYPE_GM;
    }

    // We allow access to power users, and members, when creating content.
    if (!in_array($user_type, $allowed_user_types)) {
      c4m_content_deny_access();
    }
  }
}

/**
 * Redirects to page 'Access denied'.
 */
function c4m_content_deny_access() {
  drupal_access_denied();
  drupal_exit();
}

/**
 * Creates html for link to toggle group notifications.
 *
 * @param object $account
 *   User, for which link is created.
 * @param object $group
 *   Group, for which link is created.
 *
 * @return string
 *   HTML block representing the link.
 */
function c4m_content_create_toggle_group_notification_link($account, $group) {
  $user_subscribed = _c4m_content_group_is_subscribed_to_group_notifications($account, $group);
  $message_text = $user_subscribed ? t('Notifications are enabled') : t('Notifications are disabled');
  $link_text = $user_subscribed ? t('disable') : t('enable');
  $icon_class = $user_subscribed ? 'fa fa-bell-o' : 'fa fa-bell-slash-o';

  $options = [
    'attributes' => [
      'class' => 'use-ajax',
    ],
    'purl' => ['enabled' => TRUE],
    'html' => TRUE,
  ];

  $link = l($link_text, 'group/' . $group->nid . '/notification/nojs', $options);

  $tag['element'] = [
    '#tag' => 'i',
    '#value' => '',
    '#attributes' => [
      'class' => $icon_class,
    ],
  ];
  $icon_html = theme_html_tag($tag);

  $tag['element'] = [
    '#tag' => 'span',
    '#value' => $icon_html . $message_text . '  (' . $link . ')',
    '#attributes' => [
      'id' => 'toggle-group-notifications',
    ],
  ];

  return theme_html_tag($tag);
}

/**
 * Themes toggle group notifications link.
 *
 * @return string
 *   Rendered html for field.
 */
function c4m_content_theme_toggle_group_notification_link() {
  global $user;

  if (!($group = c4m_og_current_group())) {
    return '';
  }

  // It's a group, and user is not a member.
  if (c4m_og_is_of_group_type('group') && !og_is_member('node', $group->nid)) {
    return '';
  }

  // It's a project, and user is not authenticated.
  if (c4m_og_is_of_group_type('project') && $user->uid === 0) {
    return '';
  }

  return c4m_content_create_toggle_group_notification_link($user, $group);
}

/**
 * Implements hook_menu_alter().
 *
 * Adds a menu item for AJAX call that enables / disables group notifications.
 */
function c4m_content_menu_alter(&$items) {
  $items['group/%node/notification/%'] = [
    'title' => 'Manage notifications',
    'page callback' => 'c4m_content_toggle_group_notification',
    'page arguments' => [1, 3],
    'access callback' => 'c4m_content_toggle_group_notification_access',
    'access arguments' => [1],
  ];

  $items['node/add']['access callback'] = 'c4m_content_add_access';

  return $items;
}

/**
 * Access Callback; /node/add should be allowed for SA only.
 */
function c4m_content_add_access() {
  return c4m_user_is_site_admin();
}

/**
 * Access function - AJAX call to menu that triggers group notifications toggle.
 *
 * @param object $group
 *   Group, for which notifications are toggled.
 *
 * @return bool
 *   Whether user is group member, or not.
 */
function c4m_content_toggle_group_notification_access($group) {
  global $user;

  if (!og_context_is_init()) {
    // OG context was not determined yet, so register the path and return early.
    // The next time this access callback will be called, it will not enter
    // here.
    og_context_access_callback_register_path($_GET['q']);

    return FALSE;
  }

  // It's a group, and user is not a member.
  if (c4m_og_is_of_group_type('group') && !og_is_member('node', $group->nid)) {
    return FALSE;
  }

  // It's a project, and user is not authenticated.
  if (c4m_og_is_of_group_type('project') && $user->uid === 0) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Executes group notifications toggle for current user.
 *
 * @param object $group
 *   Group, for which to execute toggle.
 * @param string $ajax
 *   Link suffix, that's changed from 'nojs' to 'ajax' by AJAX library JS.
 */
function c4m_content_toggle_group_notification($group, $ajax = 'nojs') {
  global $user;

  if ($ajax != 'ajax') {
    // Return a Drupal message if js in disabled or not found.
    drupal_set_message(t('Change the promote value.'));
    drupal_goto();
  }

  $group = c4m_og_current_group();
  // Toggle notifications.
  _c4m_content_group_toggle_group_notifications($user, $group);
  // Generate new link. Trim generated html, so AJAX won't create
  // a wrapping div: https://api.drupal.org/comment/32698#comment-32698.
  $link = trim(c4m_content_create_toggle_group_notification_link($user, $group));

  // Use AJAX commands to replace link on the page.
  $commands[] = ajax_command_replace('#toggle-group-notifications', $link);
  $page = ['#type' => 'ajax', '#commands' => $commands];
  ajax_deliver($page);
}

/**
 * Gets all node IDs of a specific type (bundle).
 *
 * @param string $type
 *   The node type.
 *
 * @return array
 *   The IDs of the nodes.
 */
function c4m_content_get_all_node_ids_by_type($type) {
  $cache = &drupal_static(__FUNCTION__ . $type);
  if (!isset($cache)) {
    $cache = db_select('node', 'n')
      ->fields('n', ['nid'])
      ->condition('type', $type)
      ->execute()
      ->fetchAllKeyed(0, 0);
  }

  return $cache;
}

/**
 * Implements hook_node_access_records().
 *
 * Add same realms to OG content, as of group it belongs to.
 */
function c4m_content_node_access_records($node) {
  if (!og_is_group_content_type('node', $node->type)) {
    // Node is not a group content.
    return;
  }

  if (!$group = c4m_og_get_group_of_content($node)) {
    // Failed to resolve the group, to which content belongs.
    return;
  }

  return c4m_content_group_node_access_records($group);
}

/**
 * Implements hook_ds_fields_info().
 */
function c4m_content_ds_fields_info($entity_type) {
  $fields = [
    'c4m_dsfield_print_page_button' => [
      'title' => t('C4M - Print page button'),
      'field_type' => DS_FIELD_TYPE_FUNCTION,
      'function' => '_c4m_content_dsfield_print_button',
    ],
  ];

  return [$entity_type => $fields];
}

/**
 * Defines ds field for page print.
 *
 * @param array $field
 *   Field settings.
 *
 * @return string
 *   Output of the ds field.
 */
function _c4m_content_dsfield_print_button(array $field) {
  $output = [
    '#theme' => 'c4m_helper_entity_actions_print',
  ];
  return render($output);
}

/**
 * Helper function to update url aliases.
 *
 * @param array $sandbox
 *   Persistent sandbox array with batch progress and status.
 * @param string $url_prefix
 *   URL prefix.
 * @param string $type
 *   Node type.
 *
 * @return string
 *   Message.
 */
function c4m_content_batch_update_aliases(array &$sandbox, $url_prefix, $type) {
  $query = db_select('url_alias', 'ua')
    ->fields('ua', ['source'])
    ->condition('alias', $url_prefix . '%', 'LIKE');
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['max'] = $query->execute()->rowCount();
    $sandbox['messages'] = [];
  }

  $limit = 100;
  $results = $query->range(0, $limit)
    ->orderBy('pid')
    ->execute()
    ->fetchCol();

  foreach ($results as &$alias) {
    $alias = str_replace('node/', '', $alias);
  }

  $nodes = node_load_multiple($results);
  foreach ($nodes as $node) {
    if ($node->type === $type) {
      $node->path['pathauto'] = TRUE;
      pathauto_node_update_alias($node, 'update');
    }
    $sandbox['progress']++;
  }

  // Safety check in case that some urls got updated since the batch was
  // started.
  if (count($results) < $limit) {
    $sandbox['progress'] = $sandbox['max'];
  }

  $sandbox['#finished'] = ($sandbox['progress'] >= $sandbox['max']) ? TRUE : ($sandbox['progress'] / $sandbox['max']);

  return t('Modified aliases to @progress from @max.', [
    '@progress' => $sandbox['progress'],
    '@max' => $sandbox['max'],
  ]);
}
