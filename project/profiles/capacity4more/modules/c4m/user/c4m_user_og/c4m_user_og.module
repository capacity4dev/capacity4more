<?php

/**
 * @file
 * Functionality to provide missing info about a user.
 *
 * And his (activity within) groups.
 */

/**
 * Check if a user has a specific permission within the group.
 *
 * @param string $permission
 *   The permission name.
 * @param object $group
 *   (optional) If no group is given, the current group will be used.
 *
 * @return bool
 *   Has access to the given permission.
 */
function c4m_user_og_has_group_permission($permission, $group = NULL) {
  if (is_null($group) || is_object($group)) {
    $group = c4m_og_current_group();
  }

  if (!$group) {
    return FALSE;
  }

  // Re-use built-in og user access checks.
  return og_ui_user_access_group($permission, 'node', $group->nid);
}

/**
 * Get the role a user has within the given group.
 *
 * Only the highest role will be returned.
 * Possible roles (highest order to lowest):
 * - owner : the user is the owner (creator) of the group.
 * - administrator : the user can manage the group.
 * - member : the user is a member of the group.
 * - blocked : the user is blocked or his membership request was rejected.
 * - pending : the membership was requested and waiting for approval.
 *
 * @param object $user
 *   The user for who we are collecting his role.
 * @param object $group
 *   The group where we are trying to determine the users role for.
 *
 * @return string
 *    The user role.
 */
function c4m_user_og_get_role_in_group($user, $group) {
  // Is user the owner of the group node?
  if ((int) $user->uid === (int) $group->uid) {
    return 'owner';
  }

  // Has the user a membership for the given group?
  $membership = og_get_membership('node', $group->nid, 'user', $user->uid);
  if (!$membership) {
    return NULL;
  }

  // Check if not pending or blocked.
  switch ($membership->state) {
    case OG_STATE_PENDING:
      return 'pending';

    case OG_STATE_BLOCKED:
      return 'blocked';
  }

  // Check if the user has the administrator role.
  $roles = og_roles('node', $group->type, $group->nid);
  $admin_role = array_search(C4M_FEATURES_OG_MEMBERS_ADMINISTRATOR_ROLE_NAME, $roles);
  if ($admin_role) {
    $user_roles = og_get_user_roles('node', $group->nid, $user->uid);
    if (array_search(C4M_FEATURES_OG_MEMBERS_ADMINISTRATOR_ROLE_NAME, $user_roles)) {
      return 'administrator';
    }
  }

  // Ok, normal member.
  return 'member';
}

/**
 * Get the human name of the role a user has within a group.
 *
 * Is a wrapper around c4m_user_og_get_role_in_group(). It translates the
 * machine name of the role into a human label.
 *
 * @param object $user
 *   The user for who we are collecting his role.
 * @param object $group
 *   The group where we are trying to determine the users role for.
 *
 * @return string
 *    The human readable name of the user role.
 */
function c4m_user_og_get_role_in_group_human($user, $group) {
  $role = c4m_user_og_get_role_in_group($user, $group);
  $role_human = c4m_user_og_get_human_role_name($role, $group);
  return $role_human;
}

/**
 * Translate a machine user role name into a human name.
 *
 * @param string $role
 *   The machine name of the role.
 * @param object $group
 *   The (optional) group node for who we are translating the role name.
 *
 * @return string
 *   The human name of the role.
 */
function c4m_user_og_get_human_role_name($role, $group = NULL) {
  if (!$group) {
    $group = c4m_og_current_group();
  }
  if (!$group) {
    return FALSE;
  }

  $role_human = $role;
  $group_type = ucfirst(node_type_get_name($group));

  switch ($role) {
    case 'owner':
      $role_human = t(
        '@group_type Owner',
        array('@group_type' => $group_type)
      );
      break;

    case 'administrator':
    case 'administrator member':
      $role_human = t(
        '@group_type Administrator',
        array('@group_type' => $group_type)
      );
      break;

    case 'member':
      $role_human = t(
        '@group_type Member',
        array('@group_type' => $group_type)
      );
      break;

    case 'blocked':
      $role_human = t('Blocked/Rejected Membership');
      break;

    case 'pending':
      $role_human = t('Requested Membership');
      break;
  }

  return $role_human;
}

/**
 * Get the number of posts (nodes) for the given user within the given group.
 *
 * @param int $uid
 *   The User ID.
 * @param int $gid
 *   The Group ID (node id).
 *
 * @return int
 *    Number of posts from user within group.
 */
function c4m_user_og_count_nodes_in_group($uid, $gid) {
  $query = db_select('node', 'n');
  $query->join('og_membership', 'ogm', 'n.nid = ogm.etid');
  $query->fields('n', array('nid'))
    ->condition('n.status', 1)
    ->condition('n.uid', (int) $uid)
    ->condition('ogm.gid', (int) $gid)
    ->condition('ogm.entity_type', 'node');

  return (int) $query->countQuery()->execute()->fetchField();
}

/**
 * Get the number of comments for the given user within the given group.
 *
 * @param int $uid
 *   The User ID.
 * @param int $gid
 *   The Group ID (node id).
 *
 * @return int
 *    Number of comments from user within group.
 */
function c4m_user_og_count_comments_in_group($uid, $gid) {
  $query = db_select('comment', 'c');
  $query->join('node', 'n', 'c.nid = n.nid');
  $query->join('og_membership', 'ogm', 'n.nid = ogm.etid');
  $query->fields('c', array('cid'))
    ->condition('c.status', 1)
    ->condition('n.status', 1)
    ->condition('c.uid', (int) $uid)
    ->condition('ogm.gid', (int) $gid)
    ->condition('ogm.entity_type', 'node');

  return (int) $query->countQuery()->execute()->fetchField();
}

/**
 * Check if a user has groups.
 *
 * @param mixed $account
 *   Optional account object, defaults to the active user.
 * @param string $bundle
 *   Optional bundle type, can be 'group' (default) or 'project'.
 * @param int $status
 *   Optional status of the groups to filter on, default published.
 *
 * @return bool
 *   Boolean indication if the user has groups.
 */
function c4m_user_og_has_groups($account = NULL, $bundle = 'group', $status = NODE_PUBLISHED) {
  $groups = og_get_groups_by_user($account);
  if (empty($groups)) {
    return FALSE;
  }

  // Count groups of bundle type.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $bundle)
    ->entityCondition('entity_id', $groups['node'], 'IN')
    ->propertyCondition('status', $status)
    ->count();
  $count = $query->execute();

  return $count > 0;
}

/**
 * Get groups a user belongs to.
 *
 * @param mixed $account
 *   Optional account object, defaults to the active user.
 * @param string $bundle
 *   Optional bundle type, can be 'group' (default) or 'project'.
 * @param int $status
 *   Optional status of the groups to filter on, default published.
 *
 * @return array|void
 *   An array with the groups or an empty array.
 */
function c4m_user_og_get_groups($account = NULL, $bundle = 'group', $status = NODE_PUBLISHED) {
  $groups = og_get_groups_by_user($account);

  if (empty($groups)) {
    return array();
  }

  // Load groups of bundle type.
  $group_nodes = node_load_multiple($groups['node'], array('type' => $bundle));
  return $group_nodes;
}

/**
 * Returns the amount of (group) contributors.
 *
 * @param int $og_id
 *   The Organic Group ID to eventually limit the query for.
 *
 * @return int
 *   The amount of contributors.
 */
function c4m_user_og_get_number_of_contributors($og_id = NULL) {
  $query = db_select('users', 'u');
  $query->join('node', 'n', 'n.uid = u.uid');
  $query->fields('u', array('uid'));
  $query->groupBy('u.uid');
  $query->condition('u.status', 1);
  $query->condition('n.status', 1);

  if (is_numeric($og_id)) {
    $query->join('og_membership', 'ogm', 'ogm.etid = n.nid');
    $query->condition('ogm.gid', (int) $og_id);
    $query->condition('ogm.entity_type', 'node');
  }

  return (int) $query->countQuery()->execute()->fetchField();
}

/**
 * Returns the amount of pending members in a group.
 *
 * @param int $og_id
 *   The Organic Group ID to limit the query for.
 *
 * @return int
 *   The amount of pending members of a group.
 */
function c4m_user_og_get_number_of_pending_members($og_id = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'og_membership');
  $query->propertyCondition('type', 'og_membership_type_default');
  $query->propertyCondition('entity_type', 'user');
  $query->propertyCondition('group_type', 'node');
  $query->propertyCondition('state', OG_STATE_PENDING);

  if (is_numeric($og_id)) {
    $query->propertyCondition('gid', $og_id);
  }

  return (int) $query->count()->execute();
}

/**
 * Returns the amount of active members in a group.
 *
 * @param int $og_id
 *   The Organic Group ID to limit the query for.
 *
 * @return int
 *   The amount of active members of a group.
 */
function c4m_user_og_get_number_of_active_members($og_id = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'og_membership');
  $query->propertyCondition('type', 'og_membership_type_default');
  $query->propertyCondition('entity_type', 'user');
  $query->propertyCondition('group_type', 'node');
  $query->propertyCondition('state', OG_STATE_ACTIVE);

  if (is_numeric($og_id)) {
    $query->propertyCondition('gid', $og_id);
  }

  return (int) $query->count()->execute();
}

/**
 * Returns the amount of contributors vs active members in a group.
 *
 * @param int $og_id
 *   The Organic Group ID to limit the query for.
 *
 * @return int
 *   The amount of contributors vs active members of a group.
 */
function c4m_user_og_get_number_of_contributors_vs_members($og_id) {
  $contributors = c4m_user_og_get_number_of_contributors($og_id);
  $active_members = c4m_user_og_get_number_of_active_members($og_id);

  if (is_numeric($contributors) && (is_numeric($active_members) && $active_members > 0)) {
    $calculation = $contributors / $active_members;
    return empty($calculation) ? 0 : $calculation;
  }

  return 0;
}

/**
 * Implements hook_c4m_content_statistics_info().
 */
function c4m_user_og_c4m_content_statistics_info() {
  return array(
    'group' => array(
      'c4m_og_user' => array(
        'type'          => 'user',
        'entity_type'   => 'user',
        'bundles'       => array(),
        'singular'      => 'Member',
        'plural'        => 'Members',
        'state'         => 1,
        'c4m_status'    => array(1),
        'scope'         => 'group',
        'aggregate'     => array(),
        'weight'        => 7,
        'feature_name'  => 'c4m_features_og_members',
        'attributes'    => array(
          'class' => array('og-users'),
        ),
        'link' => array(
          'path' => 'members',
        ),
      ),
    ),
  );
}

/**
 * Implements hook_c4m_helper_entity_metrics_info().
 */
function c4m_user_og_c4m_helper_entity_metrics_info() {
  return array(
    'c4m_og_contributors' => array(
      'type'     => 'contributors',
      'context'  => 'group',
      'callback' => 'c4m_user_og_get_number_of_contributors',
      'weight'   => 9,
    ),
    'c4m_og_contributors_vs_pending_members' => array(
      'type'     => 'contributors_vs_pending_members',
      'context'  => 'group',
      'callback' => 'c4m_user_og_get_number_of_contributors_vs_pending_members',
      'weight'   => 13,
    ),
    'c4m_og_pending_members' => array(
      'type'     => 'pending_members',
      'context'  => 'group',
      'callback' => 'c4m_user_og_get_number_of_pending_members',
      'weight'   => 11,
    ),
    'c4m_og_users' => array(
      'type'     => 'users',
      'context'  => 'group',
      'callback' => 'c4m_og_group_user_metric',
      'weight'   => 7,
    ),
  );
}

/**
 * Implements hook_theme().
 */
function c4m_user_og_theme() {
  $theme['c4m_group_visitor_cta'] = array(
    'template' => 'c4m_group_visitor_cta',
    'path' => drupal_get_path('module', 'c4m_user_og') . '/templates',
    'variables' => array(
      'url' => NULL,
      'button_label' => NULL,
      'button_icon' => NULL,
    ),
  );

  $theme['c4m_unified_workflow_register'] = array(
    'template' => 'c4m_unified_workflow_register',
    'path' => drupal_get_path('module', 'c4m_user_og') . '/templates',
    'variables' => array(
      'group_title' => NULL,
      'login_link' => NULL,
    ),
  );

  $theme['c4m_unified_workflow_login'] = array(
    'template' => 'c4m_unified_workflow_login',
    'path' => drupal_get_path('module', 'c4m_user_og') . '/templates',
    'variables' => array(
      'group_title' => NULL,
    ),
  );

  return $theme;
}

/**
 * Implements hook_c4m_cta_block_alter().
 *
 * Set the CTA block for visitors.
 */
function c4m_user_og_c4m_cta_block_alter(&$block) {
  if (!user_is_anonymous()) {
    return;
  }

  if (!$group = c4m_og_current_group()) {
    return;
  }

  $access_type = c4m_og_get_access_type($group);
  if ($access_type['type'] != 'public') {
    return;
  }

  $types = array(
    'open' => array(
      'button_label' => 'Join this group',
      'button_icon' => 'fa-user-plus',
    ),
    'moderated' => array(
      'button_label' => 'Request membership for this group',
      'button_icon' => 'fa-unlock-alt',
    ),
  );

  $membership_request_value = c4m_og_get_group_membership_request($group);

  $variables = array(
    'button_label' => $types[$membership_request_value]['button_label'],
    'button_icon' => $types[$membership_request_value]['button_icon'],
    'url' => url('group/join/' . $group->nid),
  );

  $block['content'] = theme('c4m_group_visitor_cta', $variables);
}

/**
 * Implements hook_menu().
 */
function c4m_user_og_menu() {
  $items['group/join/%node/login'] = array(
    'title' => 'Login and Join group',
    'type' => MENU_CALLBACK,
    'page callback' => 'c4m_user_og_unified_workflow',
    'page arguments' => array(2, 'login'),
    'access callback' => '_ec_groups_access_login',
    'access arguments' => array(2),
    'file' => 'c4m_user_og.page.inc',
  );

  $items['group/join/%node'] = array(
    'title' => 'Join group',
    'type' => MENU_CALLBACK,
    'page callback' => 'c4m_user_og_unified_workflow',
    'page arguments' => array(2),
    'access callback' => 'node_access',
    'access arguments' => array('view', 2),
    'file' => 'c4m_user_og.page.inc',
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function c4m_user_og_form_user_register_form_alter(&$form, &$form_state, $form_id) {
  if (!isset($_SESSION['gid_join']) || !$gid = $_SESSION['gid_join']) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $gid);
  $variables = array(
    'group_title' => $wrapper->label(),
    'login_link' => l('Log in.', 'user/login'),
  );
  drupal_set_title(theme('c4m_unified_workflow_register', $variables), PASS_THROUGH);

  $form['#submit'][] = 'c4m_user_og_unified_workflow_register_submit';
  $form['actions']['submit']['#value'] = t('Register to join');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function c4m_user_og_form_user_login_alter(&$form, &$form_state, $form_id) {
  if (!isset($_SESSION['gid_join']) || !$gid = $_SESSION['gid_join']) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $gid);
  drupal_set_title(theme('c4m_unified_workflow_login', array('group_title' => $wrapper->label())), PASS_THROUGH);

  $form['#submit'][] = 'c4m_user_og_unified_workflow_login_submit';
  $form['actions']['submit']['#value'] = t('Login to join');
}

/**
 * A submit handler for the unified workflow (registration).
 *
 * Setting a message to the user and redirect back to the group.
 */
function c4m_user_og_unified_workflow_register_submit($form, &$form_state) {
  if (!isset($_SESSION['gid_join']) || !$gid = $_SESSION['gid_join']) {
    return;
  }

  $group = node_load($gid);
  // Removing the original message of the user_register_form.
  drupal_get_messages('status');
  $message = t(
    'Hey @name, thank you for submitting your details. Please activate your account by clicking the link sent to your e-mail to join the @group_title group.', array(
    '@name' => c4m_user_name($form_state['user']),
    '@group_title' => $group->title,
  ));

  drupal_set_message($message);
  $form_state['redirect'] = drupal_get_path_alias('node/' . $gid);

  // Adding the uid to the session so we can use it later.
  $_SESSION['gid_join_uid'] = $form_state['user']->uid;

  // Store the group ID + user ID in the database after registration completes.
  c4m_user_og_store_unified_workflow($form_state['user']->uid, $gid);

  // drupal_goto has a fallback to the 'destination' so we must remove it.
  unset($_GET['destination']);
}

/**
 * A submit handler for the unified workflow (login).
 *
 * Setting a message to the user and redirect back to the group.
 */
function c4m_user_og_unified_workflow_login_submit($form, &$form_state) {
  if (!isset($_SESSION['gid_join']) || !$gid = $_SESSION['gid_join']) {
    return;
  }

  $group = node_load($gid);
  $membership_request_value = c4m_og_get_group_membership_request($group);
  $messages = array(
    'open' => t('You are now a member of this group'),
    'moderated' => t('This is a moderated group. Your request is waiting for approval. Continue to explore group @group_title content', array('@group_title' => $group->title)),
  );
  $message = $messages[$membership_request_value];

  drupal_set_message($message);
  $form_state['redirect'] = drupal_get_path_alias('node/' . $gid);

  // drupal_goto has a fallback to the 'destination' so we must remove it.
  unset($_GET['destination']);

  // Associate the user to the group after login.
  $values = array(
    'state' => $membership_request_value == 'open' ? OG_STATE_ACTIVE : OG_STATE_PENDING ,
  );
  og_group('node', $gid, $values);

  // User is logged in, the session variable should be destroyed.
  unset($_SESSION['gid_join']);
}

/**
 * Implements hook_mail_alter().
 */
function c4m_user_og_mail_alter(&$message) {
  if (!isset($_SESSION['gid_join']) || !$gid = $_SESSION['gid_join']) {
    return;
  }

  if (empty($_SESSION['gid_join_uid'])) {
    return;
  }

  $user = user_load($_SESSION['gid_join_uid']);
  $group = node_load($gid);
  $path = drupal_get_path('module', 'c4m_user_og');

  $text = file_get_contents($path . '/messages/user_registrationpassword_register_to_group_body.html');
  $variables = array(
    'group' => $group,
    'user' => $user,
  );

  $message['body'] = token_replace(
    $text,
    $variables,
    array(
      'language' => user_preferred_language($user),
      'callback' => 'c4m_user_og_mail_tokens',
      'sanitize' => FALSE,
      'clear' => TRUE,
    )
  );

  // User is registered, and the variables are now stored in the database, the
  // session variables should be destroyed.
  unset($_SESSION['gid_join']);
  unset($_SESSION['gid_join_uid']);
}

/**
 * Store a group ID + user ID in the database.
 *
 * @param $uid
 *   The user ID.
 * @param $gid
 *   The group ID.
 */
function c4m_user_og_store_unified_workflow($uid, $gid) {
  try {
    db_insert('c4m_unified_workflow')
      ->fields(array(
        'uid' => $uid,
        'gid' => $gid,
      ))
      ->execute();
  }
  catch (PDOException $e) {
    // Duplicated entry.
    watchdog('c4m_unified_workflow', $e->errorInfo[2], array(), WATCHDOG_ERROR);
  }
}

/**
 * Fetch the entries for a specific user.
 *
 * @param $uid
 *   The user ID.
 *
 * @return array
 *   Array with the entries.
 */
function c4m_user_og_fetch_unified_workflow_entries($uid) {
  return db_select('c4m_unified_workflow', 'uw')
    ->fields('uw')
    ->condition('uid', $uid)
    ->execute()
    ->fetchAll();
}

/**
 * Token callback to add unsafe tokens for user mails.
 *
 * @see c4m_content_group_mail_tokens().
 * @see user_registrationpassword_mail_tokens().
 */
function c4m_user_og_mail_tokens(array &$replacements, array $data, $options) {
  c4m_content_group_mail_tokens($replacements, $data, $options);
  user_registrationpassword_mail_tokens($replacements, $data, $options);
}

/**
 * Implements hook_user_update().
 */
function c4m_user_og_user_update(&$edit, $account, $category) {
  if ($account->original->status || !$account->status) {
    return;
  }

  // Associate the user to the group.
  foreach (c4m_user_og_fetch_unified_workflow_entries($account->uid) as $entry) {
    $group = node_load($entry->gid);
    $membership_request_value = c4m_og_get_group_membership_request($group);
    $values = array(
      'entity' => user_load($entry->uid),
      'state' => $membership_request_value == 'open' ? OG_STATE_ACTIVE : OG_STATE_PENDING ,
    );
    og_group('node', $entry->gid, $values);
  }
}
