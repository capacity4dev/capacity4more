<?php

/**
 * @file
 * Code for the C4M notifications triggers.
 */

/**
 * Include handlers.
 */
module_load_include('inc', 'c4m_user_notifications', 'includes/c4m_user_notifications_handlers');

/**
 * Check if the current membership has access to the triggering system.
 *
 * An og_membership should get access to the triggering system if it is not
 * within a migration process and its entity_type is "user".
 *
 * @param object $og_membership
 *   The og_membership object.
 *
 * @return bool
 *   TRUE if the the membership is valid for access.
 */
function c4m_user_notifications_og_membership_trigger_access($og_membership) {
  // Don't send notifications during migration.
  if (!empty($og_membership->migrate)) {
    return FALSE;
  }

  // If the membership type is not 'user'.
  if (!isset($og_membership->entity_type) || $og_membership->entity_type != 'user') {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements hook_og_membership_insert().
 *
 * Triggers email notification on new membership request for moderated groups.
 */
function c4m_user_notifications_og_membership_insert($og_membership) {
  if (!c4m_user_notifications_og_membership_trigger_access($og_membership)) {
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open.
  $wrapper = entity_metadata_wrapper('node', $og_membership->gid);
  if (!isset($wrapper->field_membership_open_request)) {
    return;
  }

  if ($wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // If not moderated group, return early.
    return;
  }

  c4m_user_notifications_moderated_group_new_membership_request($og_membership);
}

/**
 * Implements hook_og_membership_update().
 *
 * Triggers email notification for membership update.
 *
 * Notified states:
 *   Pending -> Accepted
 *   Pending -> Rejected
 */
function c4m_user_notifications_og_membership_update($og_membership) {
  if (!c4m_user_notifications_og_membership_trigger_access($og_membership)) {
    return;
  }

  if (empty($og_membership->original)) {
    // Must have original state, as we're performing update.
    return;
  }

  if ($og_membership->original->state != OG_STATE_PENDING) {
    // State change has to be initiated when state is Pending.
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open.
  $wrapper = entity_metadata_wrapper('node', $og_membership->gid);
  if (!isset($wrapper->field_membership_open_request)) {
    return;
  }

  $moderated = $wrapper->field_membership_open_request->value();

  switch ($og_membership->state) {
    case OG_STATE_ACTIVE:
      if ($moderated == C4M_OG_MODERATED_GROUP) {
        // Membership acceptance notification to user, for open and moderated
        // group is the same (template MT13).
        c4m_user_notifications_notify_user_membership_accepted($og_membership);
        c4m_user_notifications_moderated_group_notify_admins_membership_accepted($og_membership);
      }
      elseif ($moderated == C4M_OG_OPEN_GROUP) {
        // Membership acceptance notification to user, for open and moderated
        // group is the same (template MT13).
        c4m_user_notifications_notify_user_membership_accepted($og_membership);
        c4m_user_notifications_open_group_notify_admins_membership_accepted($og_membership);
      }
      break;

    case OG_STATE_BLOCKED:
      if ($moderated == C4M_OG_MODERATED_GROUP) {
        c4m_user_notifications_moderated_group_notify_user_membership_rejected($og_membership);
      }
      break;
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Triggers email notification on membership cancellation request.
 */
function c4m_user_notifications_og_membership_delete($og_membership) {
  if (!c4m_user_notifications_og_membership_trigger_access($og_membership)) {
    return;
  }

  // Loading group/project to resolve it's membership type - moderated/open.
  $wrapper = entity_metadata_wrapper('node', $og_membership->gid);
  if (!isset($wrapper->field_membership_open_request)) {
    return;
  }

  if ($wrapper->field_membership_open_request->value() != C4M_OG_MODERATED_GROUP) {
    // If not moderated group, return early.
    return;
  }

  // Loading current user.
  global $user;

  if ($user->uid == $og_membership->etid) {
    // If current user is the one that's being removed.
    c4m_user_notifications_notify_admins_membership_canceled($og_membership);
  }
  else {
    // Membership was canceled by someone else -> group / site admin.
    c4m_user_notifications_notify_user_membership_canceled($og_membership);
  }
}

/**
 * Implements hook_node_insert().
 *
 * Triggers email notification for new node (group/project), for status
 * 'published'.
 */
function c4m_user_notifications_node_insert($node) {
  // Don't send notifications during migration.
  if (!empty($node->migrate)) {
    return;
  }

  _c4m_user_notifications_process_general_triggers_insert($node);
  _c4m_user_notifications_process_og_alter($node, 'insert');
  _c4m_user_notifications_process_og_content_alter($node, 'insert');
}

/**
 * Implements hook_node_update().
 *
 * Triggers email notification for node (group/project) status update.
 */
function c4m_user_notifications_node_update($node) {
  // Don't send notifications during migration.
  if (!empty($node->migrate)) {
    return;
  }

  _c4m_user_notifications_process_general_triggers_update($node);
  _c4m_user_notifications_process_og_alter($node, 'update');
  _c4m_user_notifications_process_og_content_alter($node, 'update');
}

/**
 * Implements hook_node_delete().
 *
 * Triggers email notification for node (group/project) delete.
 */
function c4m_user_notifications_node_delete($node) {
  // Don't send notifications during migration.
  if (!empty($node->migrate)) {
    return;
  }

  if (!og_is_group('node', $node)) {
    return;
  }

  c4m_user_notifications_group_hard_deleted($node);
}

/**
 * Implements hook_comment_insert().
 *
 * Triggers email notification for comment insert.
 */
function c4m_user_notifications_comment_insert($comment) {
  // Don't send notifications during migration.
  if (!empty($comment->migrate)) {
    return;
  }

  c4m_user_notifications_notify_user_commented($comment);
  c4m_user_notifications_notify_comment_on_content($comment);
}

/**
 * Implements hook_user_delete().
 *
 * Triggers email notification for node (group/project) delete.
 */
function c4m_user_notifications_user_delete($account) {
  // Don't send notifications during migration.
  if (!empty($account->migrate)) {
    return;
  }

  c4m_user_notifications_notify_admins_user_deleted($account);
}

/**
 * Implements hook_og_role_grant().
 *
 * Triggers email notification when user is promoted to administrator.
 */
function c4m_user_notifications_og_role_grant($entity_type, $gid, $uid, $rid) {
  $group_admin_role = c4m_og_user_role_load_by_name('administrator member', 'group');

  // Administrator role is not granted.
  if ($group_admin_role->rid != $rid) {
    return;
  }

  c4m_user_notifications_notify_user_admin_granted($gid, $uid);
  c4m_user_notifications_notify_admins_admin_granted($gid, $uid);
}

/**
 * Implements hook_og_role_revoke().
 *
 * Triggers email notification when user is revoked administrator role.
 */
function c4m_user_notifications_og_role_revoke($entity_type, $gid, $uid, $rid) {
  $group_admin_role = c4m_og_user_role_load_by_name('administrator member', 'group');

  // Administrator role is not revoked.
  if ($group_admin_role->rid == $rid) {
    return;
  }

  c4m_user_notifications_notify_user_admin_revoked($gid, $uid);
  c4m_user_notifications_notify_admins_admin_revoked($gid, $uid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Triggers email notification when user is invited to group by admin.
 */
function c4m_user_notifications_form_og_ui_add_users_alter(&$form, &$form_state) {
  // Remove request message and invitation option when adding a user to a group.
  $form['membership_fields'] = FALSE;

  // Add a checkbox for sending a welcome message.
  $form['og_user']['notifications'] = array(
    "#type" => "checkboxes",
    "#options" => array("Send a welcome email to the new user."),
    "#default_value" => array(0),
    "#title" => "Notifications",
  );

  // Add custom submit handler to process the form.
  $form['#submit'][] = 'c4m_user_notifications_notify_user_invited_by_admin';
}

/**
 * Implements hook_flag_flag().
 *
 * Triggers email notification when recommendation flag is set.
 */
function c4m_user_notifications_flag_flag($flag, $entity_id, $account, $flagging) {
  if ($flag->name != 'subscribe_c4m_follow_node') {
    // If not recommendation flag, return early.
    return;
  }

  c4m_user_notifications_notify_author_content_recommended($flag, $entity_id, $account, $flagging);
  c4m_user_notifications_notify_subscribed_editor_content_recommended($flag, $entity_id, $account, $flagging);
}

/**
 * Implements hook_cron().
 *
 * Activation reminder for inactive users.
 */
function c4m_user_notifications_cron() {
  c4m_user_notifications_notify_inactive_users();
}

/**
 * Helper function.
 *
 * Triggers email notification when organic group is published.
 */
function _c4m_user_notifications_process_general_triggers_insert($node) {
  if (!og_is_group('node', $node)) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->c4m_og_status)) {
    return;
  }

  $status = $wrapper->c4m_og_status->value();

  if ($status == 'published') {
    c4m_user_notifications_group_status_set_published($node);
  }
}

/**
 * Helper function.
 *
 * Triggers different email notifications when organic group is updated:
 *   Status - group status changes (published/draft/etc...).
 *   Access - group access changes.
 *   Owner - group owner changes.
 */
function _c4m_user_notifications_process_general_triggers_update($node) {
  if (!og_is_group('node', $node)) {
    // Return early, if node type is not group/project.
    return;
  }

  if (empty($node->original)) {
    // On node update, there must be $node->original.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper_original = entity_metadata_wrapper('node', $node->original);

  if (!isset($wrapper->c4m_og_status) || !isset($wrapper_original->c4m_og_status)) {
    return;
  }

  $status = $wrapper->c4m_og_status->value();
  $prev_status = $wrapper_original->c4m_og_status->value();
  if ($status != $prev_status) {
    // If group status has changed.
    switch ($status) {
      case 'published':
        if ($prev_status == 'archived' || $prev_status == 'unpublished' || $prev_status == 'deleted') {
          c4m_user_notifications_group_status_set_republished($node);
        }
        break;

      // Published -> Draft => Unpublished.
      case 'draft':
        if ($prev_status == 'published') {
          c4m_user_notifications_group_status_set_unpublished($node);
        }
        break;

      case 'archived':
        c4m_user_notifications_group_status_set_archived($node);
        break;

      // Soft delete.
      case 'deleted':
        c4m_user_notifications_group_status_set_softdeleted($node);
        break;
    }
  }

  if (!isset($wrapper->group_access) || !isset($wrapper_original->group_access)) {
    return;
  }

  $group_access = $wrapper->group_access->value();
  $prev_group_access = $wrapper_original->group_access->value();
  if ($group_access != $prev_group_access) {
    // If group access has changed (switch between Public
    // and Private/Restricted).
    c4m_user_notifications_group_access_changed($node);
  }
  elseif ($group_access == TRUE) {
    // Possible switch between Private and Restricted.
    $plug_node_access = empty($wrapper->pluggable_node_access->value());
    $prev_plug_node_access = empty($wrapper_original->pluggable_node_access->value());

    if ($plug_node_access != $prev_plug_node_access) {
      c4m_user_notifications_group_access_changed($node);
    }
    else {
      // Check if 'membership open' state was changed - part of group access
      // as well.
      $membership_open = $wrapper->field_membership_open_request->value();
      $prev_membership_open = $wrapper_original->field_membership_open_request->value();

      if ($membership_open != $prev_membership_open) {
        c4m_user_notifications_group_access_changed($node);
      }
    }
  }

  $group_owner = $node->uid;
  $prev_group_owner = $node->original->uid;
  if ($group_owner != $prev_group_owner) {
    c4m_user_notifications_notify_prev_owner_owner_update($node);
    c4m_user_notifications_notify_new_owner_owner_update($node);
    c4m_user_notifications_notify_admins_owner_update($node);
  }
}

/**
 * Helper function.
 *
 * Triggers email notification when organic group node is updated.
 * Per subscribe_c4m_follow_term flag.
 */
function _c4m_user_notifications_process_og_alter($node, $mode) {
  $allowed_og_types = array('group', 'project', 'event', 'article');
  if (!in_array($node->type, $allowed_og_types)) {
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->c4m_og_status)) {
    return;
  }

  $status = $wrapper->c4m_og_status->value();

  if ($status == 'published') {
    switch ($mode) {
      case 'insert':
        c4m_user_notifications_new_node_published($node);
        break;

      case 'update':
        c4m_user_notifications_existing_node_updated($node);
        break;
    }
  }
}

/**
 * Helper function.
 *
 * Triggers different email notifications when organic group content is updated.
 * Per subscribe_c4m_follow_group flag.
 */
function _c4m_user_notifications_process_og_content_alter($node, $mode) {
  if ($node->status != NODE_PUBLISHED) {
    return;
  }

  $allowed_og_content_types = array(
    'discussion',
    'document',
    'event',
    'wiki_page',
  );
  if (!in_array($node->type, $allowed_og_content_types)) {
    return;
  }

  // Load current node wrapper.
  $wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->{OG_AUDIENCE_FIELD}->c4m_og_status)) {
    return;
  }

  // If group is published.
  if ($wrapper->{OG_AUDIENCE_FIELD}->c4m_og_status->value() == 'published') {
    switch ($mode) {
      case 'insert':
        c4m_user_notifications_new_group_content_published($node);
        break;

      case 'update':
        c4m_user_notifications_existing_group_content_updated($node);
        break;
    }
  }
}
