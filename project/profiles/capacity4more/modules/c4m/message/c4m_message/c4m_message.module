<?php

/**
 * @file
 * Code for the Message feature.
 */

include_once 'c4m_message.features.inc';

/**
 * Implements hook_ctools_plugin_directory().
 */
function c4m_message_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_entity_insert().
 *
 * Delegate message creation for inserted entities.
 */
function c4m_message_entity_insert($entity, $entity_type) {
  c4m_message_crud_message($entity_type, $entity, 'insert');
}

/**
 * Implements hook_entity_update().
 *
 * Delegate message creation for inserted entities.
 */
function c4m_message_entity_update($entity, $entity_type) {
  c4m_message_crud_message($entity_type, $entity, 'update');
}

/**
 * Implements hook_mail_alter().
 *
 * Adds ability to alter message fields per message type.
 * Example:
 *   On the 'c4m_welcome_to_group' message type we set a special format at the
 *   'From' field.
 */
function c4m_message_mail_alter(&$message) {
  if (empty($message['params']['message_entity'])) {
    // There's no message entity inside - return early.
    return;
  }
  $message_entity = $message['params']['message_entity'];

  _c4m_message_format_welcome_to_group_from_field($message, $message_entity);
  _c4m_message_format_admin_demoted_from_field($message, $message_entity);
}

/**
 * Formats 'c4m_welcome_to_group' message From field, per MT10 template.
 */
function _c4m_message_format_welcome_to_group_from_field(&$message, $message_entity) {
  if ($message_entity->type != 'c4m_welcome_to_group') {
    // For message type other than c4m_welcome_to_group - return early.
    return;
  }

  // Set the 'From' format.
  $wrapper = entity_metadata_wrapper('message', $message_entity);
  $author = $wrapper->field_group_node->author->value();

  $message['from'] = format_string(
    '"@name at @site"<@mail>',
    array(
      '@name' => c4m_user_name($author),
      '@site' => variable_get('site_name'),
      '@mail' => $author->mail,
    )
  );
}

/**
 * Formats 'c4m_group_admin_demoted' message From field, per MT36 template.
 */
function _c4m_message_format_admin_demoted_from_field(&$message, $message_entity) {
  if ($message_entity->type != 'c4m_group_admin_demoted') {
    // For message type other than c4m_group_admin_demoted - return early.
    return;
  }

  _c4m_message_format_from_field_to_default_pattern($message);
}

/**
 * Helper function.
 *
 * Formats 'group change state' messages From field, per template requirement.
 */
function _c4m_message_format_group_status_update_set_from_field(&$message) {
  global $user;

  $message['from'] = format_string(
    '"@name at @site"<@mail>',
    array(
      '@name' => c4m_user_name($user),
      '@site' => variable_get('site_name'),
      '@mail' => variable_get('site_mail'),
    )
  );
}

/**
 * Helper function.
 *
 * Modifies messages 'From' field, to match pattern:
 * "[user_name] at [site_name]"<[email]>.
 * Example:  "Alan Turing"<alan@turing.com>.
 *
 * @param object $message
 *   Message entity.
 * @param object $account
 *   Account to resolve [user_name] and [email] from.
 */
function _c4m_message_format_from_field_to_default_pattern(&$message, $account = NULL) {
  if (!isset($account)) {
    // If $account is not provided, global user will be used.
    global $user;
    $account = $user;
  }

  $mail = $account->mail;

  $message['from'] = format_string(
    '"@name at @site"<@mail>',
    array(
      '@name' => c4m_user_name($account),
      '@site' => variable_get('site_name'),
      '@mail' => $mail,
    )
  );
}

/**
 * Helper function.
 *
 * Modifies messages 'From' field, to match pattern:
 * "[name]"<capacity4dev@ec.europa.eu>.
 *
 * @param object $message
 *   Message entity.
 * @param bool $add_team
 *   Whether to add 'team' into [name], or not.
 */
function _c4m_message_format_from_field_to_simple_pattern(&$message, $add_team = FALSE) {
  $name = variable_get('site_name');

  if ($add_team) {
    $name = 'The ' . $name . ' team';
  }

  $message['from'] = format_string(
    '"@name"<@mail>',
    array(
      '@name' => $name,
      '@mail' => 'capacity4dev@ec.europa.eu',
    )
  );
}

/**
 * Implements hook_entity_delete().
 *
 * @todo: Push item to queue.
 */
function c4m_message_entity_delete($entity, $entity_type) {
  $valid_entity_types = array(
    'comment',
    'node',
    'taxonomy_term',
    'og_membership',
  );

  if (!in_array($entity_type, $valid_entity_types)) {
    // Not an entity related to message.
    return;
  }

}

/**
 * Implements hook_entity_load().
 *
 * Add callbacks to the arguments. Instead of hardcoding them, we add those
 * arguments on the fly.
 */
function c4m_message_entity_load($entities, $entity_type) {
  if ($entity_type != 'message') {
    return;
  }

  foreach ($entities as $entity) {

    list(, , $bundle) = entity_extract_ids($entity_type, $entity);
    $func = 'c4m_message_load__' . $bundle;

    if (function_exists($func)) {
      // Call the delegated load function.
      $func($entity);
    }
  }
}

/**
 * Add callbacks to c4m_welcome_to_group message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_welcome_to_group(Message $message) {
  $message->arguments['@member_full_name'] = array(
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  );

  $message->arguments['!group_dashboard_url'] = array(
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  );

  $message->arguments['@group_node_title'] = array(
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  );

  $message->arguments['@group_welcome_message'] = array(
    'callback' => 'c4m_message_format_group_welcome_message',
    'pass message' => TRUE,
  );

  $message->arguments['@group_node_type'] = array(
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  );

  $message->arguments['!go_public_profile_url'] = array(
    'callback' => 'c4m_message_format_group_owner_public_profile_url',
    'pass message' => TRUE,
  );

  $message->arguments['@go_full_name'] = array(
    'callback' => 'c4m_message_format_group_owner_full_name',
    'pass message' => TRUE,
  );
}

/**
 * Add callbacks to c4m_log_group_admin_demoted message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_admin_demoted(Message $message) {
  $message->arguments['@member_full_name'] = array(
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  );

  $message->arguments['@group_node_title'] = array(
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  );

  $message->arguments['@group_node_type'] = array(
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  );

  $message->arguments['!group_dashboard_url'] = array(
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  );
}

/**
 * Returns message addressee user ID.
 *
 * @param Message $message
 *   The Message entity - used to retrieve required info.
 *
 * @return int
 *   Returns addressee's user ID.
 */
function c4m_message_format_addressee_uid(Message $message) {
  return $message->uid;
}

/**
 * Returns the of group message refers to.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   Returns group ID.
 */
function c4m_message_format_group_gid(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_node->value(array('identifier' => TRUE));
}

/**
 * Returns addressee full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns addressee's full name.
 */
function c4m_message_format_addressee_full_name(Message $message) {
  $user = user_load($message->uid);

  return c4m_user_name($user);
}

/**
 * Returns new member full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's full name.
 */
function c4m_message_format_new_member_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $new_member = $wrapper->field_related_user->value();

  return c4m_user_name($new_member);
}

/**
 * Returns new member organisation.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's organisation.
 */
function c4m_message_format_new_member_organisation(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_related_user->c4m_organisation->value();
}

/**
 * Returns new member organisation type.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's organisation type.
 */
function c4m_message_format_new_member_organisation_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_related_user->c4m_organisation_type->value();
}

/**
 * Returns new member country.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's country.
 */
function c4m_message_format_new_member_country(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $field = field_info_field('c4m_country');
  $allowed_values = list_allowed_values($field);

  return $allowed_values[$wrapper->field_related_user->c4m_country->value()];
}

/**
 * Returns new member expertise.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a comma separated string of member's expertise.
 */
function c4m_message_format_new_member_expertise(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $expertises = $wrapper->field_related_user->c4m_vocab_topic_expertise->value();
  $expertise_names = array();

  foreach ($expertises as $expertise) {
    $expertise_names[] = $expertise->name;
  }

  return implode(', ', $expertise_names);
}

/**
 * Returns new member self description.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's self description.
 */
function c4m_message_format_new_member_self_description(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return strip_tags($wrapper->field_related_user->c4m_body->value->value());
}

/**
 * Returns a link to new member membership management.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member membership management.
 */
function c4m_message_format_group_pending_member_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $gid = $wrapper->field_group_node->value(array('identifier' => TRUE));
  $mid = $wrapper->field_group_membership->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('group/node/' . $gid . '/admin/people/edit-membership/' . $mid, $options);
}

/**
 * Returns a link to new member public profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member public profile.
 */
function c4m_message_format_new_member_public_profile_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_related_user->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('user/' . $uid, $options);
}

/**
 * Returns a link to new member public profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member public profile.
 */
function c4m_message_format_new_member_request_message(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_membership->og_membership_request->value();
}

/**
 * Returns group owner full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group owner full name.
 * */
function c4m_message_format_group_owner_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $author = $wrapper->field_group_node->author->value();

  return c4m_user_name($author);
}

/**
 * Returns group url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group url.
 */
function c4m_message_format_group_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $nid = $wrapper->field_group_node->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('node/' . $nid, $options);
}

/**
 * Returns group title token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group title.
 */
function c4m_message_format_group_node_title(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_node->label();
}

/**
 * Returns group welcome message token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group welcome message.
 */
function c4m_message_format_group_welcome_message(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $group_message = $wrapper->field_group_node->c4m_group_welcome_message->value();

  return $group_message ? $group_message : '';
}

/**
 * Returns group node type token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group node type.
 */
function c4m_message_format_group_node_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $group_type = $wrapper->field_group_node->getBundle();

  return $group_type ? $group_type : '';
}

/**
 * Returns group message to admin token (entered by group requester).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return message to admin, which is entered by group requester.
 */
function c4m_message_format_group_message_to_admins(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  if (!isset($wrapper->field_group_node->field_message_to_site_admin)) {
    return '';
  }

  return $wrapper->field_group_node->field_message_to_site_admin->value();
}

/**
 * Returns group edit url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group edit url.
 */
function c4m_message_format_group_edit_status_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $nid = $wrapper->field_group_node->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('node/' . $nid . '/edit', $options);
}

/**
 * Returns group owner url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group owner url.
 */
function c4m_message_format_group_owner_public_profile_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $author_id = $wrapper->field_group_node->author->getIdentifier();

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('user/' . $author_id, $options);
}

/**
 * Returns the ID of user that executed the event.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   User ID.
 */
function c4m_message_format_event_user_id(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_executing_user->value(array('identifier' => TRUE));
}

/**
 * Returns full name of user that executed the event.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   User full name.
 */
function c4m_message_format_event_user_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return c4m_user_name($wrapper->field_executing_user->value());
}

/**
 * Returns a link to event user contact page.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to event user contact page.
 */
function c4m_message_format_event_user_message_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_executing_user->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('user/' . $uid . '/contact', $options);
}

/**
 * Returns a link to event user profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to event user public profile.
 */
function c4m_message_format_event_user_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_executing_user->value(array('identifier' => TRUE));

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('user/' . $uid, $options);
}

/**
 * Returns the title of attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node title.
 */
function c4m_message_format_node_title(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_node->label();
}

/**
 * Returns the type of attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node type.
 */
function c4m_message_format_node_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_node->value()->type;
}

/**
 * Returns the path to attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node path.
 */
function c4m_message_format_node_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('node/' . $wrapper->field_node->value(array('identifier' => TRUE)), $options);
}

/**
 * Returns number of times attached node was recommended.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   Number of recommendations.
 */
function c4m_message_format_node_recommend_count(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $property_info = array(
    'flag_name' => 'c4m_og_content_recommend',
  );
  $count = c4m_helper_entity_entity_get_properties($node, array(), '', 'node', $property_info);

  return empty($count) ? 0 : $count;
}

/**
 * Returns a teaser of nodes body.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node body teaser.
 */
function c4m_message_format_node_body_teaser(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();
  if (empty($node->c4m_body)) {
    return '';
  }

  $body_teaser = field_view_field('node', $node, 'c4m_body', 'teaser');

  return strip_tags($body_teaser[0]['#markup']);
}

/**
 * Returns a teaser of nodes body.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node body teaser.
 */
function c4m_message_format_comment_body_teaser(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $comment = $wrapper->field_comment->value();
  $body_teaser = field_view_field('comment', $comment, 'comment_body', 'teaser');

  return strip_tags($body_teaser[0]['#markup']);
}

/**
 * Returns a url that is used to unsubscribe from following flagged node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_node_unsubscribe_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'node');
}

/**
 * Returns a url that is used to unsubscribe from following content comments.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_unsubscribe_content_comments_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'comment');
}

/**
 * Returns a url that is used to unsubscribe from following a group.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_unsubscribe_group_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'group');
}

/**
 * Helper function.
 *
 * Returns a url that is used to unsubscribe from following an entity that is
 * embedded inside message.
 *
 * @param Message $message
 *   The Message entity.
 * @param string $flag_suffix
 *   The suffix of flag that is used to track message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function _c4m_message_format_unsubscribe_url(Message $message, $flag_suffix) {
  $wrapper = entity_metadata_wrapper('message', $message);

  // Group field at message is 'field_group_node'.
  $field_suffix = $flag_suffix == 'group' ? 'group_node' : $flag_suffix;
  $field = "field_{$field_suffix}";
  $nid = $wrapper->$field->value(array('identifier' => TRUE));
  if ($flag_suffix == 'comment') {
    // The identifier we got is actually cid. Need to get the correct one.
    $comment = comment_load($nid);
    $nid = $comment->nid;
  }

  $uid = $message->uid;
  $account = user_load($uid);
  $wrapper = entity_metadata_wrapper('user', $account);
  $hash = $wrapper->c4m_unsubscribe_hash->value();

  $options = array(
    'absolute' => TRUE,
    'purl' => array('disabled' => TRUE),
  );

  return url('user/' . $uid . '/unsubscribe/' . $flag_suffix . '/' . $nid . '/' . $hash, $options);
}

/**
 * Delegate message CRUD to message type specific functions.
 *
 * @param string $entity_type
 *   The entity type.
 * @param object $entity
 *   The entity object.
 * @param string $op
 *   The operation to perform. Possible values are "insert" or "update".
 *
 * @return void|Message
 *   The saved message object, or NULL if not created or updated.
 */
function c4m_message_crud_message($entity_type, $entity, $op) {
  // Do not create a message if no user is associated with the entity.
  if (!isset($entity->uid) || (isset($entity->uid) && $entity->uid < 1)) {
    $entity->_skip_message = TRUE;
  }

  if (!empty($entity->_skip_message)) {
    // Entity should not create a message.
    return FALSE;
  }

  $valid_entity_types = array(
    'comment',
    'node',
    'taxonomy_term',
    'og_membership',
  );

  $valid_node_types = array(
    'discussion',
    'event',
    'photo',
    'photoalbum',
    'share',
    'document',
    'wiki_page',
  );

  // Hide message for the type 'article' when the operation 'update' happened.
  if ($op != 'update') {
    array_push($valid_node_types, 'article');
  }

  if (!in_array($entity_type, $valid_entity_types)) {
    // Not an entity related to message.
    return NULL;
  }
  if ($entity_type == 'node' && !in_array($entity->type, $valid_node_types)) {
    // Don't have to create message for this node type.
    return NULL;
  }

  $message = NULL;

  $func = 'c4m_message__' . $op . '__' . $entity_type;
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $bundle_func = $func . '__' . $bundle;

  if (function_exists($bundle_func)) {
    // Call the bundle specific function.
    $message = $bundle_func($entity);
  }
  elseif (function_exists($func)) {
    // Call the entity specific function.
    $message = $func($entity);
  }

  if ($message) {
    $message_wrapper = entity_metadata_wrapper('message', $message);
    $message_wrapper->field_entity_published->set($entity->status);
    if (isset($message_wrapper->field_operation)) {
      $message_wrapper->field_operation->set($op);
    }
    $message->save();
  }

  return $message;
}

/**
 * A general function to add arguments for node related messages.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_general_arguments(Message $message) {
  $message->arguments['!date'] = array(
    'callback' => 'c4m_message_format_date_for_message',
    'pass message' => TRUE,
  );

  $message->arguments['!group_info'] = array(
    'callback' => 'c4m_messages_group_info',
    'pass message' => TRUE,
  );
}

/**
 * Replace the date value of a message with a formatted value.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The formatted date.
 */
function c4m_message_format_date_for_message(Message $message) {
  $format = variable_get('date_format_c4m_long_without_time', 'j F Y H:i');
  $rel_date = c4m_helper_date_time_ago($message->timestamp, $format, 16070400);
  $abs_date = format_date($message->timestamp, 'custom', $format);

  return '<span data-toggle="tooltip" data-placement="bottom" title="' . $abs_date . '">' . $rel_date . '</span>';
}

/**
 * Get group info for activity stream.
 *
 * @param Message $message
 *    The message object.
 *
 * @return string
 *    The group info.
 *
 * @throws \EntityMetadataWrapperException
 *    Throws EntityMetadataWrapperException error.
 */
function c4m_messages_group_info(Message $message) {
  $group_info = '';
  $get_query = drupal_get_query_parameters();

  // Add group info for activity stream on the homepage,
  // When the request is from RESTful, "drupal_is_front_page" won't work.
  $handler = og_purl_og_context_handler();
  if (((drupal_is_front_page() || !empty($get_query['homepage']))
    && empty($handler) || (isset($get_query['group'])
      && is_array($get_query['group'])))
  ) {
    if (isset($message->field_group_node) && !empty($message->field_group_node)) {
      $wrapper = entity_metadata_wrapper(
        'node',
        $message->field_group_node[LANGUAGE_NONE][0]['target_id']
      );
      $link = l($wrapper->label(), $wrapper->value()->purl);
      $group_info = t('Group: !link', array('!link' => $link));
    }
  }

  return $group_info;
}

/**
 * Delegated hook_entity_load() for node of "discussion" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__discussion(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "article" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__article(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "wiki_page" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__wiki_page(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "document" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__document(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "photo" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__photo(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['@photoalbum'] = array(
    'callback' => 'c4m_message_format_photo_photoalbum',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "share" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__share(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );
  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_node_share',
    'pass message' => TRUE,
  );

  $message->arguments['!group'] = array(
    'callback' => 'c4m_message_format_group_share',
    'pass message' => TRUE,
  );

  $message->arguments['!group_original'] = array(
    'callback' => 'c4m_message_format_original_group_share',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "photoalbum" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__photoalbum(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for node of "event" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__event(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  );

  $message->arguments['@operation'] = array(
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Delegated hook_entity_load() for comment.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__comment(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@node_type'] = array(
    'callback' => 'c4m_message_format_comment',
    'pass message' => TRUE,
  );

  $message->arguments['!content'] = array(
    'callback' => 'c4m_message_format_rendered_comment',
    'pass message' => TRUE,
  );

  $message->arguments['!icon'] = array(
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  );
}

/**
 * Return the formatted operation name (added or updated).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The action text.
 */
function c4m_message_format_operation(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $operation = $wrapper->field_operation->value();
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  switch ($operation) {
    case 'insert':
      $op = $info['insert action'];
      break;

    case 'update':
    default:
      $op = $info['update action'];
      break;
  }

  return $op;
}

/**
 * Return the photoalbum title of the inserted photo.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The photoalbum if exists or an empty string.
 */
function c4m_message_format_photo_photoalbum(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $album_label = $wrapper->field_node->node_gallery_ref_1->label();

  return $album_label ? 'to Photo album ' . $album_label : '';
}

/**
 * Return the formatted node type.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The Comment type.
 */
function c4m_message_format_comment(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  return format_string(
    '@article @node_type',
    array('@article' => $info['article'], '@node_type' => $info['singular'])
  );
}

/**
 * Return the formatted body and image.
 *
 * We get the body and image on te fly, in case a user edited the content - not
 * to show an outdated teaser.
 * We use a view mode to control the rendered node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The formated string.
 */
function c4m_message_format_rendered_node(Message $message) {
  $get_query = drupal_get_query_parameters();
  $wrapper = entity_metadata_wrapper('message', $message);

  $handler = og_purl_og_context_handler();
  if ((empty($get_query['homepage'])) && !empty($handler)) {
    $view = node_view($wrapper->field_node->value(), 'activity_group');
  }
  else {
    $view = node_view($wrapper->field_node->value(), 'activity_global');
  }

  return drupal_render($view);
}

/**
 * Return the formatted body and image.
 *
 * Retrieve proper icon for a content type (and maybe subtype).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_node_icon(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  $icon_tag = array(
    '#type' => 'html_tag',
    '#tag' => 'i',
    '#value' => '',
    '#attributes' => array('class' => array('fa', $info['icon'])),
  );

  return drupal_render($icon_tag);
}

/**
 * Return the formatted "shared to" group info.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_group_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $group_wrapper = entity_metadata_wrapper(
    'node',
    $wrapper->field_node->og_group_ref->value()
  );

  $url_options = array(
    'absolute' => TRUE,
    'purl' => array(
      'provider' => 'og_purl|node',
      'id' => $group_wrapper->nid->value(),
    ),
  );

  return t(
    '@group_type !group_url',
    array(
      '@group_type' => $group_wrapper->getBundle(),
      '!group_url' => l(
        $group_wrapper->title->value(),
        url('<front>', $url_options)
      ),
    )
  );
}

/**
 * Return the formatted "original group".
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_original_group_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $original_entity = entity_metadata_wrapper(
    'node',
    $wrapper->field_node->c4m_source_entity->value()
  );
  $group_wrapper = entity_metadata_wrapper(
    'node',
    $original_entity->og_group_ref->value()
  );

  return l(
    $group_wrapper->title->value(),
    url(
      'node/' . $group_wrapper->get('nid')->value(),
      array('purl' => array('disabled' => FALSE))

    )
  );
}

/**
 * Return the formatted share operation.
 *
 * Retrieve proper icon for a content type (and maybe subtype).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_node_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $original_node = $wrapper->field_node->c4m_source_entity->value();

  $info = c4m_helper_entity_label_info($original_node);

  return t(
    'shared @article @node_type',
    array('@article' => $info['article'], '@node_type' => $info['singular'])
  );
}

/**
 * Return the body of the comment.
 *
 * @param Message $message
 *    The message object.
 *
 * @return string
 *    Rendered comment.
 */
function c4m_message_format_rendered_comment(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $view = comment_view(
    $wrapper->field_comment->value(),
    $wrapper->field_node->value(),
    'activity_global'
  );

  return drupal_render($view);
}

/**
 * Create a comment message.
 *
 * @param object $comment
 *   The comment object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__insert__comment($comment) {
  $values = array('uid' => $comment->uid);
  $message = message_create('c4m_insert__comment', $values);

  $node = node_load($comment->nid);
  c4m_message_prepare_insert_entity($message, 'node', $node);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->field_comment->set($comment);

  return $message;
}

/**
 * Updating a comment message.
 *
 * @param object $comment
 *   The comment object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__update__comment($comment) {
  $time_since = time() - variable_get('c4m_message_join_messages', '3600');

  // Load existing message that is not older then 6 hours for the current node.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'message')
    ->propertyCondition('type', 'c4m_insert__comment')
    ->propertyCondition('timestamp', $time_since, '>')
    ->fieldCondition('field_node', 'target_id', $comment->nid)
    ->fieldCondition('field_comment', 'target_id', $comment->cid)
    ->propertyOrderBy('timestamp', 'desc')
    ->range(0, 1)
    ->execute();

  $message = NULL;
  if (!empty($result['message'])) {
    $id = key($result['message']);
    $message = message_load($id);
  }

  if (!$message) {
    // Message doesn't exist - create a new message.
    $values = array('uid' => $comment->uid);
    $message = message_create('c4m_insert__comment', $values);
  }
  $node = node_load($comment->nid);
  c4m_message_prepare_insert_entity($message, 'node', $node);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->field_comment->set($comment);

  return $message;
}

/**
 * Create a node message.
 *
 * @param object $node
 *   The node object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__insert__node($node) {
  $values = array('uid' => $node->uid);
  $message = message_create('c4m_insert__node__' . $node->type, $values);

  c4m_message_prepare_insert_entity($message, 'node', $node);

  return $message;
}

/**
 * Updating a node message.
 *
 * @param object $node
 *   The node object.
 * @param object $account
 *   The user object.
 *
 * @return Message
 *   The non-saved message entity, or NULL if update shouldn't occur.
 */
function c4m_message__update__node($node, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = clone $user;
  }

  if ($account->uid == 0) {
    // Drush has user "0". Assign updates to the original node creator.
    $account = user_load($node->uid);
  }

  $time_since = time() - variable_get('c4m_message_join_messages', '3600');
  // Load existing message that is not older then 6 hours for the current node.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'message')
    ->propertyCondition('type', 'c4m_insert__node__' . $node->type)
    ->propertyCondition('timestamp', $time_since, '>')
    ->fieldCondition('field_node', 'target_id', $node->nid)
    ->propertyOrderBy('timestamp', 'desc')
    ->range(0, 1)
    ->execute();

  $message = NULL;
  if (!empty($result['message'])) {
    $id = key($result['message']);
    $message = message_load($id);
    $wrapper = entity_metadata_wrapper('message', $message);

    if ($message->uid == $user->uid) {
      if ($wrapper->field_operation->value() == 'update') {
        // When an existing item is updated within 6 hours after the PREVIOUS
        // UPDATE by the SAME user who did the last update.
        $message->timestamp = $node->timestamp;
      }
      else {
        // When an existing item is updated within 6 hours after the initial
        // insert by the SAME user.
        return FALSE;
      }
    }
    else {
      // Need to create new message, not to update existing one.
      $values = array(
        'uid' => $account->uid,
        'timestamp' => $node->timestamp,
      );
      $message = message_create(
        'c4m_insert__node__' . $node->type,
        $values,
        $account
      );
    }
  }
  else {
    // More than 6 hours last - need to create a new message.
    $values = array(
      'uid' => $account->uid,
      'timestamp' => $node->timestamp,
    );
    $message = message_create(
      'c4m_insert__node__' . $node->type,
      $values,
      $account
    );
  }
  if ($message) {
    c4m_message_prepare_insert_entity($message, 'node', $node);
  }

  return $message;
}

/**
 * Set the message fields values.
 *
 * @param Message $message
 *    The message entity.
 * @param string $entity_type
 *    The entity type.
 * @param object $entity
 *    The Entity for we create/update message.
 */
function c4m_message_prepare_insert_entity(
  Message &$message,
  $entity_type,
  $entity
) {
  $message_wrapper = entity_metadata_wrapper('message', $message);
  if ($entity_type != 'node') {
    return;
  }

  $node_wrapper = entity_metadata_wrapper($entity_type, $entity);
  $node = $entity;

  $message_wrapper->field_node->set($node);

  if (!isset($node_wrapper->{OG_AUDIENCE_FIELD})) {
    return;
  }

  if (!$node_wrapper->{OG_AUDIENCE_FIELD}->value()) {
    return;
  }

  $group_id = $node_wrapper->{OG_AUDIENCE_FIELD}->value(
    array('identifier' => TRUE)
  );
  $message_wrapper->field_group_node->set($group_id);
}

/**
 * Node preprocess.
 */
function c4m_message_preprocess_node(&$variables) {
  if ($variables['view_mode'] == 'activity_group' || $variables['view_mode'] == 'activity_global') {
    $variables['theme_hook_suggestions'][] = 'node__activity_stream';
    $variables['theme_hook_suggestions'][] = 'node__' . $variables['node']->type . '__activity_stream';
  }
  $preprocess_function = "c4m_message_preprocess_node__{$variables['node']->type}";
  if (function_exists($preprocess_function)) {
    $preprocess_function($variables);
  }
}

/**
 * Node document preprocess.
 */
function c4m_message_preprocess_node__document(&$variables) {
  if ($variables['view_mode'] != 'activity_group' && $variables['view_mode'] != 'activity_global') {
    // Current view mode is not an 'activity stream'.
    return;
  }

  $node = $variables['node'];
  $node_wrapper = entity_metadata_wrapper('node', $node);

  $document = $node_wrapper->c4m_document->value();
  if (empty($document)) {
    // There is no file.
    $variables['download_link'] = '';
    $variables['file_info'] = '';
    return;
  }

  $file_uri = file_load($document['fid']);
  $download = file_entity_download_uri($file_uri);
  $variables['download_link'] = l(
    t('Download this Document'),
    $download['path'],
    $download['options']
  );
  $file_size = format_size($document['filesize']);
  $file_type = $document['type'];
  $variables['file_info'] = t(
    'Filetype: @filetype | Filesize: @filesize',
    array('@filetype' => $file_type, '@filesize' => $file_size)
  );
}

/**
 * Node event preprocess.
 */
function c4m_message_preprocess_node__event(&$variables) {
  if ($variables['view_mode'] != 'activity_group' && $variables['view_mode'] != 'activity_global') {
    // Current view mode is not an 'activity stream'.
    return;
  }

  $node = $variables['node'];
  $node_wrapper = entity_metadata_wrapper('node', $node);

  $start = $node_wrapper->c4m_datetime_end->value->value();
  $end = $node_wrapper->c4m_datetime_end->value2->value();

  $start_date = format_date($start, 'custom', 'd/m/Y');
  $end_date = format_date($end, 'custom', 'd/m/Y');

  $start_date_time = format_date($start, 'custom', 'd/m/Y H:i');
  $end_date_time = $start_date == $end_date
    ? format_date($end, 'custom', 'H:i')
    : format_date($end, 'custom', 'd/m/Y H:i');

  $variables['event_info'] = t(
    'From @start to @end',
    array('@start' => $start_date_time, '@end' => $end_date_time)
  );
}

/**
 * Adds the activity stream to the AngularJs app.
 *
 * Depending on if the user is logged in or not,
 * The activity stream is loaded from the user's groups,
 * Or from all the public groups if user is anonymous.
 */
function c4m_message_load_homepage_activity_stream() {
  global $user;
  $get_query = drupal_get_query_parameters();

  // Get filter value.
  $filter = !empty($get_query['filter'])
    ? $get_query['filter']
    : '';
  $groups = array();
  $interests = array();
  $hide_articles = $filter == 'groups'
    ? 1
    : 0;
  $group_context = (bool) og_context();

  // Checks if this is an Authenticated user.
  if ($user->uid) {
    switch ($filter) {
      case 'groups':
        // Gets all the group IDs that the user belongs to.
        $groups = c4m_og_get_user_group_nodes_by_bundle('group');
        break;

      case 'projects':
        // Gets all the project IDs that the user belongs to.
        $groups = c4m_og_get_user_group_nodes_by_bundle('project');
        break;

      case 'interests':
        $hide_articles = 0;
        // Get user's interests.
        $user_wrapper = entity_metadata_wrapper('user', $user->uid);
        $interests = $user_wrapper->c4m_vocab_topic->raw();

        // Get groups that have topics from user's interests
        // but user is not member of these groups (we already have this list).
        $query = new EntityFieldQuery();

        $query
          ->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'group')
          ->propertyCondition('status', NODE_PUBLISHED);
        if (!empty($groups)) {
          $query->propertyCondition('nid', $groups, 'NOT IN');
        }
        if (!empty($interests)) {
          $query->fieldCondition('c4m_vocab_topic', 'tid', $interests, 'IN');
        }

        $result = $query->execute();

        if (!empty($result['node'])) {
          $groups = array_merge($groups, array_keys($result['node']));
        }
        break;
    }
  }

  $activity_stream_handler = restful_get_restful_handler('activity_stream');

  $request = array(
    'group' => $groups,
    'topics' => $interests,
    'html' => TRUE,
    // Sort the activity stream by timestamp descending.
    'sort' => '-timestamp',
    'homepage' => 1,
    'hide_articles' => $hide_articles,
    'group_context' => $group_context,
  );

  $activities = $activity_stream_handler->get('', $request);

  // URL options.
  $options = array(
    'purl' => array(
      'disabled' => TRUE,
    ),
    'absolute' => TRUE,
  );

  // Pass info via Drupal.settings.
  $settings['c4m'] = array(
    'basePath' => url('', $options),
    'csrfToken' => drupal_get_token(\RestfulInterface::TOKEN_VALUE),
    'activities' => $activities,
    'data' => array(
      'request' => $request,
      'entity' => array('group' => $groups),
    ),
  );
  drupal_add_js($settings, 'setting');
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Changes the join of the group field to "LEFT" join,
 * So it's possible to get messages without this field,
 * Also changes the condition from AND to OR.
 * (field group has those values OR is null).
 */
function c4m_message_query_activity_stream_homepage_alter(SelectQuery &$query) {
  $tables = &$query->getTables();
  $conditions = &$query->conditions();

  $tables['field_data_field_group_node1']['join type'] = 'LEFT';
  $values = $conditions[1]['value'];
  $or = db_or()
    ->condition('field_group_node_target_id', $values, 'IN')
    ->isNull('field_group_node_target_id');
  $query->condition($or);

  foreach ($conditions as $key => $condition) {
    if (isset($condition['field']) && !is_object(
        $condition['field']
      ) && $condition['field'] == 'field_data_field_group_node1.field_group_node_target_id'
    ) {
      unset($conditions[$key]);
    }
  }
}

/**
 * Alter field access for activity stream entities.
 *
 * @param \SelectQuery $query
 *    The query to be altered.
 */
function c4m_message_query_activity_stream_entity_field_access_alter(
  SelectQuery &$query
) {
  $query->addMetaData('base_table', 'field_data_field_group_node');

  global $user;

  // Read meta-data from query, if provided.
  if (!$account = $query->getMetaData('account')) {
    $account = $user;
  }
  if (!$op = $query->getMetaData('op')) {
    $op = 'view';
  }

  // If $account can bypass node access, or there are no node access modules,
  // or the operation is 'view' and the $account has a global view grant
  // (such as a view grant for node ID 0), we don't need to alter the query.
  if (user_access('bypass node access', $account)) {
    return;
  }
  if (!count(module_implements('node_grants'))) {
    return;
  }
  if ($op == 'view' && node_access_view_all_nodes($account)) {
    return;
  }

  $tables = $query->getTables();
  $base_table = $query->getMetaData('base_table');

  // Find all instances of the base table being joined -- could appear
  // more than once in the query, and could be aliased. Join each one to
  // the node_access table.
  $grants = node_access_grants($op, $account);

  $node_conditions = db_and();

  foreach ($tables as $nalias => $tableinfo) {
    $table = $tableinfo['table'];
    if (!($table instanceof SelectQueryInterface) && $table == $base_table) {
      // Set the subquery.
      $subquery = db_select('node_access', 'na')
        ->fields('na', array('nid'));

      $grant_conditions = db_or();
      // If any grant exists for the specified user, then user has access
      // to the node for the specified operation.
      foreach ($grants as $realm => $gids) {
        foreach ($gids as $gid) {
          $grant_conditions->condition(
            db_and()
              ->condition('na.gid', $gid)
              ->condition('na.realm', $realm)
          );
        }
      }

      // Attach conditions to the subquery for nodes.
      if (count($grant_conditions->conditions())) {
        $subquery->condition($grant_conditions);
      }
      $subquery->condition('na.grant_' . $op, 1, '>=');
      $field = 'nid';
      // Now handle entities.
      // Set a common alias for entities.
      $base_alias = $nalias;
      $field = 'field_group_node_target_id';
      $subquery->where("$nalias.$field = na.nid");

      // For an entity query, attach the subquery to entity conditions.
      $node_conditions->exists($subquery);
    }

    // Needed for the sharing functionality,
    // which adds node access on node level.
    if (!($table instanceof SelectQueryInterface) && $table == 'node') {
      if (!node_access_view_all_nodes()) {
        // Prevent duplicates records.
        $query->distinct();
        // The recognized operations are 'view', 'update', 'delete'.
        if (!$op = $query->getMetaData('op')) {
          $op = 'view';
        }
        // Skip the extra joins and conditions for node admins.
        if (!user_access('bypass node access')) {
          // The node_access table has the access grants for any given node.
          $access_alias = $query->join(
            'node_access',
            'na',
            '%alias.nid = node.nid'
          );
          $or = db_or();
          // If any grant exists for the specified user,
          // then user has access to the node for the specified operation.
          foreach (node_access_grants(
                     $op,
                     $query->getMetaData('account')
                   ) as $realm => $gids) {
            foreach ($gids as $gid) {
              $or->condition(
                db_and()
                  ->condition($access_alias . '.gid', $gid)
                  ->condition($access_alias . '.realm', $realm)
              );
            }
          }

          if (count($or->conditions())) {
            $query->condition($or);
          }

          $query->condition($access_alias . '.grant_' . $op, 1, '>=');
        }
      }
    }
  }

  if (count($subquery->conditions())) {
    // All the node access conditions are only for field values belonging to
    // nodes.
    $node_conditions->condition("$base_alias.entity_type", 'message');
    $or = db_or();
    $or->condition($node_conditions);
    // If the field value belongs to a non-node entity type then this function
    // does not do anything with it.
    $or->condition("$base_alias.entity_type", 'message', '<>');
    $or->isNull('gn.field_group_node_target_id');
    // Add the compiled set of rules to the query.
    $query->condition($or);
  }
}

/**
 * Implements hook_c4m_helper_entity_metrics_info().
 */
function c4m_message_c4m_helper_entity_metrics_info() {
  return array(
    'c4m_user_last_activity' => array(
      'type' => 'last_activity',
      'context' => 'user',
      'callback' => 'c4m_message_get_user_last_activity',
    ),
  );
}

/**
 * Returns the date & time of the last activity of an user.
 *
 * @param int $uid
 *   User ID.
 *
 * @return string
 *   Date.
 */
function c4m_message_get_user_last_activity($uid) {
  $query = db_select('message', 'm');
  $query->fields('m', array('timestamp'));
  $query->condition('uid', $uid);
  $query->orderBy('timestamp', 'DESC');
  $query->range(0, 1);

  $query = $query->execute();
  $amount = $query->fetchCol();

  if ($amount) {
    return date('d/m/Y H:i', $amount[0]);
  }
  else {
    return '';
  }
}
