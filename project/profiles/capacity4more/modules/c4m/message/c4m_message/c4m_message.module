<?php

/**
 * @file
 * Code for the Message feature.
 */

include_once 'c4m_message.features.inc';

define('C4M_MESSAGE_EXPIRE_TIME', 12000);

/**
 * Implements hook_ctools_plugin_directory().
 */
function c4m_message_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Clear activity stream cache when deleting entities related to messages.
 *
 * @todo Push item to queue. Is this still a requirement? The message module
 *   does delete the messages referencing the current entity in
 *   message_entity_delete().
 */
function c4m_message_entity_delete($entity, $entity_type) {
  if (!c4m_message_handle_entity($entity, $entity_type, 'delete') && $entity_type !== 'message') {
    return;
  }
  _c4m_message_clear_activity_stream_cache();
}

/**
 * Implements hook_entity_insert().
 *
 * Delegate message creation for inserted entities.
 */
function c4m_message_entity_insert($entity, $entity_type) {
  c4m_message_crud_message($entity_type, $entity, 'insert');
}

/**
 * Implements hook_entity_update().
 *
 * Delegate message creation for inserted entities.
 */
function c4m_message_entity_update($entity, $entity_type) {
  c4m_message_crud_message($entity_type, $entity, 'update');

  // Clear activity stream cache when modifying group status.
  if ($entity_type === 'node' && $entity->type === 'group') {
    $different_group_status = $entity->c4m_og_status[LANGUAGE_NONE][0]['value'] != $entity->original->c4m_og_status[LANGUAGE_NONE][0]['value'];
    $different_group_access = $entity->group_access[LANGUAGE_NONE][0]['value'] != $entity->original->group_access[LANGUAGE_NONE][0]['value'];
    if ($different_group_status || $different_group_access) {
      _c4m_message_clear_activity_stream_cache();
    }
  }
}

/**
 * Formats the default from field as "capacity4dev <site_mail>".
 *
 * @param object $message
 *   Drupal Message entity object.
 */
function _c4m_message_format_from_website($message) {
  _c4m_message_format_from_field_to_simple_pattern($message, FALSE);
}

/**
 * Formats the from field as "The capacity4dev team <site_mail>".
 *
 * @param object $message
 *   Drupal Message entity object.
 */
function _c4m_message_format_from_the_team($message) {
  $message_entity = $message['params']['message_entity'];

  $valid_message_types = [
    'c4m_group_request_approved' => TRUE,
    'c4m_group_request_submitted' => TRUE,
    'c4m_new_member_joined' => TRUE,
    'c4m_new_membership_request' => TRUE,
  ];

  if (!empty($valid_message_types[$message_entity->type])) {
    _c4m_message_format_from_field_to_simple_pattern($message, TRUE);
  }
}

/**
 * Formats the from field as "Firstname Lastname <site_mail>".
 *
 * @param object $message
 *   Drupal Message entity object.
 */
function _c4m_message_format_from_user_first_last($message) {
  $message_entity = $message['params']['message_entity'];

  $valid_message_types = [
    'c4m_content_updated' => TRUE,
    'c4m_notify_admins_membership_approved' => TRUE,
    'c4m_group_published' => TRUE,
    'c4m_group_archived' => TRUE,
    'c4m_group_access_change' => TRUE,
    'c4m_group_unpublished' => TRUE,
    'c4m_group_republished' => TRUE,
    'c4m_group_admin_demoted' => TRUE,
    'c4m_notify_content_recommendation' => TRUE,
    'c4m_new_content_published' => TRUE,
    'c4m_group_content_updated' => TRUE,
    'c4m_notify_editors_group_content_updated' => TRUE,
    'c4m_notify_subscribers_new_comment' => TRUE,
    'c4m_group_hard_deleted' => TRUE,
    'c4m_group_soft_deleted' => TRUE,
    'c4m_notify_promoted_member' => TRUE,
    'c4m_notify_content_followers_new_comment' => TRUE,
    'c4m_membership_request_rejected' => TRUE,
    'c4m_welcome_to_group' => TRUE,
    'c4m_new_content_share_published' => TRUE,
    'c4m_notify_subscribe_content_of_interest' => TRUE,
  ];

  if (!empty($valid_message_types[$message_entity->type])) {
    _c4m_message_format_from_field_to_default_pattern($message);
  }
}

/**
 * Implements hook_mail_alter().
 *
 * Adds ability to alter message fields per message type.
 * Example:
 *   On the 'c4m_welcome_to_group' message type we set a special format at the
 *   'From' field.
 */
function c4m_message_mail_alter(&$message) {
  if (empty($message['params']['message_entity'])) {
    // There's no message entity inside - return early.
    return;
  }

  // Default from form: $message['from'] = "capacity4dev <site_mail>".
  _c4m_message_format_from_website($message);

  // Exception: $message['from'] = "The capacity4dev team <site_mail>".
  _c4m_message_format_from_the_team($message);

  // Exception: $message['from'] = "Firstname Lastname <site_mail>".
  _c4m_message_format_from_user_first_last($message);
}

/**
 * Modifies messages 'From' field to the default pattern.
 *
 * @param object $message
 *   Mail message entity.
 * @param object $message_entity
 *   Message API entity.
 */
function _c4m_message_format_from_field_to_default_pattern(&$message, $message_entity = NULL) {
  $account = NULL;

  if (!empty($message_entity)) {
    $wrapper = entity_metadata_wrapper('message', $message_entity);
    $account = $wrapper->field_executing_user->value();
  }

  $message['from'] = c4m_message_get_from_field_default_pattern($account);
}

/**
 * Returns the default pattern for FROM field.
 *
 * Pattern is "[user_name] at [site_name]"<[email]>.
 * Example "Alan Turing at capacity4dev.eu"<alan@turing.com>.
 *
 * @param object $account
 *   Account to resolve [user_name] and [email] from.
 */
function c4m_message_get_from_field_default_pattern($account = NULL) {
  if (!isset($account)) {
    // If $account is not provided, global user will be used.
    global $user;
    $account = $user;
  }

  return format_string(
    '"@name at @site"<@mail>',
    [
      '@name' => c4m_user_name($account),
      '@site' => variable_get('site_name'),
      '@mail' => variable_get('site_mail'),
    ]
  );
}

/**
 * Helper function.
 *
 * Modifies messages 'From' field, to match pattern:
 * "[name]"<automated-notifications@noreply.ec.europa.eu>.
 *
 * @param object $message
 *   Message entity.
 * @param bool $add_team
 *   Whether to add 'team' into [name], or not.
 */
function _c4m_message_format_from_field_to_simple_pattern(&$message, $add_team = FALSE) {
  $name = variable_get('site_name');

  if ($add_team) {
    $name = 'The ' . $name . ' team';
  }

  $message['from'] = format_string('"@name"<@mail>', [
    '@name' => $name,
    '@mail' => variable_get('site_mail'),
  ]);
}

/**
 * Returns TRUE if the messaging system should handle this entity.
 *
 * @param object $entity
 *   Current entity.
 * @param string $entity_type
 *   Entity type.
 * @param string $op
 *   Operation type.
 *
 * @return bool
 *   TRUE if the messaging system should handle this entity.
 */
function c4m_message_handle_entity($entity, $entity_type, $op) {
  $valid_entity_types = c4m_message_get_valid_entity_types();

  if (!in_array($entity_type, $valid_entity_types)) {
    // Not an entity related to message.
    return FALSE;
  }

  $valid_node_types = c4m_message_get_valid_node_types($op);

  if ($entity_type == 'node' && !in_array($entity->type, $valid_node_types)) {
    // Not a node related to message.
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements hook_entity_load().
 *
 * Add callbacks to the arguments. Instead of hardcoding them, we add those
 * arguments on the fly.
 */
function c4m_message_entity_load($entities, $entity_type) {
  if ($entity_type != 'message') {
    return;
  }

  foreach ($entities as $entity) {

    list(, , $bundle) = entity_extract_ids($entity_type, $entity);
    $func = 'c4m_message_load__' . $bundle;

    if (function_exists($func)) {
      // Call the delegated load function.
      $func($entity);
    }
  }
}

/**
 * Replaces callback function for message params, with their resolved value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_resolve_tokens(Message $message) {
  foreach ($message->arguments as &$argument) {

    if (empty($argument['callback'])) {
      continue;
    }

    $callback = $argument['callback'];
    if (isset($callback) && function_exists($callback)) {
      $argument = $callback($message);
    }
  }
}

/**
 * Add callbacks to c4m_log_group_state_change message arguments.
 *
 * For each token at message template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_log_group_state_change(Message $message) {
  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_request_approved message arguments.
 *
 * For each token at message template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_request_approved(Message $message) {
  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@member_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@site_contact_link'] = [
    'callback' => 'c4m_message_format_site_contact_link',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_welcome_to_group message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_welcome_to_group(Message $message) {
  $message->arguments['@member_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_welcome_message'] = [
    'callback' => 'c4m_message_format_group_welcome_message',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!go_public_profile_url'] = [
    'callback' => 'c4m_message_format_group_owner_public_profile_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@go_full_name'] = [
    'callback' => 'c4m_message_format_group_owner_full_name',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_new_membership_request message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_new_membership_request(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_full_name'] = [
    'callback' => 'c4m_message_format_new_member_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_organisation'] = [
    'callback' => 'c4m_message_format_new_member_organisation',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_organisation_type'] = [
    'callback' => 'c4m_message_format_new_member_organisation_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_country'] = [
    'callback' => 'c4m_message_format_new_member_country',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_expertise'] = [
    'callback' => 'c4m_message_format_new_member_expertise',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_about_me'] = [
    'callback' => 'c4m_message_format_new_member_self_description',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_pending_member_url'] = [
    'callback' => 'c4m_message_format_group_pending_member_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!new_member_public_profile_url'] = [
    'callback' => 'c4m_message_format_new_member_public_profile_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_request_message'] = [
    'callback' => 'c4m_message_format_new_member_request_message',
    'pass message' => TRUE,
  ];

  $message->arguments['!membership_approve_url'] = [
    'callback' => 'c4m_message_format_autologin_approve_membership_link',
    'pass message' => TRUE,
  ];

  $message->arguments['!membership_reject_url'] = [
    'callback' => 'c4m_message_format_autologin_reject_membership_link',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_user_membership_pending message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_user_membership_pending(
  Message $message
) {
  $message->arguments['@member_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_new_member_joined message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_new_member_joined(Message $message) {

  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_full_name'] = [
    'callback' => 'c4m_message_format_new_member_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_organisation'] = [
    'callback' => 'c4m_message_format_new_member_organisation',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_organisation_type'] = [
    'callback' => 'c4m_message_format_new_member_organisation_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_country'] = [
    'callback' => 'c4m_message_format_new_member_country',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_expertise'] = [
    'callback' => 'c4m_message_format_new_member_expertise',
    'pass message' => TRUE,
  ];

  $message->arguments['@new_member_about_me'] = [
    'callback' => 'c4m_message_format_new_member_self_description',
    'pass message' => TRUE,
  ];

  $message->arguments['!new_member_public_profile_url'] = [
    'callback' => 'c4m_message_format_new_member_public_profile_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_archived message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_archived(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_former_status'] = [
    'callback' => 'c4m_message_format_group_former_status',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_unpublished message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_unpublished(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_former_status'] = [
    'callback' => 'c4m_message_format_group_former_status',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_published message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_published(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_republished message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_republished(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_former_status'] = [
    'callback' => 'c4m_message_format_group_former_status',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_admins_membership_accepted message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_admins_membership_accepted(
  Message $message
) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@related_user_full_name'] = [
    'callback' => 'c4m_message_format_new_member_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@related_user_organisation'] = [
    'callback' => 'c4m_message_format_new_member_organisation',
    'pass message' => TRUE,
  ];

  $message->arguments['@related_user_organisation_type'] = [
    'callback' => 'c4m_message_format_new_member_organisation_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@related_user_country'] = [
    'callback' => 'c4m_message_format_new_member_country',
    'pass message' => TRUE,
  ];

  $message->arguments['@related_user_expertise'] = [
    'callback' => 'c4m_message_format_new_member_expertise',
    'pass message' => TRUE,
  ];

  $message->arguments['!related_user_public_profile_url'] = [
    'callback' => 'c4m_message_format_new_member_public_profile_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_log_group_admin_demoted message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_admin_demoted(Message $message) {
  $message->arguments['@member_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_message_url'] = [
    'callback' => 'c4m_message_format_event_user_message_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_content_recommendation message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_content_recommendation(
  Message $message
) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_node_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_type_name'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!content_node_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_recommend_count'] = [
    'callback' => 'c4m_message_format_node_recommend_count',
    'pass message' => TRUE,
  ];

  $message->arguments['@node_teaser_body'] = [
    'callback' => 'c4m_message_format_node_body_teaser',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_unsubscribe_recommend_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to group content inserts or updates messages arguments.
 *
 * For each token at email template, assigns a function that will be used to
 * resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_content_inserted_or_updated(Message $message) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_node_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_type_name'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!content_node_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_group_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_content_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_node_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to content inserts or updates messages arguments.
 *
 * For each token at email template, assigns a function that will be used to
 * resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_content_inserted_or_updated(Message $message) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_node_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_type_name'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!content_node_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_content_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_subscribe_content_of_interest message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_content_of_interest(
  Message $message
) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_node_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@content_type_name'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!content_node_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@term_name'] = [
    'callback' => 'c4m_message_format_taxonomy_term_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_term_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_taxonomy_term_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_new_content_share_published message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_content_share_inserted_or_updated(
  Message $message
) {
  $message->arguments['!original_group_dashboard_url'] = [
    'callback' => 'c4m_message_format_original_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@original_group_node_title'] = [
    'callback' => 'c4m_message_format_original_group_node_title',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_requested message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_requested(Message $message) {
  $message->arguments['@group_owner_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_subscribers_new_comment message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_subscribers_new_comment(
  Message $message
) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_content_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_content_type'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_content_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_teaser_body'] = [
    'callback' => 'c4m_message_format_comment_body_teaser',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_content_comments_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_content_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_url'] = [
    'callback' => 'c4m_message_format_comment_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_reply_url'] = [
    'callback' => 'c4m_message_format_comment_reply_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_access_change message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_access_change(Message $message) {
  $message->arguments['@group_admin_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_permissions'] = [
    'callback' => 'c4m_message_format_group_permissions',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_promoted_member message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_promoted_member(Message $message) {
  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_message_url'] = [
    'callback' => 'c4m_message_format_event_user_message_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@member_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_notify_content_followers_new_comment message tokens.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_notify_content_followers_new_comment(
  Message $message
) {
  $message->arguments['@user_full_name'] = [
    'callback' => 'c4m_message_format_addressee_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_content_title'] = [
    'callback' => 'c4m_message_format_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_content_type'] = [
    'callback' => 'c4m_message_format_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_content_url'] = [
    'callback' => 'c4m_message_format_node_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@comment_teaser_body'] = [
    'callback' => 'c4m_message_format_comment_body_teaser',
    'pass message' => TRUE,
  ];

  $message->arguments['!unsubscribe_content_comments_url'] = [
    'callback' => 'c4m_message_format_unsubscribe_content_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!user_settings_url'] = [
    'callback' => 'c4m_message_format_user_settings_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_url'] = [
    'callback' => 'c4m_message_format_comment_url',
    'pass message' => TRUE,
  ];

  $message->arguments['!comment_reply_url'] = [
    'callback' => 'c4m_message_format_comment_reply_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_request_submitted message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_request_submitted(Message $message
) {
  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@message_to_site_admins'] = [
    'callback' => 'c4m_message_format_group_message_to_admins',
    'pass message' => TRUE,
  ];

  $message->arguments['!pending_groups_overview'] = [
    'callback' => 'c4m_message_format_pending_groups_overview',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_group_soft_deleted message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_group_soft_deleted(Message $message) {
  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!help_section_url'] = [
    'callback' => 'c4m_message_format_help_section_url',
    'pass message' => TRUE,
  ];
}

/**
 * Add callbacks to c4m_membership_request_rejected message arguments.
 *
 * For each token at email template, assigns a function that will be used
 * to resolve token value.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_tokens__c4m_membership_request_rejected(
  Message $message
) {
  $message->arguments['!group_dashboard_url'] = [
    'callback' => 'c4m_message_format_group_url',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_title'] = [
    'callback' => 'c4m_message_format_group_node_title',
    'pass message' => TRUE,
  ];

  $message->arguments['@group_node_type'] = [
    'callback' => 'c4m_message_format_group_node_type',
    'pass message' => TRUE,
  ];

  $message->arguments['@event_user_full_name'] = [
    'callback' => 'c4m_message_format_event_user_full_name',
    'pass message' => TRUE,
  ];

  $message->arguments['!event_user_url'] = [
    'callback' => 'c4m_message_format_event_user_url',
    'pass message' => TRUE,
  ];
}

/**
 * Returns message addressee user ID.
 *
 * @param Message $message
 *   The Message entity - used to retrieve required info.
 *
 * @return int
 *   Returns addressee's user ID.
 */
function c4m_message_format_addressee_uid(Message $message) {
  return $message->uid;
}

/**
 * Returns the of group message refers to.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   Returns group ID.
 */
function c4m_message_format_group_gid(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_node->value(['identifier' => TRUE]);
}

/**
 * Returns addressee full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns addressee's full name.
 */
function c4m_message_format_addressee_full_name(Message $message) {
  $user = user_load($message->uid);

  return c4m_user_name($user);
}

/**
 * Returns new member full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's full name.
 */
function c4m_message_format_new_member_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $new_member = $wrapper->field_related_user->value();

  return c4m_user_name($new_member);
}

/**
 * Returns new member organisation.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's organisation.
 */
function c4m_message_format_new_member_organisation(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_related_user->c4m_organisation->value();
}

/**
 * Returns new member organisation type.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's organisation type.
 */
function c4m_message_format_new_member_organisation_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_related_user->c4m_organisation_type->label();
}

/**
 * Returns new member country.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's country.
 */
function c4m_message_format_new_member_country(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $field = field_info_field('c4m_country');
  $allowed_values = list_allowed_values($field);
  $index = $wrapper->field_related_user->c4m_country->value();

  return empty($index) ? '' : $allowed_values[$index];
}

/**
 * Returns new member expertise.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a comma separated string of member's expertise.
 */
function c4m_message_format_new_member_expertise(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $expertises = $wrapper->field_related_user->c4m_vocab_topic_expertise->value();
  $expertise_names = [];

  foreach ($expertises as $expertise) {
    $expertise_names[] = $expertise->name;
  }

  return implode(', ', $expertise_names);
}

/**
 * Returns new member self description.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns member's self description.
 */
function c4m_message_format_new_member_self_description(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $related_user = $wrapper->field_related_user->value();

  return empty($related_user->c4m_body) ? '' : strip_tags(
    $wrapper->field_related_user->c4m_body->value->value()
  );
}

/**
 * Returns a link to new member membership management.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member membership management.
 */
function c4m_message_format_group_pending_member_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $gid = $wrapper->field_group_node->value(['identifier' => TRUE]);
  $mid = $wrapper->field_group_membership->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url(
    'group/node/' . $gid . '/admin/people/edit-membership/' . $mid,
    $options
  );
}

/**
 * Returns a link to new member public profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member public profile.
 */
function c4m_message_format_new_member_public_profile_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_related_user->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('user/' . $uid, $options);
}

/**
 * Returns a link to new member public profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to new member public profile.
 */
function c4m_message_format_new_member_request_message(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_membership->og_membership_request->value();
}

/**
 * Returns group owner full name token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group owner full name.
 * */
function c4m_message_format_group_owner_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $author = $wrapper->field_group_node->author->value();

  return c4m_user_name($author);
}

/**
 * Returns group url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group url.
 */
function c4m_message_format_group_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $nid = $wrapper->field_group_node->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('node/' . $nid, $options);
}

/**
 * Returns original group url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group url.
 */
function c4m_message_format_original_group_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $node = entity_metadata_wrapper('node', $wrapper->field_node->value());

  $group_wrapper = entity_metadata_wrapper(
    'node',
    $node->og_group_ref->value()
  );

  $url_options = [
    'absolute' => TRUE,
    'purl' => [
      'provider' => 'og_purl|node',
      'enabled' => TRUE,
      'id' => $group_wrapper->nid->value(),
    ],
  ];

  return url('<front>', $url_options);
}

/**
 * Returns help guidance url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return help guidance url.
 */
function c4m_message_format_help_section_url(Message $message) {
  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('help-guidance/help-guidance', $options);
}

/**
 * Returns site contact link token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Site contact link.
 */
function c4m_message_format_site_contact_link(Message $message) {
  return 'mailto:capacity4dev@ec.europa.eu';
}

/**
 * Returns group title token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group title.
 */
function c4m_message_format_group_node_title(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_group_node->label();
}

/**
 * Returns original group title token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group title.
 */
function c4m_message_format_original_group_node_title(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $node = entity_metadata_wrapper('node', $wrapper->field_node->value());

  $group_wrapper = entity_metadata_wrapper(
    'node',
    $node->og_group_ref->value()
  );

  return $group_wrapper->title->value();
}

/**
 * Returns group welcome message token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group welcome message.
 */
function c4m_message_format_group_welcome_message(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  // Projects do not have 'welcome message' field.
  if ($wrapper->field_group_node->type->value() == 'project') {
    return '';
  }

  $group_message = $wrapper->field_group_node->c4m_group_welcome_message->value();

  return $group_message ? $group_message : '';
}

/**
 * Returns group node type token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group node type.
 */
function c4m_message_format_group_node_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $group_type = $wrapper->field_group_node->getBundle();

  return $group_type ? $group_type : '';
}

/**
 * Returns group message to admin token (entered by group requester).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return message to admin, which is entered by group requester.
 */
function c4m_message_format_group_message_to_admins(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  if (!isset($wrapper->field_group_node->field_message_to_site_admin)) {
    return '';
  }

  return $wrapper->field_group_node->field_message_to_site_admin->value();
}

/**
 * Returns group edit url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group edit url.
 */
function c4m_message_format_pending_groups_overview(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $group = $wrapper->field_group_node->value();

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('admin/c4m/' . $group->type . 's/pending', $options);
}

/**
 * Returns group owner url token.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Return group owner url.
 */
function c4m_message_format_group_owner_public_profile_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $author_id = $wrapper->field_group_node->author->getIdentifier();

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('user/' . $author_id, $options);
}

/**
 * Returns the ID of user that executed the event.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   User ID.
 */
function c4m_message_format_event_user_id(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_executing_user->value(['identifier' => TRUE]);
}

/**
 * Returns full name of user that executed the event.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   User full name.
 */
function c4m_message_format_event_user_full_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return c4m_user_name($wrapper->field_executing_user->value());
}

/**
 * Returns a link to event user contact page.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to event user contact page.
 */
function c4m_message_format_event_user_message_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_executing_user->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('user/' . $uid . '/contact', $options);
}

/**
 * Returns a link to event user profile.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Returns a link to event user public profile.
 */
function c4m_message_format_event_user_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $uid = $wrapper->field_executing_user->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url('user/' . $uid, $options);
}

/**
 * Returns the title of attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node title.
 */
function c4m_message_format_node_title(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_node->label();
}

/**
 * Returns the type of attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node type.
 */
function c4m_message_format_node_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $node = $wrapper->field_node->value();

  return node_type_get_name($node);
}

/**
 * Returns the path to attached node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node path.
 */
function c4m_message_format_node_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url(
    'node/' . $wrapper->field_node->value(['identifier' => TRUE]),
    $options
  );
}

/**
 * Returns direct url to reply on comment.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Direct path to reply on comment.
 */
function c4m_message_format_comment_reply_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $node_id = $wrapper->field_node->value(['identifier' => TRUE]);
  $comment_id = $wrapper->field_comment->value(['identifier' => TRUE]);

  $options = [
    'absolute' => TRUE,
  ];

  return url('comment/reply/' . $node_id . '/' . $comment_id, $options);
}

/**
 * Returns direct url to comment.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Direct path to comment.
 */
function c4m_message_format_comment_url(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $node_url = c4m_message_format_node_url($message);
  $comment_id = $wrapper->field_comment->value(['identifier' => TRUE]);

  // Url example: http://capacity4more.dev/nobelprize/wiki/prizes#comment-24.
  return $node_url . '#comment-' . $comment_id;
}

/**
 * Returns number of times attached node was recommended.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return int
 *   Number of recommendations.
 */
function c4m_message_format_node_recommend_count(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $property_info = [
    'flag_name' => 'c4m_og_content_recommend',
  ];
  $count = c4m_helper_entity_entity_get_properties(
    $node,
    [],
    '',
    'node',
    $property_info
  );

  return empty($count) ? 0 : $count;
}

/**
 * Returns a teaser of content's body (intro text, if it's an article).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node body teaser.
 */
function c4m_message_format_node_body_teaser(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $teaser_field = ($node->type == 'article') ? 'c4m_intro_text' : 'c4m_body';
  if (empty($node->{$teaser_field})) {
    return '';
  }

  $body_teaser = field_view_field('node', $node, $teaser_field, 'teaser');

  return strip_tags($body_teaser[0]['#markup']);
}

/**
 * Returns a teaser of nodes body.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Node body teaser.
 */
function c4m_message_format_comment_body_teaser(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $comment = $wrapper->field_comment->value();
  $body_teaser = field_view_field(
    'comment',
    $comment,
    'comment_body',
    'teaser'
  );

  return strip_tags($body_teaser[0]['#markup']);
}

/**
 * Returns a url that is used to unsubscribe from following node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_unsubscribe_node_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'node');
}

/**
 * Returns a url that is used to manage settings.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_user_settings_url(Message $message) {
  return _c4m_message_format_user_settings_url($message);
}

/**
 * Returns a url that is used to unsubscribe from following content.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_unsubscribe_content_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'content');
}

/**
 * Returns a url that is used to unsubscribe from following a group.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function c4m_message_format_unsubscribe_group_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'group');
}

/**
 * Helper function.
 *
 * Returns a url that is used to unsubscribe from following an entity that is
 * embedded inside message.
 *
 * @param Message $message
 *   The Message entity.
 * @param string $flag_suffix
 *   The suffix of flag that is used to track message entity.
 *
 * @return string
 *   Unsubscribe url.
 */
function _c4m_message_format_unsubscribe_url(Message $message, $flag_suffix) {
  $wrapper = entity_metadata_wrapper('message', $message);

  switch ($flag_suffix) {
    case 'group':
      $field = 'field_group_node';
      break;

    case 'content':
      $field = 'field_node';
      break;

    default:
      $field = "field_{$flag_suffix}";
      break;
  }

  $entity_id = $wrapper->$field->value(['identifier' => TRUE]);

  $uid = $message->uid;
  $hash = c4m_user_profile_get_unsubscribe_hash($uid, $flag_suffix, $entity_id);

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url(
    'user/' . $uid . '/unsubscribe/' . $flag_suffix . '/' . $entity_id . '/' . $hash,
    $options
  );
}

/**
 * Helper function.
 *
 * Returns a url that is used to manage your settings.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Settings url.
 */
function _c4m_message_format_user_settings_url(Message $message) {
  $uid = $message->uid;

  $options = [
    'absolute' => TRUE,
    'purl' => ['disabled' => TRUE],
  ];

  return url(
    'user/' . $uid . '/settings',
    $options
  );
}

/**
 * Returns a url that is used to approve membership request embedded at message.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Approve membership auto login link.
 */
function c4m_message_format_autologin_approve_membership_link(Message $message
) {
  return _c4m_message_format_autologin_control_membership_link(
    $message,
    'approve'
  );
}

/**
 * Returns a url that is used to reject membership request embedded at message.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   Reject membership auto login link.
 */
function c4m_message_format_autologin_reject_membership_link(Message $message) {
  return _c4m_message_format_autologin_control_membership_link(
    $message,
    'reject'
  );
}

/**
 * Helper function.
 *
 * Returns a url that is used to approve/reject membership request which is
 * embedded inside message.
 *
 * @param Message $message
 *   The Message entity.
 * @param string $action
 *   Approve / Reject.
 *
 * @return string
 *   $action membership auto login link.
 */
function _c4m_message_format_autologin_control_membership_link(
  Message $message,
  $action
) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $membership = $wrapper->field_group_membership->value();
  $user = user_load($message->uid);

  return c4m_og_autologin_control_membership_link($user, $membership, $action);
}

/**
 * Returns the types that applicable for a message.
 *
 * @param string $op
 *   Name of the operation performed on entity.
 *
 * @return array
 *   The node types for messages.
 */
function c4m_message_get_valid_node_types($op) {
  $valid_node_types = [
    'discussion',
    'event',
    'news',
    'photo',
    'photoalbum',
    'share',
    'document',
    'wiki_page',
  ];

  // Show message for the type 'article' when the operation is not 'update'.
  if ($op != 'update') {
    array_push($valid_node_types, 'article');
  }

  return $valid_node_types;
}

/**
 * Delegate message CRUD to message type specific functions.
 *
 * @param string $entity_type
 *   The entity type.
 * @param object $entity
 *   The entity object.
 * @param string $op
 *   The operation to perform. Possible values are "insert" or "update".
 *
 * @return void|Message
 *   The saved message object, or NULL if not created or updated.
 */
function c4m_message_crud_message($entity_type, $entity, $op) {
  // Do not create a message if no user is associated with the entity.
  if (!isset($entity->uid) || (isset($entity->uid) && $entity->uid < 1)) {
    $entity->_skip_message = TRUE;
  }

  if (!empty($entity->_skip_message)) {
    // Entity should not create a message.
    return FALSE;
  }

  if (!c4m_message_handle_entity($entity, $entity_type, $op)) {
    return NULL;
  }

  // When a new photo is being uploaded to a photo album, we should create an
  // update message of the photo album itself instead of a message of the
  // photo (CFM-1456).
  if ($entity_type == 'node' && $photo_album = c4m_content_photo_get_photo_album(
      $entity
    )
  ) {
    // Skip this message when coming from a migration.
    if (!empty($entity->migrate)) {
      return NULL;
    }

    // Update the correct time.
    $photo_album->timestamp = $entity->timestamp;
    $op = 'update';
    $entity = $photo_album;
  }

  $message = NULL;

  $func = 'c4m_message__' . $op . '__' . $entity_type;
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $bundle_func = $func . '__' . $bundle;

  if (function_exists($bundle_func)) {
    // Call the bundle specific function.
    $message = $bundle_func($entity);
  }
  elseif (function_exists($func)) {
    // Call the entity specific function.
    $message = $func($entity);
  }

  if ($message) {
    $message_wrapper = entity_metadata_wrapper('message', $message);
    $message_wrapper->field_entity_published->set($entity->status);
    if (isset($message_wrapper->field_operation)) {
      $message_wrapper->field_operation->set($op);
    }
    $message->save();

    // Clear cache for activity stream.
    _c4m_message_clear_activity_stream_cache();
  }

  return $message;
}

/**
 * Returns the list of valid entity types for messages.
 *
 * @return array
 *   List of entity types.
 */
function c4m_message_get_valid_entity_types() {
  return [
    'comment',
    'node',
    'taxonomy_term',
    'og_membership',
  ];
}

/**
 * A general function to add arguments for node related messages.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load_general_arguments(Message $message) {
  $message->arguments['!date'] = [
    'callback' => 'c4m_message_format_date_for_message',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_info'] = [
    'callback' => 'c4m_messages_group_info',
    'pass message' => TRUE,
  ];
}

/**
 * Replace the date value of a message with a formatted value.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The formatted date.
 */
function c4m_message_format_date_for_message(Message $message) {
  return c4m_helper_date_format_relative_date($message->timestamp);
}

/**
 * Get group info for activity stream.
 *
 * @param Message $message
 *   The message object.
 *
 * @return string
 *   The group info.
 *
 * @throws \EntityMetadataWrapperException
 *    Throws EntityMetadataWrapperException error.
 */
function c4m_messages_group_info(Message $message) {
  $group_info = '';
  $get_query = drupal_get_query_parameters();

  // Add group info for activity stream on the homepage,
  // When the request is from RESTful, "drupal_is_front_page" won't work.
  $handler = og_purl_og_context_handler();
  if (((drupal_is_front_page() || !empty($get_query['homepage']))
    && empty($handler) || (isset($get_query['group'])
      && is_array($get_query['group'])))
  ) {
    if (isset($message->field_group_node) && !empty($message->field_group_node)) {
      $wrapper = entity_metadata_wrapper('message', $message);
      $link = l(
        $wrapper->field_group_node->label(),
        $wrapper->field_group_node->value()->purl
      );
      $group_info = t('Group: !link', ['!link' => $link]);
    }
  }

  return $group_info;
}

/**
 * Delegated hook_entity_load() for node of "discussion" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__discussion(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "news" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__news(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "article" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__article(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "wiki_page" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__wiki_page(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "document" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__document(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "photo" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__photo(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['@photoalbum'] = [
    'callback' => 'c4m_message_format_photo_photoalbum',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "share" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__share(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];
  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_node_share',
    'pass message' => TRUE,
  ];

  $message->arguments['!group'] = [
    'callback' => 'c4m_message_format_group_share',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_type'] = [
    'callback' => 'c4m_message_format_original_group_type',
    'pass message' => TRUE,
  ];

  $message->arguments['!group_original'] = [
    'callback' => 'c4m_message_format_original_group_share',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "photoalbum" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__photoalbum(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for node of "event" bundle.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__node__event(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_node',
    'pass message' => TRUE,
  ];

  $message->arguments['@operation'] = [
    'callback' => 'c4m_message_format_operation',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Delegated hook_entity_load() for comment.
 *
 * Add Message arguments callbacks.
 *
 * @param Message $message
 *   The Message entity.
 */
function c4m_message_load__c4m_insert__comment(Message $message) {
  c4m_message_load_general_arguments($message);

  $message->arguments['@node_type'] = [
    'callback' => 'c4m_message_format_comment',
    'pass message' => TRUE,
  ];

  $message->arguments['!content'] = [
    'callback' => 'c4m_message_format_rendered_comment',
    'pass message' => TRUE,
  ];

  $message->arguments['!icon'] = [
    'callback' => 'c4m_message_format_node_icon',
    'pass message' => TRUE,
  ];
}

/**
 * Return the formatted operation name (added or updated).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The action text.
 */
function c4m_message_format_operation(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $operation = $wrapper->field_operation->value();
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  switch ($operation) {
    case 'insert':
      $op = $info['insert action'];
      break;

    case 'update':
    default:
      $op = $info['update action'];
      break;
  }

  return $op;
}

/**
 * Return the photoalbum title of the inserted photo.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The photoalbum if exists or an empty string.
 */
function c4m_message_format_photo_photoalbum(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $album_label = $wrapper->field_node->node_gallery_ref_1->label();

  return $album_label ? 'to the Photo album ' . $album_label : '';
}

/**
 * Return the formatted node type.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The Comment type.
 */
function c4m_message_format_comment(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  return format_string(
    '@article @node_type',
    ['@article' => $info['article'], '@node_type' => $info['singular']]
  );
}

/**
 * Return the formatted body and image.
 *
 * We get the body and image on te fly, in case a user edited the content - not
 * to show an outdated teaser.
 * We use a view mode to control the rendered node.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The formated string.
 */
function c4m_message_format_rendered_node(Message $message) {
  $get_query = drupal_get_query_parameters();
  $wrapper = entity_metadata_wrapper('message', $message);

  // Determine if the current display is for homepage.
  if (isset($get_query['homepage'])) {
    $homepage = $get_query['homepage'] == '1';
  }
  else {
    $homepage = drupal_is_front_page() && !og_context();
  }

  $object = menu_get_object();
  $is_topic_page = !empty($object->type) && $object->type == 'topic';

  $view_mode = $homepage || $is_topic_page ? 'activity_global' : 'activity_group';
  $view = node_view($wrapper->field_node->value(), $view_mode);

  return drupal_render($view);
}

/**
 * Return the formatted body and image.
 *
 * Retrieve proper icon for a content type (and maybe subtype).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_node_icon(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $node = $wrapper->field_node->value();

  $info = c4m_helper_entity_label_info($node);

  $icon_tag = [
    '#type' => 'html_tag',
    '#tag' => 'i',
    '#value' => '',
    '#attributes' => ['class' => ['fa', $info['icon']]],
  ];

  return drupal_render($icon_tag);
}

/**
 * Return the formatted "shared to" group info.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_group_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $group_wrapper = entity_metadata_wrapper(
    'node',
    $wrapper->field_node->og_group_ref->value()
  );

  $url_options = [
    'absolute' => TRUE,
    'purl' => [
      'provider' => 'og_purl|node',
      'id' => $group_wrapper->nid->value(),
      'enabled' => TRUE,
    ],
  ];

  $bundle = $group_wrapper->getBundle();
  drupal_alter('c4m_content_bundle', $bundle, $group_wrapper);

  return t(
    '@group_type !group_url',
    [
      '@group_type' => $bundle,
      '!group_url' => l(
        $group_wrapper->title->value(),
        url('<front>', $url_options)
      ),
    ]
  );
}

/**
 * Return the formatted "original group".
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_original_group_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $original_entity = entity_metadata_wrapper(
    'node',
    $wrapper->field_node->c4m_source_entity->value()
  );
  $group_wrapper = entity_metadata_wrapper(
    'node',
    $original_entity->og_group_ref->value()
  );

  return l(
    $group_wrapper->title->value(),
    url(
      'node/' . $group_wrapper->get('nid')->value(),
      ['purl' => ['disabled' => TRUE], 'absolute' => TRUE]

    )
  );
}

/**
 * Return the original group type (group|project).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The group type.
 */
function c4m_message_format_original_group_type(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $original_entity = entity_metadata_wrapper(
    'node',
    $wrapper->field_node->c4m_source_entity->value()
  );
  $group_wrapper = entity_metadata_wrapper(
    'node',
    $original_entity->og_group_ref->value()
  );

  return $group_wrapper->getBundle();
}

/**
 * Return the formatted share operation.
 *
 * Retrieve proper icon for a content type (and maybe subtype).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_node_share(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  $original_node = $wrapper->field_node->c4m_source_entity->value();

  $info = c4m_helper_entity_label_info($original_node);

  return t(
    'shared @article @node_type',
    ['@article' => $info['article'], '@node_type' => $info['singular']]
  );
}

/**
 * Return the formatted unsubscribe url for taxonomy terms.
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The unsubscribe link.
 */
function c4m_message_format_unsubscribe_taxonomy_term_url(Message $message) {
  return _c4m_message_format_unsubscribe_url($message, 'taxonomy_term');
}

/**
 * Return the formatted share operation.
 *
 * Retrieve proper icon for a content type (and maybe subtype).
 *
 * @param Message $message
 *   The Message entity.
 *
 * @return string
 *   The icon class.
 */
function c4m_message_format_taxonomy_term_name(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);

  return $wrapper->field_taxonomy_term->label();
}

/**
 * Return the body of the comment.
 *
 * @param Message $message
 *   The message object.
 *
 * @return string
 *   Rendered comment.
 */
function c4m_message_format_rendered_comment(Message $message) {
  $wrapper = entity_metadata_wrapper('message', $message);
  $get_query = drupal_get_query_parameters();

  // Determine if the current display is for a group or homepage.
  $view_mode = 'activity_global';

  // Determine if the current display is within a group context.
  $context = og_context();

  if (isset($get_query['homepage']) && $get_query['homepage'] == '0' || $context) {
    $view_mode = 'activity_group';
  }

  $view = comment_view(
    $wrapper->field_comment->value(),
    $wrapper->field_node->value(),
    $view_mode
  );

  return drupal_render($view);
}

/**
 * Create a comment message.
 *
 * @param object $comment
 *   The comment object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__insert__comment($comment) {
  $values = ['uid' => $comment->uid];
  $message = message_create('c4m_insert__comment', $values);

  $node = node_load($comment->nid);
  c4m_message_prepare_insert_entity($message, 'node', $node);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->field_comment->set($comment);

  return $message;
}

/**
 * Updating a comment message.
 *
 * @param object $comment
 *   The comment object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__update__comment($comment) {
  $time_since = time() - variable_get('c4m_message_join_messages', '36000');

  // Load existing message that is not older than the threshold for the current
  // node.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'message')
    ->propertyCondition('type', 'c4m_insert__comment')
    ->propertyCondition('timestamp', $time_since, '>')
    ->fieldCondition('field_node', 'target_id', $comment->nid)
    ->fieldCondition('field_comment', 'target_id', $comment->cid)
    ->propertyOrderBy('timestamp', 'desc')
    ->range(0, 1)
    ->execute();

  $message = NULL;
  if (!empty($result['message'])) {
    $id = key($result['message']);
    $message = message_load($id);
  }

  if (!$message) {
    // Message doesn't exist - create a new message.
    $values = ['uid' => $comment->uid];
    $message = message_create('c4m_insert__comment', $values);
  }
  $node = node_load($comment->nid);
  c4m_message_prepare_insert_entity($message, 'node', $node);
  $message_wrapper = entity_metadata_wrapper('message', $message);
  $message_wrapper->field_comment->set($comment);

  return $message;
}

/**
 * Create a node message.
 *
 * @param object $node
 *   The node object.
 *
 * @return Message
 *   The non-saved message entity.
 */
function c4m_message__insert__node($node) {
  // Do not create message for activity stream, as we deal with
  // unpublished content.
  if ($node->status == NODE_NOT_PUBLISHED) {
    return FALSE;
  }

  $values = ['uid' => $node->uid];
  $message = message_create('c4m_insert__node__' . $node->type, $values);

  c4m_message_prepare_insert_entity($message, 'node', $node);

  return $message;
}

/**
 * Updating a node message.
 *
 * @param object $node
 *   The node object.
 * @param object $account
 *   The user object.
 *
 * @return Message
 *   The non-saved message entity, or NULL if update shouldn't occur.
 */
function c4m_message__update__node($node, $account = NULL) {
  // Do not create/update message for activity stream, as we deal with
  // unpublished content.
  if ($node->status == NODE_NOT_PUBLISHED) {
    return FALSE;
  }

  // When user unchecked the "create new revision" checkbox we should not
  // create an activity stream message.
  // However, this is not correct in case content is being published (status
  // changes from NODE_NOT_PUBLISHED to NODE_PUBLISHED).
  // Therefore, we cancel activity stream creation only if content status
  // does not change.
  // We know that current status is NODE_PUBLISHED, so it's enough to
  // verify that original status was NODE_PUBLISHED as well.
  if (empty($node->revision) && $node->original->status == NODE_PUBLISHED) {
    return FALSE;
  }

  if (empty($account)) {
    global $user;
    $account = clone $user;
  }

  if ($account->uid == 0) {
    // Drush has user "0". Assign updates to the original node creator.
    $account = user_load($node->uid);
  }

  // If the "Send notification" on the form is checked then we should by pass
  // the threshold since the user explicitly wants to send a notification
  // (meaning creating a new message).
  $send_notification_bypass = !empty($node->c4m_send_notification);

  // If we use the bypass we can spare the hit to the DB.
  if (!$send_notification_bypass) {
    $time_since = time() - variable_get('c4m_message_join_messages', '36000');
    // Load existing message that is not older than the threshold for the
    // current node.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'message')
      ->propertyCondition('type', 'c4m_insert__node__' . $node->type)
      ->propertyCondition('timestamp', $time_since, '>')
      ->fieldCondition('field_node', 'target_id', $node->nid)
      ->propertyOrderBy('timestamp', 'desc')
      ->range(0, 1)
      ->execute();
  }

  $message = NULL;
  if (!$send_notification_bypass && !empty($result['message'])) {
    $id = key($result['message']);
    $message = message_load($id);
    $wrapper = entity_metadata_wrapper('message', $message);

    if ($message->uid == $user->uid) {
      if ($wrapper->field_operation->value() == 'update') {
        // When an existing item is updated within the threshold time after the
        // PREVIOUS UPDATE by the SAME user who did the last update.
        $message->timestamp = $node->timestamp;
      }
      else {
        // When an existing item is updated within the threshold time after the
        // initial insert by the SAME user.
        return FALSE;
      }
    }
    else {
      // Need to create new message, not to update existing one.
      $values = [
        'uid' => $account->uid,
        'timestamp' => $node->timestamp,
      ];
      $message = message_create(
        'c4m_insert__node__' . $node->type,
        $values,
        $account
      );
    }
  }
  else {
    // More than the threshold - need to create a new message.
    $values = [
      'uid' => $account->uid,
      'timestamp' => $node->timestamp,
    ];
    $message = message_create(
      'c4m_insert__node__' . $node->type,
      $values,
      $account
    );
  }
  if ($message) {
    c4m_message_prepare_insert_entity($message, 'node', $node);
  }

  return $message;
}

/**
 * Set the message fields values.
 *
 * @param Message $message
 *   The message entity.
 * @param string $entity_type
 *   The entity type.
 * @param object $entity
 *   The Entity for we create/update message.
 */
function c4m_message_prepare_insert_entity(
  Message &$message,
  $entity_type,
  $entity
) {
  $message_wrapper = entity_metadata_wrapper('message', $message);
  if ($entity_type != 'node') {
    return;
  }

  $node_wrapper = entity_metadata_wrapper($entity_type, $entity);
  $node = $entity;

  $message_wrapper->field_node->set($node);

  if (!isset($node_wrapper->{OG_AUDIENCE_FIELD})) {
    return;
  }

  if (!$node_wrapper->{OG_AUDIENCE_FIELD}->value()) {
    return;
  }

  $group_id = $node_wrapper->{OG_AUDIENCE_FIELD}->value(
    ['identifier' => TRUE]
  );
  $message_wrapper->field_group_node->set($group_id);
}

/**
 * Node preprocess.
 */
function c4m_message_preprocess_node(&$variables) {
  if ($variables['view_mode'] == 'activity_group' || $variables['view_mode'] == 'activity_global') {
    $variables['theme_hook_suggestions'][] = 'node__activity_stream';
    $variables['theme_hook_suggestions'][] = 'node__' . $variables['node']->type . '__activity_stream';
  }
  $preprocess_function = "c4m_message_preprocess_node__{$variables['node']->type}";
  if (function_exists($preprocess_function)) {
    $preprocess_function($variables);
  }
}

/**
 * Node document preprocess.
 */
function c4m_message_preprocess_node__document(&$variables) {
  if ($variables['view_mode'] != 'activity_group' && $variables['view_mode'] != 'activity_global') {
    // Current view mode is not an 'activity stream'.
    return;
  }

  $node = $variables['node'];
  $node_wrapper = entity_metadata_wrapper('node', $node);

  $document = $node_wrapper->c4m_document->value();
  if (empty($document)) {
    // There is no file.
    $variables['download_link'] = '';
    $variables['file_info'] = '';
    return;
  }

  $file_uri = file_load($document['fid']);
  $download = file_entity_download_uri($file_uri);
  $variables['download_link'] = l(
    t('Download this Document'),
    $download['path'],
    $download['options']
  );
  $file_size = format_size($document['filesize']);
  $file_type = $document['type'];
  $variables['file_info'] = t(
    'Filetype: @filetype | Filesize: @filesize',
    ['@filetype' => $file_type, '@filesize' => $file_size]
  );
}

/**
 * Node event preprocess.
 */
function c4m_message_preprocess_node__event(&$variables) {
  if ($variables['view_mode'] != 'activity_group' && $variables['view_mode'] != 'activity_global') {
    // Current view mode is not an 'activity stream'.
    return;
  }

  $node = $variables['node'];
  $node_wrapper = entity_metadata_wrapper('node', $node);

  $start = $node_wrapper->c4m_datetime_end->value->value();
  $end = $node_wrapper->c4m_datetime_end->value2->value();

  $start_date = format_date($start, 'custom', 'd/m/Y');
  $end_date = format_date($end, 'custom', 'd/m/Y');

  $start_date_time = format_date($start, 'custom', 'd/m/Y H:i');
  $end_date_time = $start_date == $end_date
    ? format_date($end, 'custom', 'H:i')
    : format_date($end, 'custom', 'd/m/Y H:i');

  $variables['event_info'] = t(
    'From @start to @end',
    ['@start' => $start_date_time, '@end' => $end_date_time]
  );
}

/**
 * Adds the activity stream to the AngularJs app.
 *
 * Depending on if the user is logged in or not,
 * The activity stream is loaded from the user's groups,
 * Or from all the public groups if user is anonymous.
 */
function c4m_message_load_homepage_activity_stream() {
  global $user;
  $get_query = drupal_get_query_parameters();

  // Get filter value.
  $filter = !empty($get_query['filter'])
    ? $get_query['filter']
    : '';
  $groups = [];
  $interests = [];
  $hide_articles = FALSE;
  $group_context = (bool) og_context();

  // Checks if this is an Authenticated user.
  if ($user->uid) {
    switch ($filter) {
      case 'groups':
        // Gets all the group IDs that the user belongs to.
        $groups = c4m_og_get_user_group_ids_by_bundle('group');
        $hide_articles = TRUE;
        break;

      case 'projects':
        // Gets all the project IDs that the user belongs to.
        $groups = c4m_og_get_user_group_ids_by_bundle('project');
        $hide_articles = TRUE;
        break;

      case 'interests':
        // Get user's interests.
        $user_wrapper = entity_metadata_wrapper('user', $user->uid);
        $interests = $user_wrapper->c4m_vocab_topic->raw();

        // Get groups that have topics from user's interests
        // but user is not member of these groups (we already have this list).
        $query = new EntityFieldQuery();

        $query
          ->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'group')
          ->propertyCondition('status', NODE_PUBLISHED);
        if (!empty($groups)) {
          $query->propertyCondition('nid', $groups, 'NOT IN');
        }
        if (!empty($interests)) {
          $query->fieldCondition('c4m_vocab_topic', 'tid', $interests, 'IN');
        }

        $result = $query->execute();

        if (!empty($result['node'])) {
          $groups = array_merge($groups, array_keys($result['node']));
        }
        break;

      case 'showAll':
      default:
        $groups = [];
        break;
    }
  }

  $request = [
    'group' => $groups,
    'topics' => $interests,
    'html' => TRUE,
    // Sort the activity stream by timestamp descending.
    'sort' => '-timestamp',
    'homepage' => '1',
    'hide_articles' => $hide_articles,
    'group_context' => $group_context,
  ];

  $activities = c4m_message_get_activities($request);

  // URL options.
  $options = [
    'purl' => [
      'disabled' => TRUE,
    ],
    'absolute' => TRUE,
  ];

  // Pass info via Drupal.settings.
  $settings['c4m'] = [
    'basePath' => url('', $options),
    'csrfToken' => drupal_get_token(\RestfulInterface::TOKEN_VALUE),
    'activities' => $activities,
    'data' => [
      'request' => $request,
      'entity' => ['group' => $groups],
    ],
  ];
  drupal_add_js($settings, 'setting');
}

/**
 * Helper to get activity stream items with caching layer.
 *
 * @param array $request
 *   Request array (settings) that are unique to the result.
 *
 * @return array
 *   Array of (rendered) activities.
 */
function c4m_message_get_activities(array $request) {
  global $user;

  // Generate a key based on the request array + the user id.
  // It is used for node access later so the results might differ from one user
  // to the other.
  $cache_key = md5(json_encode($request + ['uid' => $user->uid]));

  $cache = cache_get($cache_key, 'cache_activity_stream');

  if ($cache && time() < $cache->expire) {
    $activities = $cache->data;
  }
  else {
    // Load the activity stream.
    $activity_stream_handler = restful_get_restful_handler('activity_stream');

    // Lazyloader is not compatible with Activity stream which uses Angular for
    // rendering. So, we should make sure it's disabled while loading the
    // Activity stream.
    $lazyloader_status = variable_get('lazyloader_enabled', TRUE);
    variable_set('lazyloader_enabled', FALSE);
    $activities = $activity_stream_handler->get('', $request);
    variable_set('lazyloader_enabled', $lazyloader_status);

    cache_set($cache_key, $activities, 'cache_activity_stream', time() + C4M_MESSAGE_EXPIRE_TIME);
  }

  return $activities;
}

/**
 * Helper to clear the activity stream caches.
 *
 * We use db_truncate instead of cache_clear_all because our cache items are
 * marked as permanent so they may not get deleted.
 */
function _c4m_message_clear_activity_stream_cache() {
  if (!db_table_exists('cache_activity_stream')) {
    return;
  }

  db_truncate('cache_activity_stream')->execute();
}

/**
 * Implements hook_flush_caches().
 *
 * This hook is called in drupal_flush_all_caches. Normally it should return
 * custom bins to be cleared. We need special handling for cache_activity_stream
 * bin so we just call our custom function and not return anything. Similar code
 * can be found in system_flush_caches().
 */
function c4m_message_flush_caches() {
  _c4m_message_clear_activity_stream_cache();
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Changes the join of the group field to "LEFT" join,
 * So it's possible to get messages without this field,
 * Also changes the condition from AND to OR.
 * (field group has those values OR is null).
 */
function c4m_message_query_activity_stream_homepage_alter(SelectQuery &$query) {
  $tables = &$query->getTables();
  $conditions = &$query->conditions();

  $tables['field_data_field_group_node1']['join type'] = 'LEFT';
  $values = $conditions[1]['value'];
  $or = db_or()
    ->condition('field_group_node_target_id', $values, 'IN')
    ->isNull('field_group_node_target_id');
  $query->condition($or);

  foreach ($conditions as $key => $condition) {
    if (isset($condition['field']) && !is_object(
        $condition['field']
      ) && $condition['field'] == 'field_data_field_group_node1.field_group_node_target_id'
    ) {
      unset($conditions[$key]);
    }
  }
}

/**
 * Alter field access for activity stream entities.
 *
 * @param \SelectQuery $query
 *   The query to be altered.
 */
function c4m_message_query_activity_stream_entity_field_access_alter(
  SelectQuery &$query
) {
  $query->addMetaData('base_table', 'field_data_field_group_node');

  global $user;

  // Read meta-data from query, if provided.
  if (!$account = $query->getMetaData('account')) {
    $account = $user;
  }
  if (!$op = $query->getMetaData('op')) {
    $op = 'view';
  }

  // If $account can bypass node access, or there are no node access modules,
  // or the operation is 'view' and the $account has a global view grant
  // (such as a view grant for node ID 0), we don't need to alter the query.
  if (user_access('bypass node access', $account)) {
    return;
  }
  if (!count(module_implements('node_grants'))) {
    return;
  }
  if ($op == 'view' && node_access_view_all_nodes($account)) {
    return;
  }

  $tables = $query->getTables();
  $base_table = $query->getMetaData('base_table');

  // Find all instances of the base table being joined -- could appear
  // more than once in the query, and could be aliased. Join each one to
  // the node_access table.
  $grants = node_access_grants($op, $account);

  $node_conditions = db_and();

  foreach ($tables as $nalias => $tableinfo) {
    $table = $tableinfo['table'];
    if (!($table instanceof SelectQueryInterface) && $table == $base_table) {
      // Set the subquery.
      $subquery = db_select('node_access', 'na')
        ->fields('na', ['nid']);

      // Plugable_node_access model does not take into consideration restricted
      // group status ('c4m_og_status' field), while non members that match the
      // restriction, may view such a group, only if it's at published or
      // archived states.
      // To resolve 'c4m_og_status' of group, join with
      // field_data_c4m_og_status table.
      $subquery->leftJoin(
        'field_data_c4m_og_status',
        'gst',
        'na.nid = gst.entity_id'
      );
      $pluggable_node_access_grants = pluggable_node_access_node_grants(
        $account,
        $op
      );

      $grant_conditions = db_or();
      // If any grant exists for the specified user, then user has access
      // to the node for the specified operation.
      foreach ($grants as $realm => $gids) {
        foreach ($gids as $gid) {
          $grant_condition = db_and()
            ->condition('na.gid', $gid)
            ->condition('na.realm', $realm);

          // If grants is allocated by pluggable_node_access model,
          // add group status condition - status may be either published
          // or archived.
          if (in_array($realm, array_keys($pluggable_node_access_grants))) {
            $group_status_condition = db_or()
              ->condition('gst.c4m_og_status_value', 'published')
              ->condition('gst.c4m_og_status_value', 'archived');

            $grant_condition->condition($group_status_condition);
          }

          $grant_conditions->condition($grant_condition);
        }
      }

      // Attach conditions to the subquery for nodes.
      if (count($grant_conditions->conditions())) {
        $subquery->condition($grant_conditions);
      }
      $subquery->condition('na.grant_' . $op, 1, '>=');
      $field = 'nid';
      // Now handle entities.
      // Set a common alias for entities.
      $base_alias = $nalias;
      $field = 'field_group_node_target_id';
      $subquery->where("$nalias.$field = na.nid");

      // For an entity query, attach the subquery to entity conditions.
      $node_conditions->exists($subquery);
    }

    // Needed for the sharing functionality,
    // which adds node access on node level.
    if (!($table instanceof SelectQueryInterface) && $table == 'node') {
      if (!node_access_view_all_nodes()) {
        // Prevent duplicates records.
        $query->distinct();
        // The recognized operations are 'view', 'update', 'delete'.
        if (!$op = $query->getMetaData('op')) {
          $op = 'view';
        }
        // Skip the extra joins and conditions for node admins.
        if (!user_access('bypass node access')) {
          // The node_access table has the access grants for any given node.
          $access_alias = $query->join(
            'node_access',
            'na',
            '%alias.nid = node.nid'
          );
          $or = db_or();
          // If any grant exists for the specified user,
          // then user has access to the node for the specified operation.
          foreach (node_access_grants(
                     $op,
                     $query->getMetaData('account')
                   ) as $realm => $gids) {
            foreach ($gids as $gid) {
              $or->condition(
                db_and()
                  ->condition($access_alias . '.gid', $gid)
                  ->condition($access_alias . '.realm', $realm)
              );
            }
          }

          if (count($or->conditions())) {
            $query->condition($or);
          }

          $query->condition($access_alias . '.grant_' . $op, 1, '>=');
        }
      }
    }
  }

  if (count($subquery->conditions())) {
    // All the node access conditions are only for field values belonging to
    // nodes.
    $node_conditions->condition("$base_alias.entity_type", 'message');
    $or = db_or();
    $or->condition($node_conditions);
    // If the field value belongs to a non-node entity type then this function
    // does not do anything with it.
    $or->condition("$base_alias.entity_type", 'message', '<>');
    $or->isNull('gn.field_group_node_target_id');
    // Add the compiled set of rules to the query.
    $query->condition($or);
  }
}

/**
 * Implements hook_c4m_helper_entity_metrics_info().
 */
function c4m_message_c4m_helper_entity_metrics_info() {
  return [
    'c4m_user_last_activity' => [
      'type' => 'last_activity',
      'context' => 'user',
      'callback' => 'c4m_message_get_user_last_activity',
    ],
  ];
}

/**
 * Returns the date & time of the last activity of an user.
 *
 * @param int $uid
 *   User ID.
 *
 * @return string
 *   Date.
 */
function c4m_message_get_user_last_activity($uid) {
  $query = db_select('message', 'm');
  $query->fields('m', ['timestamp']);
  $query->condition('uid', $uid);
  $query->orderBy('timestamp', 'DESC');
  $query->range(0, 1);

  $query = $query->execute();
  $amount = $query->fetchCol();

  if ($amount) {
    return date('d/m/Y H:i', $amount[0]);
  }
  else {
    return '';
  }
}

/**
 * Gets the specified condition index in the query where hierarchy.
 *
 * @param array $query_filter
 *   The query->where array to search.
 * @param string $field
 *   The specific field name we wish to find.
 *
 * @return array
 *   An associative array of the filter group and index of the requested
 *   condition.
 */
function c4m_message_get_query_condition_index_by_field_name(
  array $query_filter,
  $field
) {
  foreach ($query_filter as $group_index => $group) {
    foreach ($group['conditions'] as $condition_index => $condition) {
      if (is_string($condition['field']) && $condition['field'] == $field) {
        return [
          'group' => $group_index,
          'index' => $condition_index,
        ];
      }
    }
  }
  return [];
}

/**
 * Implements hook_views_query_alter().
 *
 * Filter the activity stream by the user's choice.
 */
function c4m_message_views_query_alter(&$view, &$query) {
  if ($view->name != 'global_activity_stream_no_js_fallback') {
    return;
  }

  $filter_by = filter_input(INPUT_GET, 'filter', FILTER_SANITIZE_STRING);

  if ($filter_by == 'groups' || $filter_by == 'projects') {
    // `rtrim` removes plural 's' from the query string value to get the bundle.
    $groups = c4m_og_get_user_group_ids_by_bundle(rtrim($filter_by, 's'));
    $condition = c4m_message_get_query_condition_index_by_field_name(
      $query->where,
      'field_data_field_group_node.field_group_node_target_id'
    );
    $query->where[$condition['group']]['conditions'][$condition['index']]['value'] = $groups;
    $query->where[$condition['group']]['conditions'][$condition['index']]['operator'] = 'IN';
  }
  else {
    // Remove the filter criteria when the users chooses to show all activity or
    // filter by interests rather than by groups or projects.
    $condition = c4m_message_get_query_condition_index_by_field_name(
      $query->where,
      'field_data_field_group_node.field_group_node_target_id'
    );
    unset($query->where[$condition['group']]);
  }
}

/**
 * Redirect the user to the homepage + query string ?filter=.
 *
 * For the global activity stream, when JS is not enabled, this function will
 * redirect to the correct path when filtering the content by groups, projects
 * or interests.
 */
function c4m_features_homepage_filter_form_create_submit(
  array &$form,
  array &$form_state
) {
  $options = [
    'query' => [
      'filter' => $form_state['values']['homepage-filter'],
    ],
  ];
  $form_state['redirect'] = ['<front>', $options];
}

/**
 * Implements hook_menu().
 */
function c4m_message_menu() {
  $items = [];

  $items['activity/%message/delete'] = [
    'page callback' => 'drupal_get_form',
    'page arguments' => ['c4m_message_delete_message_confirm', 1],
    'access callback' => 'c4m_message_delete_message_access',
    'access arguments' => [1],
  ];

  return $items;
}

/**
 * Page callback for delete message menu item.
 */
function c4m_message_delete_message_confirm($form, &$form_state, $message) {
  $form['mid'] = ['#type' => 'value', '#value' => $message->mid];
  $form['destination'] = ['#type' => 'value', '#value' => $_GET['destination']];

  $question = t('Are you sure you want to delete this message?');
  return confirm_form($form, $question, $_GET['destination']);
}

/**
 * Submit callback for delete message confirm form.
 */
function c4m_message_delete_message_confirm_submit($form, &$form_state) {
  message_delete_multiple([$form_state['values']['mid']]);
  $form_state['redirect'] = $form_state['values']['destination'];
}

/**
 * Access callback for delete message menu item.
 *
 * @param object $message
 *   Message object.
 */
function c4m_message_delete_message_access($message) {
  if (!isset($message->field_group_node[LANGUAGE_NONE][0]['target_id'])) {
    // No group for the message. User should be SA.
    return c4m_user_is_site_admin();
  }
  else {
    $group = node_load($message->field_group_node[LANGUAGE_NONE][0]['target_id']);
    // User should be GA or GO or SA.
    return c4m_features_og_members_is_power_user($group);
  }
}
